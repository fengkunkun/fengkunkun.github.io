<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>VS Code插件推荐</title>
      <link href="/2019/06/20/VS%20Code%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90/"/>
      <url>/2019/06/20/VS%20Code%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90/</url>
      
        <content type="html"><![CDATA[<h5 id="VS-Code插件推荐"><a href="#VS-Code插件推荐" class="headerlink" title="VS Code插件推荐"></a>VS Code插件推荐</h5><p>前端工具</p><a id="more"></a><h1 id="1-Open-In-Browser"><a href="#1-Open-In-Browser" class="headerlink" title="1. Open-In-Browser"></a>1. Open-In-Browser</h1><p>由于 VSCode 没有提供直接在浏览器中打开文件的内置界面，所以此插件在快捷菜单中添加了在默认浏览器查看文件选项，以及在客户端（Firefox，Chrome，IE）中打开命令面板选项。</p><h1 id="2-Quokka"><a href="#2-Quokka" class="headerlink" title="2. Quokka"></a>2. Quokka</h1><p>Quokka 是一个调试工具插件，能够根据你正在编写的代码提供实时反馈。它易于配置，并能够预览变量的函数和计算值结果。另外，在使用 JSX 或 TypeScript 项目中，它能够开箱即用。</p><h1 id="3-Faker"><a href="#3-Faker" class="headerlink" title="3. Faker"></a>3. Faker</h1><p>使用流行的 JavaScript 库 – Faker，能够帮你快速的插入用例数据。Faker 可以随机生成姓名、地址、图像、电话号码，或者经典的乱数假文段落，并且每个类别还包含了各种子类别，你可以根据自身的需求来使用这些数据。</p><h1 id="4-CSS-Peek"><a href="#4-CSS-Peek" class="headerlink" title="4. CSS Peek"></a>4. CSS Peek</h1><p>使用此插件，你可以追踪至样式表中 CSS 类和 ids 定义的地方。当你在 HTML 文件中右键单击选择器时，选择“ Go to Definition 和 Peek definition ”选项，它便会给你发送样式设置的 CSS 代码。</p><h1 id="5-HTML-Boilerplate"><a href="#5-HTML-Boilerplate" class="headerlink" title="5. HTML Boilerplate"></a>5. HTML Boilerplate</h1><p>通过使用 HTML 模版插件，你就摆脱了为 HTML 新文件重新编写头部和正文标签的苦恼。你只需在空文件中输入 html，并按 Tab 键，即可生成干净的文档结构。</p><h1 id="6-Prettier"><a href="#6-Prettier" class="headerlink" title="6. Prettier"></a>6. Prettier</h1><p>Prettier 是目前 Web 开发中最受欢迎的代码格式化程序。安装了这个插件，它就能够自动应用 Prettier，并将整个 JS 和 CSS 文档快速格式化为统一的代码样式。</p><h1 id="7-Color-Info"><a href="#7-Color-Info" class="headerlink" title="7. Color Info"></a>7. Color Info</h1><p>这个便捷的插件，将为你提供你在 CSS 中使用颜色的相关信息。你只需在颜色上悬停光标，就可以预览色块中色彩模型的（HEX、 RGB、HSL 和 CMYK）相关信息了。</p><h1 id="8-SVG-Viewer"><a href="#8-SVG-Viewer" class="headerlink" title="8. SVG Viewer"></a>8. SVG Viewer</h1><p>此插件在 Visual Studio 代码中添加了许多实用的 SVG 程序，你无需离开编辑器，便可以打开 SVG 文件并查看它们。同时，它还包含了用于转换为 PNG 格式和生成数据 URI 模式的选项。</p><h1 id="9-TODO-Highlight"><a href="#9-TODO-Highlight" class="headerlink" title="9. TODO Highlight"></a>9. TODO Highlight</h1><p>这个插件能够在你的代码中标记出所有的 TODO 注释，以便更容易追踪任何未完成的业务。在默认的情况下，它会查找 TODO 和 FIXME 关键字。当然，你也可以添加自定义表达式。</p><h1 id="10-Icon-Fonts"><a href="#10-Icon-Fonts" class="headerlink" title="10. Icon Fonts"></a>10. Icon Fonts</h1><p>这是一个能够在项目中添加图标字体的插件。该插件支持超过 20 个热门的图标集，包括了 Font Awesome、Ionicons、Glyphicons 和 Material Design Icons。</p><h1 id="11-Minify"><a href="#11-Minify" class="headerlink" title="11. Minify"></a>11. Minify</h1><p>这是一款用于压缩合并 JavaScript 和 CSS 文件的应用程序。它提供了大量自定义的设置，以及自动压缩保存并导出为.min 文件的选项。它能够分别通过 ulifyg-js、clean-css 和 html-minifier，与 JavaScript、CSS 和 HTML 协同工作。</p><h1 id="12-Change-Case"><a href="#12-Change-Case" class="headerlink" title="12. Change Case"></a>12. Change Case</h1><p>虽然 VSCode 内置了开箱即用的文本转换选项，但其只能进行文本大小写的转换。而此插件则添加了用于修改文本的更多命名格式，包括驼峰命名、下划线分隔命名，snake_case 命名以及 CONST_CAS 命名等。</p><h1 id="13-Regex-Previewer"><a href="#13-Regex-Previewer" class="headerlink" title="13. Regex Previewer"></a>13. Regex Previewer</h1><p>这是一个用于实时测试正则表达式的实用工具。它可以将正则表达式模式应用在任何打开的文件上，并高亮所有的匹配项。</p><h1 id="14-Language-and-Framework-Packs"><a href="#14-Language-and-Framework-Packs" class="headerlink" title="14. Language and Framework Packs"></a>14. Language and Framework Packs</h1><p>VSCode 默认支持大量的主流编程语言，但如果你所使用的编程语言不包括在内，也可以通过下载扩展包来自动添加。同时，你还可以添加一些像 React Native 与 Vue 的相关 Web 开发插件包。</p><h1 id="15-Themes"><a href="#15-Themes" class="headerlink" title="15. Themes"></a>15. Themes</h1><p>当然，在众多的实用插件中，岂能少了漂亮的主题呢？你每天都会与你的 VSCode 编辑器进行“亲密的接触”，为何不把它打扮得更漂亮些呢？这里有一些帮助你更改侧边栏的配色方案，以及图标的相关主题，与大家分享：</p><h1 id="16-VSC-Netease-Music"><a href="#16-VSC-Netease-Music" class="headerlink" title="16. VSC Netease Music"></a>16. VSC Netease Music</h1><p>写代码的时候来一段网易云音乐，岂不是美滋滋，支持音乐搜索，用户登陆，收藏，每日推荐，解锁海外 IP 限制等等等等</p>]]></content>
      
      
      <categories>
          
          <category> 前端工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>前端基础 - 复习</title>
      <link href="/2018/03/20/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%20-%20%E5%A4%8D%E4%B9%A0/"/>
      <url>/2018/03/20/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%20-%20%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h5 id="前端基础-复习"><a href="#前端基础-复习" class="headerlink" title="前端基础 - 复习"></a>前端基础 - 复习</h5><p>资料整理</p><a id="more"></a><h2 id="一、CSS"><a href="#一、CSS" class="headerlink" title="一、CSS"></a>一、CSS</h2><h3 id="1-盒模型"><a href="#1-盒模型" class="headerlink" title="1. 盒模型"></a>1. 盒模型</h3><blockquote><p>页面渲染时，<code>dom</code> 元素所采用的 布局模型。可通过<code>box-sizing</code>进行设置。根据计算宽高的区域可分为</p></blockquote><ul><li><code>content-box</code> (<code>W3C</code> 标准盒模型)</li><li><code>border-box</code> (<code>IE</code> 盒模型)</li><li><code>padding-box</code></li><li><code>margin-box</code> (浏览器未实现)</li></ul><h3 id="2-BFC"><a href="#2-BFC" class="headerlink" title="2. BFC"></a>2. BFC</h3><blockquote><p>块级格式化上下文，是一个独立的渲染区域，让处于 <code>BFC</code> 内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。</p></blockquote><blockquote><p>IE下为 <code>Layout</code>，可通过 <code>zoom:1</code> 触发</p></blockquote><p><strong>触发条件:</strong></p><ul><li>根元素</li><li><code>position: absolute/fixed</code></li><li><code>display: inline-block / table</code></li><li><code>float</code> 元素</li><li><code>ovevflow !== visible</code></li></ul><p><strong>规则:</strong></p><ul><li>属于同一个 <code>BFC</code> 的两个相邻 <code>Box</code> 垂直排列</li><li>属于同一个 <code>BFC</code> 的两个相邻 <code>Box</code> 的 <code>margin</code> 会发生重叠</li><li><code>BFC</code> 中子元素的 <code>margin box</code> 的左边， 与包含块 (BFC) <code>border box</code>的左边相接触 (子元素 <code>absolute</code> 除外)</li><li><code>BFC</code> 的区域不会与 <code>float</code> 的元素区域重叠</li><li>计算 <code>BFC</code> 的高度时，浮动子元素也参与计算</li><li>文字层不会被浮动层覆盖，环绕于周围</li></ul><p><strong>应用:</strong></p><ul><li>阻止<code>margin</code>重叠</li><li>可以包含浮动元素 —— 清除内部浮动(清除浮动的原理是两个<code>div</code>都位于同一个 <code>BFC</code> 区域之中)</li><li>自适应两栏布局</li><li>可以阻止元素被浮动元素覆盖</li></ul><h3 id="3-层叠上下文"><a href="#3-层叠上下文" class="headerlink" title="3.层叠上下文"></a>3.层叠上下文</h3><blockquote><p>元素提升为一个比较特殊的图层，在三维空间中 (z轴) 高出普通元素一等。</p></blockquote><p><strong>触发条件</strong></p><ul><li>根层叠上下文(<code>html</code>)</li><li><code>position</code></li><li><code>css3</code>属性<ul><li><code>flex</code></li><li><code>transform</code></li><li><code>opacity</code></li><li><code>filter</code></li><li><code>will-change</code></li><li><code>webkit-overflow-scrolling</code></li></ul></li></ul><p><strong>层叠等级：层叠上下文在z轴上的排序</strong></p><ul><li>在同一层叠上下文中，层叠等级才有意义</li><li><code>z-index</code>的优先级最高</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/2/14/168e9d9f3a1d368b" alt=""></p><h3 id="4-居中布局"><a href="#4-居中布局" class="headerlink" title="4. 居中布局"></a>4. 居中布局</h3><p><strong>水平居中</strong></p><ul><li>行内元素: <code>text-align: center</code></li><li>块级元素: <code>margin: 0 auto</code></li><li><code>absolute + transform</code></li><li><code>flex + justify-content: center</code></li></ul><p><strong>垂直居中</strong></p><ul><li><code>line-height: height</code></li><li><code>absolute + transform</code></li><li><code>flex + align-items: center</code></li><li><code>table</code></li></ul><p><strong>水平垂直居中</strong></p><ul><li><code>absolute + transform</code></li><li><code>flex + justify-content + align-items</code></li></ul><h3 id="5-选择器优先级"><a href="#5-选择器优先级" class="headerlink" title="5. 选择器优先级"></a>5. 选择器优先级</h3><ul><li><code>!important</code> &gt; 行内样式 &gt; <code>#id</code> &gt; <code>.class</code> &gt; <code>tag</code> &gt; <code>*</code> &gt; 继承 &gt; 默认</li><li>选择器 从右往左 解析</li></ul><h3 id="6-去除浮动影响，防止父级高度塌陷"><a href="#6-去除浮动影响，防止父级高度塌陷" class="headerlink" title="6.去除浮动影响，防止父级高度塌陷"></a>6.去除浮动影响，防止父级高度塌陷</h3><ul><li>通过增加尾元素清除浮动</li><li><code>:after / &lt;br&gt; : clear: both</code></li><li>创建父级 <code>BFC</code></li><li>父级设置高度</li></ul><h3 id="7-link-与-import-的区别"><a href="#7-link-与-import-的区别" class="headerlink" title="7.link 与 @import 的区别"></a>7.link 与 @import 的区别</h3><ul><li><code>link</code>功能较多，可以定义 <code>RSS</code>，定义 <code>Rel</code> 等作用，而<code>@import</code>只能用于加载 <code>css</code></li><li>当解析到<code>link</code>时，页面会同步加载所引的 <code>css</code>，而<code>@import</code>所引用的 <code>css</code> 会等到页面加载完才被加载</li><li><code>@import</code>需要 <code>IE5</code> 以上才能使用</li><li><code>link</code>可以使用 <code>js</code> 动态引入，<code>@import</code>不行</li></ul><h3 id="8-CSS预处理器-Sass-Less-Postcss"><a href="#8-CSS预处理器-Sass-Less-Postcss" class="headerlink" title="8. CSS预处理器(Sass/Less/Postcss)"></a>8. CSS预处理器(Sass/Less/Postcss)</h3><blockquote><p><code>CSS</code>预处理器的原理: 是将类 <code>CSS</code>语言通过 <code>Webpack</code> 编译 转成浏览器可读的真正 <code>CSS</code>。在这层编译之上，便可以赋予 <code>CSS</code> 更多更强大的功能，常用功能:</p></blockquote><ul><li>嵌套</li><li>变量</li><li>循环语句</li><li>条件语句</li><li>自动前缀</li><li>单位转换</li><li><code>mixin</code>复用</li></ul><blockquote><p>面试中一般不会重点考察该点，一般介绍下自己在实战项目中的经验即可~</p></blockquote><h3 id="9-CSS动画"><a href="#9-CSS动画" class="headerlink" title="9.CSS动画"></a>9.CSS动画</h3><p><strong>transition: 过渡动画</strong></p><ul><li><code>transition-property</code>: 属性</li><li><code>transition-duration</code>: 间隔</li><li><code>transition-timing-function</code>: 曲线</li><li><code>transition-delay</code>: 延迟</li><li>常用钩子: <code>transitionend</code></li></ul><p><strong>animation / keyframes</strong></p><ul><li><code>animation-name</code>: 动画名称，对应<code>@keyframes</code></li><li><code>animation-duration</code>: 间隔</li><li><code>animation-timing-function</code>: 曲线</li><li><code>animation-delay</code>: 延迟</li><li><code>animation-iteration-count</code>: 次数<ul><li><code>infinite</code>: 循环动画</li></ul></li><li><code>animation-direction</code>: 方向<ul><li><code>alternate</code>: 反向播放</li></ul></li><li><code>animation-fill-mode</code>: 静止模式<ul><li><code>forwards</code>: 停止时，保留最后一帧</li><li><code>backwards</code>: 停止时，回到第一帧</li><li><code>both</code>: 同时运用 <code>forwards / backwards</code></li></ul></li><li>常用钩子: <code>animationend</code></li></ul><blockquote><p>动画属性: 尽量使用动画属性进行动画，能拥有较好的性能表现</p></blockquote><ul><li><code>translate</code></li><li><code>scale</code></li><li><code>rotate</code></li><li><code>skew</code></li><li><code>opacity</code></li><li><code>color</code></li></ul><h2 id="二、JavaScript"><a href="#二、JavaScript" class="headerlink" title="二、JavaScript"></a>二、JavaScript</h2><h3 id="1-原型-构造函数-实例"><a href="#1-原型-构造函数-实例" class="headerlink" title="1. 原型 / 构造函数 / 实例"></a>1. 原型 / 构造函数 / 实例</h3><ul><li>原型(<code>prototype</code>): 一个简单的对象，用于实现对象的 属性继承。可以简单的理解成对象的爹。在 <code>Firefox</code> 和 <code>Chrome</code> 中，每个<code>JavaScript</code>对象中都包含一个<code>__proto__</code>(非标准)的属性指向它爹(该对象的原型)，可<code>obj.__proto__</code>进行访问。</li><li>构造函数: 可以通过<code>new</code>来 新建一个对象 的函数。</li><li>实例: 通过构造函数和<code>new</code>创建出来的对象，便是实例。 实例通过<code>__proto__</code>指向原型，通过<code>constructor</code>指向构造函数。</li></ul><blockquote><p>以<code>Object</code>为例，我们常用的<code>Object</code>便是一个构造函数，因此我们可以通过它构建实例。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实例</span></span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br></pre></td></tr></table></figure><blockquote><p>则此时， 实例为<code>instance</code>, 构造函数为<code>Object</code>，我们知道，构造函数拥有一个<code>prototype</code>的属性指向原型，因此原型为:</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原型</span></span><br><span class="line"><span class="keyword">const</span> prototype = <span class="built_in">Object</span>.prototype</span><br></pre></td></tr></table></figure><p><strong>这里我们可以来看出三者的关系:</strong></p><ul><li><code>实例.__proto__ === 原型</code></li><li><code>原型.constructor === 构造函数</code></li><li><code>构造函数.prototype === 原型</code></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 这条线其实是是基于原型进行获取的，可以理解成一条基于原型的映射线</span><br><span class="line">&#x2F;&#x2F; 例如: </span><br><span class="line">&#x2F;&#x2F; const o &#x3D; new Object()</span><br><span class="line">&#x2F;&#x2F; o.constructor &#x3D;&#x3D;&#x3D; Object   --&gt; true</span><br><span class="line">&#x2F;&#x2F; o.__proto__ &#x3D; null;</span><br><span class="line">&#x2F;&#x2F; o.constructor &#x3D;&#x3D;&#x3D; Object   --&gt; false</span><br><span class="line">实例.constructor &#x3D;&#x3D;&#x3D; 构造函数</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2019/2/14/168e9d9b940c4c6f" alt=""></p><h3 id="2-原型链："><a href="#2-原型链：" class="headerlink" title="2.原型链："></a>2.原型链：</h3><blockquote><p>原型链是由原型对象组成，每个对象都有 <code>__proto__</code> 属性，指向了创建该对象的构造函数的原型，<code>__proto__</code> 将对象连接起来组成了原型链。是一个用来实现继承和共享属性的有限的对象链</p></blockquote><ul><li>属性查找机制: 当查找对象的属性时，如果实例对象自身不存在该属性，则沿着原型链往上一级查找，找到时则输出，不存在时，则继续沿着原型链往上一级查找，直至最顶级的原型对象<code>Object.prototype</code>，如还是没找到，则输出<code>undefined</code>；</li><li>属性修改机制: 只会修改实例对象本身的属性，如果不存在，则进行添加该属性，如果需要修改原型的属性时，则可以用: <code>b.prototype.x = 2</code>；但是这样会造成所有继承于该对象的实例的属性发生改变。</li></ul><h3 id="3-执行上下文-EC"><a href="#3-执行上下文-EC" class="headerlink" title="3. 执行上下文(EC)"></a>3. 执行上下文(EC)</h3><blockquote><p>执行上下文可以简单理解为一个对象:</p></blockquote><p><strong>它包含三个部分:</strong></p><ul><li>变量对象(<code>VO</code>)</li><li>作用域链(词法作用域)</li><li><code>this</code>指向</li></ul><p><strong>它的类型:</strong></p><ul><li>全局执行上下文</li><li>函数执行上下文</li><li><code>eval</code>执行上下文</li></ul><p><strong>代码执行过程:</strong></p><ul><li>创建 全局上下文 (<code>global EC</code>)</li><li>全局执行上下文 (<code>caller</code>) 逐行 自上而下 执行。遇到函数时，函数执行上下文 (<code>callee</code>) 被<code>push</code>到执行栈顶层</li><li>函数执行上下文被激活，成为 <code>active EC</code>, 开始执行函数中的代码，<code>caller</code> 被挂起</li><li>函数执行完后，<code>callee</code> 被<code>pop</code>移除出执行栈，控制权交还全局上下文 (<code>caller</code>)，继续执行</li></ul><h3 id="4-变量对象"><a href="#4-变量对象" class="headerlink" title="4.变量对象"></a>4.变量对象</h3><ul><li>变量对象，是执行上下文中的一部分，可以抽象为一种 数据作用域，其实也可以理解为就是一个简单的对象，它存储着该执行上下文中的所有 变量和函数声明(不包含函数表达式)。</li><li>活动对象 (<code>AO</code>): 当变量对象所处的上下文为 <code>active EC</code> 时，称为活动对象。</li></ul><h3 id="5-作用域"><a href="#5-作用域" class="headerlink" title="5. 作用域"></a>5. 作用域</h3><blockquote><p>执行上下文中还包含作用域链。理解作用域之前，先介绍下作用域。作用域其实可理解为该上下文中声明的 变量和声明的作用范围。可分为 块级作用域 和 函数作用域</p></blockquote><p><strong>特性:</strong></p><ul><li>声明提前: 一个声明在函数体内都是可见的, 函数优先于变量</li><li>非匿名自执行函数，函数变量为 只读 状态，无法修改</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="number">1</span>) &#125;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    foo = <span class="number">10</span>  <span class="comment">// 由于foo在函数中只为可读，因此赋值无效</span></span><br><span class="line">    <span class="built_in">console</span>.log(foo)</span><br><span class="line">&#125;()) </span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果打印：  ƒ foo() &#123; foo = 10 ; console.log(foo) &#125;</span></span><br></pre></td></tr></table></figure><h3 id="6-作用域链"><a href="#6-作用域链" class="headerlink" title="6.作用域链"></a>6.作用域链</h3><blockquote><p>我们知道，我们可以在执行上下文中访问到父级甚至全局的变量，这便是作用域链的功劳。作用域链可以理解为一组对象列表，包含 父级和自身的变量对象，因此我们便能通过作用域链访问到父级里声明的变量或者函数。</p></blockquote><p><strong>由两部分组成:</strong></p><ul><li><code>[[scope]]</code>属性: 指向父级变量对象和作用域链，也就是包含了父级的<code>[[scope]]</code>和<code>AO</code></li><li><code>AO</code>: 自身活动对象</li></ul><blockquote><p>如此 <code>[[scopr]]</code>包含<code>[[scope]]</code>，便自上而下形成一条 链式作用域。</p></blockquote><h3 id="7-闭包"><a href="#7-闭包" class="headerlink" title="7. 闭包"></a>7. 闭包</h3><blockquote><p>闭包属于一种特殊的作用域，称为 静态作用域。它的定义可以理解为: 父函数被销毁 的情况下，返回出的子函数的<code>[[scope]]</code>中仍然保留着父级的单变量对象和作用域链，因此可以继续访问到父级的变量对象，这样的函数称为闭包。</p></blockquote><p><strong>闭包会产生一个很经典的问题:</strong></p><blockquote><p>多个子函数的<code>[[scope]]</code>都是同时指向父级，是完全共享的。因此当父级的变量对象被修改时，所有子函数都受到影响。</p></blockquote><p>••解决:**</p><ul><li>变量可以通过 函数参数的形式 传入，避免使用默认的<code>[[scope]]</code>向上查找</li><li>使用<code>setTimeout</code>包裹，通过第三个参数传入</li><li>使用 块级作用域，让变量成为自己上下文的属性，避免共享</li></ul><h3 id="8-script-引入方式："><a href="#8-script-引入方式：" class="headerlink" title="8. script 引入方式："></a>8. script 引入方式：</h3><ul><li><code>html</code> 静态<code>&lt;script&gt;</code>引入</li><li><code>js</code> 动态插入<code>&lt;script&gt;</code></li><li><code>&lt;script defer&gt;</code>: 异步加载，元素解析完成后执行</li><li><code>&lt;script async&gt;</code>: 异步加载，但执行时会阻塞元素渲染</li></ul><h3 id="9-对象的拷贝"><a href="#9-对象的拷贝" class="headerlink" title="9. 对象的拷贝"></a>9. 对象的拷贝</h3><p><strong>浅拷贝: 以赋值的形式拷贝引用对象，仍指向同一个地址，修改时原对象也会受到影响</strong></p><ul><li><code>Object.assign</code></li><li>展开运算符(<code>...</code>)</li></ul><p><strong>深拷贝: 完全拷贝一个新对象，修改时原对象不再受到任何影响</strong></p><ul><li><code>JSON.parse(JSON.stringify(obj))</code>: 性能最快</li><li>具有循环引用的对象时，报错</li><li>当值为函数、<code>undefined</code>、或<code>symbol</code>时，无法拷贝</li><li>递归进行逐一赋值</li></ul><h3 id="10-new运算符的执行过程"><a href="#10-new运算符的执行过程" class="headerlink" title="10. new运算符的执行过程"></a>10. new运算符的执行过程</h3><ul><li>新生成一个对象</li><li>链接到原型: <code>obj.__proto__ = Con.prototype</code></li><li>绑定<code>this: apply</code></li><li>返回新对象(如果构造函数有自己 <code>retrun</code> 时，则返回该值)</li></ul><h3 id="11-instanceof原理"><a href="#11-instanceof原理" class="headerlink" title="11. instanceof原理"></a>11. instanceof原理</h3><blockquote><p>能在实例的 原型对象链 中找到该构造函数的<code>prototype</code>属性所指向的 原型对象，就返回<code>true</code>。即:</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// __proto__: 代表原型对象链</span></span><br><span class="line">instance.[__proto__...] === instance.constructor.prototype</span><br><span class="line"></span><br><span class="line"><span class="comment">// return true</span></span><br></pre></td></tr></table></figure><h3 id="12-代码的复用"><a href="#12-代码的复用" class="headerlink" title="12. 代码的复用"></a>12. 代码的复用</h3><blockquote><p>当你发现任何代码开始写第二遍时，就要开始考虑如何复用。一般有以下的方式:</p></blockquote><ul><li>函数封装</li><li>继承</li><li>复制<code>extend</code></li><li>混入<code>mixin</code></li><li>借用<code>apply/call</code></li></ul><h3 id="13-继承"><a href="#13-继承" class="headerlink" title="13. 继承"></a>13. 继承</h3><blockquote><p>在 JS 中，继承通常指的便是 原型链继承，也就是通过指定原型，并可以通过原型链继承原型上的属性或者方法。</p></blockquote><p><strong>最优化: 圣杯模式</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> inherit = (<span class="function"><span class="keyword">function</span>(<span class="params">c,p</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">c,p</span>)</span>&#123;</span><br><span class="line">F.prototype = p.prototype;</span><br><span class="line">c.prototype = <span class="keyword">new</span> F();</span><br><span class="line">c.uber = p.prototype;</span><br><span class="line">c.prototype.constructor = c;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><blockquote><p>使用 <code>ES6</code> 的语法糖 <code>class / extends</code></p></blockquote><h3 id="14-类型转换"><a href="#14-类型转换" class="headerlink" title="14. 类型转换"></a>14. 类型转换</h3><blockquote><p>大家都知道 JS 中在使用运算符号或者对比符时，会自带隐式转换，规则如下:</p></blockquote><ul><li><code>-、*、/、%</code>：一律转换成数值后计算</li><li><strong>+：</strong><ul><li>数字 + 字符串 = 字符串， 运算顺序是从左到右</li><li>数字 + 对象， 优先调用对象的<code>valueOf -&gt; toString</code></li><li>数字 + <code>boolean/null</code> -&gt; 数字</li><li>数字 + <code>undefined</code> -&gt; <code>NaN</code></li></ul></li><li><code>[1].toString() === &#39;1&#39;</code></li><li><code>{}.toString() === &#39;[object object]&#39;</code></li><li><code>NaN !== NaN</code> 、+<code>undefined</code> 为 <code>NaN</code></li></ul><h3 id="15-类型判断"><a href="#15-类型判断" class="headerlink" title="15. 类型判断"></a>15. 类型判断</h3><blockquote><p>判断 <code>Target</code> 的类型，单单用 <code>typeof</code> 并无法完全满足，这其实并不是 <code>bug</code>，本质原因是 <code>JS</code> 的万物皆对象的理论。因此要真正完美判断时，我们需要区分对待:</p></blockquote><ul><li>基本类型(<code>null</code>): 使用 <code>String(null)</code></li><li>基本类型(<code>string / number / boolean / undefined</code>) + <code>function</code>: - 直接使用 <code>typeof</code>即可</li><li>其余引用类型(<code>Array / Date / RegExp Error</code>): 调用<code>toString</code>后根据<code>[object XXX]</code>进行判断</li></ul><p>很稳的判断封装:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> class2type = &#123;&#125;</span><br><span class="line"><span class="string">'Array Date RegExp Object Error'</span>.split(<span class="string">' '</span>).forEach(<span class="function"><span class="params">e</span> =&gt;</span> class2type[ <span class="string">'[object '</span> + e + <span class="string">']'</span> ] = e.toLowerCase()) </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">type</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">null</span>) <span class="keyword">return</span> <span class="built_in">String</span>(obj)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> obj === <span class="string">'object'</span> ? class2type[ <span class="built_in">Object</span>.prototype.toString.call(obj) ] || <span class="string">'object'</span> : <span class="keyword">typeof</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="16-模块化"><a href="#16-模块化" class="headerlink" title="16. 模块化"></a>16. 模块化</h3><blockquote><p>模块化开发在现代开发中已是必不可少的一部分，它大大提高了项目的可维护、可拓展和可协作性。通常，我们 在浏览器中使用 <code>ES6</code> 的模块化支持，在 <code>Node</code> 中使用 <code>commonjs</code> 的模块化支持。</p></blockquote><p><strong>分类:</strong></p><ul><li><code>es6: import / export</code></li><li><code>commonjs: require / module.exports / exports</code></li><li><code>amd: require / defined</code></li></ul><p><strong>require与import的区别</strong></p><ul><li><code>require</code>支持 动态导入，<code>import</code>不支持，正在提案 (<code>babel</code> 下可支持)</li><li><code>require</code>是 同步 导入，<code>impor</code>t属于 异步 导入</li><li><code>require</code>是 值拷贝，导出值变化不会影响导入值；<code>import</code>指向 内存地址，导入值会随导出值而变化</li></ul><h3 id="17-防抖与节流"><a href="#17-防抖与节流" class="headerlink" title="17. 防抖与节流"></a>17. 防抖与节流</h3><blockquote><p>防抖与节流函数是一种最常用的 高频触发优化方式，能对性能有较大的帮助。</p></blockquote><ul><li>防抖 (debounce): 将多次高频操作优化为只在最后一次执行，通常使用的场景是：用户输入，只需再输入完成后做一次输入校验即可。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, wait, immediate</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span></span><br><span class="line">        <span class="keyword">let</span> context = <span class="keyword">this</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (immediate &amp;&amp; !timer) &#123;</span><br><span class="line">            fn.apply(context, args)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (timer) clearTimeout(timer)</span><br><span class="line">        timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            fn.apply(context, args)</span><br><span class="line">        &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>节流(throttle): 每隔一段时间后执行一次，也就是降低频率，将高频操作优化成低频操作，通常使用场景: 滚动条事件 或者 <code>resize</code> 事件，通常每隔 <code>100~500 ms</code>执行一次即可。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, wait, immediate</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> callNow = immediate</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="keyword">this</span>,</span><br><span class="line">            args = <span class="built_in">arguments</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (callNow) &#123;</span><br><span class="line">            fn.apply(context, args)</span><br><span class="line">            callNow = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">            timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                fn.apply(context, args)</span><br><span class="line">                timer = <span class="literal">null</span></span><br><span class="line">            &#125;, wait)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="18-函数执行改变this"><a href="#18-函数执行改变this" class="headerlink" title="18. 函数执行改变this"></a>18. 函数执行改变this</h3><ul><li>由于 JS 的设计原理: 在函数中，可以引用运行环境中的变量。因此就需要一个机制来让我们可以在函数体内部获取当前的运行环境，这便是<code>this</code>。</li></ul><blockquote><p>因此要明白 <code>this</code> 指向，其实就是要搞清楚 函数的运行环境，说人话就是，谁调用了函数。例如</p></blockquote><ul><li><code>obj.fn()</code>，便是 <code>obj</code> 调用了函数，既函数中的 <code>this === obj</code></li><li><code>fn()</code>，这里可以看成 <code>window.fn()</code>，因此 <code>this === window</code></li></ul><blockquote><p>但这种机制并不完全能满足我们的业务需求，因此提供了三种方式可以手动修改 <code>this</code> 的指向:</p></blockquote><ul><li><code>call: fn.call(target, 1, 2)</code></li><li><code>apply: fn.apply(target, [1, 2])</code></li><li><code>bind: fn.bind(target)(1,2)</code></li></ul><h3 id="19-ES6-ES7"><a href="#19-ES6-ES7" class="headerlink" title="19. ES6/ES7"></a>19. ES6/ES7</h3><blockquote><p>由于 <code>Babel</code>的强大和普及，现在 <code>ES6/ES7</code> 基本上已经是现代化开发的必备了。通过新的语法糖，能让代码整体更为简洁和易读。</p></blockquote><p><strong>声明</strong></p><ul><li><code>let / const</code>: 块级作用域、不存在变量提升、暂时性死区、不允许重复声明</li><li><code>const</code>: 声明常量，无法修改</li></ul><p><strong>解构赋值</strong></p><p><strong>class / extend: 类声明与继承</strong></p><p><strong>Set / Map: 新的数据结构</strong></p><p><strong>异步解决方案:</strong></p><ul><li><code>Promise</code>的使用与实现</li><li><code>generator</code>:<ul><li><code>yield</code>: 暂停代码</li><li><code>next()</code>: 继续执行代码</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">helloWorld</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'hello'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'world'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'ending'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> generator = helloWorld();</span><br><span class="line"></span><br><span class="line">generator.next()  <span class="comment">// &#123; value: 'hello', done: false &#125;</span></span><br><span class="line"></span><br><span class="line">generator.next()  <span class="comment">// &#123; value: 'world', done: false &#125;</span></span><br><span class="line"></span><br><span class="line">generator.next()  <span class="comment">// &#123; value: 'ending', done: true &#125;</span></span><br><span class="line"></span><br><span class="line">generator.next()  <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><blockquote><p><code>await / async</code>: 是<code>generator</code>的语法糖， <code>babel</code>中是基于<code>promise</code>实现。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getUserByAsync</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">let</span> user = <span class="keyword">await</span> fetchUser();</span><br><span class="line">   <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user = <span class="keyword">await</span> getUserByAsync()</span><br><span class="line"><span class="built_in">console</span>.log(user)</span><br></pre></td></tr></table></figure><h3 id="20-AST"><a href="#20-AST" class="headerlink" title="20. AST"></a>20. AST</h3><blockquote><p>抽象语法树 (<code>Abstract Syntax Tree</code>)，是将代码逐字母解析成 树状对象 的形式。这是语言之间的转换、代码语法检查，代码风格检查，代码格式化，代码高亮，代码错误提示，代码自动补全等等的基础。例如:</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> n * n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>通过解析转化成的AST如下图:</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2019/2/14/168e9d95910dd187?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><h3 id="21-babel编译原理"><a href="#21-babel编译原理" class="headerlink" title="21. babel编译原理"></a>21. babel编译原理</h3><ul><li><code>babylon</code> 将 <code>ES6/ES7</code> 代码解析成 <code>AST</code></li><li><code>babel-traverse</code> 对 <code>AST</code> 进行遍历转译，得到新的 <code>AST</code></li><li>新 AST 通过 <code>babel-generator</code> 转换成 <code>ES5</code></li></ul><h3 id="22-函数柯里化"><a href="#22-函数柯里化" class="headerlink" title="22. 函数柯里化"></a>22. 函数柯里化</h3><blockquote><p>在一个函数中，首先填充几个参数，然后再返回一个新的函数的技术，称为函数的柯里化。通常可用于在不侵入函数的前提下，为函数 预置通用参数，供多次重复调用。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">y</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> add1 = add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">add1(<span class="number">2</span>) === <span class="number">3</span></span><br><span class="line">add1(<span class="number">20</span>) === <span class="number">21</span></span><br></pre></td></tr></table></figure><h3 id="23-数组-array"><a href="#23-数组-array" class="headerlink" title="23. 数组(array)"></a>23. 数组(array)</h3><ul><li><code>map</code>: 遍历数组，返回回调返回值组成的新数组</li><li><code>forEach</code>: 无法<code>break</code>，可以用<code>try/catch</code>中<code>throw new Error</code>来停止</li><li><code>filter</code>: 过滤</li><li><code>some</code>: 有一项返回<code>true</code>，则整体为<code>true</code></li><li><code>every</code>: 有一项返回<code>false</code>，则整体为<code>false</code></li><li><code>join</code>: 通过指定连接符生成字符串</li><li><code>push / pop</code>: 末尾推入和弹出，改变原数组， 返回推入/弹出项</li><li><code>unshift / shift</code>: 头部推入和弹出，改变原数组，返回操作项</li><li><code>sort(fn) / reverse</code>: 排序与反转，改变原数组</li><li><code>concat</code>: 连接数组，不影响原数组， 浅拷贝</li><li><code>slice(start, end)</code>: 返回截断后的新数组，不改变原数组</li><li><code>splice(start, number, value...)</code>: 返回删除元素组成的数组，<code>value</code>为插入项，改变原数组</li><li><code>indexOf / lastIndexOf(value, fromIndex)</code>: 查找数组项，返回对应的下标</li><li><code>reduce / reduceRight(fn(prev, cur)</code>， <code>defaultPrev)</code>: 两两执行，<code>prev</code> 为上次化简函数的<code>return</code>值，<code>cur</code>为当前值(从第二项开始)</li></ul><p><strong>数组乱序：</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>];</span><br><span class="line">arr.sort(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.random() - <span class="number">0.5</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>数组拆解: flat: [1,[2,3]] –&gt; [1, 2, 3]</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.flat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.toString().split(<span class="string">','</span>).map(<span class="function"><span class="params">item</span> =&gt;</span> +item )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、浏览器"><a href="#三、浏览器" class="headerlink" title="三、浏览器"></a>三、浏览器</h2><h3 id="1-跨标签页通讯"><a href="#1-跨标签页通讯" class="headerlink" title="1. 跨标签页通讯"></a>1. 跨标签页通讯</h3><blockquote><p>不同标签页间的通讯，本质原理就是去运用一些可以 共享的中间介质，因此比较常用的有以下方法:</p></blockquote><ul><li>通过父页面<code>window.open()</code>和子页面<code>postMessage</code><ul><li>异步下，通过 <code>window.open(&#39;about: blank&#39;)</code> 和 <code>tab.location.href = &#39;*&#39;</code></li></ul></li><li>设置同域下共享的<code>localStorage</code>与监听<code>window.onstorage</code><ul><li>重复写入相同的值无法触发</li><li>会受到浏览器隐身模式等的限制</li></ul></li><li>设置共享<code>cookie</code>与不断轮询脏检查(<code>setInterval</code>)</li><li>借助服务端或者中间层实现</li></ul><h3 id="2-浏览器架构"><a href="#2-浏览器架构" class="headerlink" title="2. 浏览器架构"></a>2. 浏览器架构</h3><ul><li>用户界面</li><li>主进程</li><li>内核<ul><li>渲染引擎</li><li><code>JS</code> 引擎<ul><li>执行栈</li></ul></li></ul></li><li>事件触发线程<ul><li>消息队列<ul><li>微任务</li><li>宏任务</li></ul></li></ul></li><li>网络异步线程</li><li>定时器线程</li></ul><h3 id="3-浏览器下事件循环-Event-Loop"><a href="#3-浏览器下事件循环-Event-Loop" class="headerlink" title="3. 浏览器下事件循环(Event Loop)"></a>3. 浏览器下事件循环(Event Loop)</h3><blockquote><p>事件循环是指: 执行一个宏任务，然后执行清空微任务列表，循环再执行宏任务，再清微任务列表</p></blockquote><ul><li>微任务 <code>microtask(jobs): promise / ajax / Object.observe</code>(该方法已废弃)</li><li>宏任务 <code>macrotask(task): setTimout / script / IO / UI Rendering</code></li></ul><h3 id="4-从输入-url-到展示的过程"><a href="#4-从输入-url-到展示的过程" class="headerlink" title="4. 从输入 url 到展示的过程"></a>4. 从输入 url 到展示的过程</h3><ul><li><code>DNS</code> 解析</li><li><code>TCP</code> 三次握手</li><li>发送请求，分析 <code>url</code>，设置请求报文(头，主体)</li><li>服务器返回请求的文件 (<code>html</code>)</li><li>浏览器渲染<ul><li><code>HTML parser</code> –&gt; <code>DOM Tree</code><ul><li>标记化算法，进行元素状态的标记</li><li><code>dom</code> 树构建</li></ul></li></ul></li><li><code>CSS parser --&gt; Style Tree</code><ul><li>解析 <code>css</code> 代码，生成样式树</li></ul></li><li><code>attachment</code> –&gt; <code>Render Tree</code><ul><li>结合 dom树 与 style树，生成渲染树</li></ul></li><li><code>layout</code>: 布局</li><li><code>GPU painting</code>: 像素绘制页面</li></ul><h3 id="5-重绘与回流"><a href="#5-重绘与回流" class="headerlink" title="5. 重绘与回流"></a>5. 重绘与回流</h3><blockquote><p>当元素的样式发生变化时，浏览器需要触发更新，重新绘制元素。这个过程中，有两种类型的操作，即重绘与回流。</p></blockquote><blockquote><ul><li>重绘(repaint): 当元素样式的改变不影响布局时，浏览器将使用重绘对元素进行更新，此时由于只需要UI层面的重新像素绘制，因此 损耗较少</li><li>回流(reflow): 当元素的尺寸、结构或触发某些属性时，浏览器会重新渲染页面，称为回流。此时，浏览器需要重新经过计算，计算后还需要重新页面布局，因此是较重的操作。会触发回流的操作:</li></ul></blockquote><ul><li>页面初次渲染</li><li>浏览器窗口大小改变</li><li>元素尺寸、位置、内容发生改变</li><li>元素字体大小变化</li><li>添加或者删除可见的 <code>dom</code> 元素</li><li>激活 <code>CSS</code> 伪类（例如：<code>:hover</code>）</li><li>查询某些属性或调用某些方法<ul><li><code>clientWidth、clientHeight、clientTop、clientLeft</code></li><li><code>offsetWidth、offsetHeight、offsetTop、offsetLeft</code></li><li><code>scrollWidth、scrollHeight、scrollTop、scrollLeft</code></li><li><code>getComputedStyle()</code></li><li><code>getBoundingClientRect()</code></li><li><code>scrollTo()</code></li></ul></li></ul><blockquote><p>回流必定触发重绘，重绘不一定触发回流。重绘的开销较小，回流的代价较高。</p></blockquote><p><strong>最佳实践:</strong></p><p><strong>css</strong></p><ul><li>避免使用<code>table</code>布局</li><li>将动画效果应用到<code>position</code>属性为<code>absolute</code>或<code>fixed</code>的元素上</li></ul><p><strong>javascript</strong></p><ul><li>避免频繁操作样式，可汇总后统一 一次修改</li><li>尽量使用<code>class</code>进行样式修改</li><li>减少<code>dom</code>的增删次数，可使用 字符串 或者 <code>documentFragment</code> 一次性插入</li><li>极限优化时，修改样式可将其<code>display: none</code>后修改</li><li>避免多次触发上面提到的那些会触发回流的方法，可以的话尽量用 变量存住</li></ul><h3 id="6-存储"><a href="#6-存储" class="headerlink" title="6. 存储"></a>6. 存储</h3><blockquote><p>我们经常需要对业务中的一些数据进行存储，通常可以分为 短暂性存储 和 持久性储存。</p></blockquote><ul><li>短暂性的时候，我们只需要将数据存在内存中，只在运行时可用</li><li>持久性存储，可以分为 浏览器端 与 服务器端<ul><li>浏览器:<ul><li><code>cookie</code>: 通常用于存储用户身份，登录状态等<ul><li><code>http</code> 中自动携带， 体积上限为 <code>4K</code>， 可自行设置过期时间</li></ul></li><li><code>localStorage / sessionStorage</code>: 长久储存/窗口关闭删除， 体积限制为 <code>4~5M</code></li><li><code>indexDB</code></li></ul></li><li>服务器:<ul><li>分布式缓存 <code>redis</code></li><li>数据库 </li></ul></li></ul></li></ul><h3 id="7-Web-Worker"><a href="#7-Web-Worker" class="headerlink" title="7. Web Worker"></a>7. Web Worker</h3><blockquote><p>现代浏览器为<code>JavaScript</code>创造的 多线程环境。可以新建并将部分任务分配到<code>worker</code>线程并行运行，两个线程可 独立运行，互不干扰，可通过自带的 消息机制 相互通信。</p></blockquote><p><strong>基本用法:</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建 worker</span></span><br><span class="line"><span class="keyword">const</span> worker = <span class="keyword">new</span> Worker(<span class="string">'work.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向主进程推送消息</span></span><br><span class="line">worker.postMessage(<span class="string">'Hello World'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听主进程来的消息</span></span><br><span class="line">worker.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Received message '</span> + event.data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>限制:</strong></p><ul><li>同源限制</li><li>无法使用 <code>document / window / alert / confirm</code></li><li>无法加载本地资源</li></ul><h3 id="8-内存泄露"><a href="#8-内存泄露" class="headerlink" title="8. 内存泄露"></a>8. 内存泄露</h3><ul><li>意外的全局变量: 无法被回收</li><li>定时器: 未被正确关闭，导致所引用的外部变量无法被释放</li><li>事件监听: 没有正确销毁 (低版本浏览器可能出现)</li><li>闭包: 会导致父级中的变量无法被释放</li><li><code>dom</code> 引用: <code>dom</code> 元素被删除时，内存中的引用未被正确清空</li></ul><blockquote><p>可用 <code>chrome</code> 中的 <code>timeline</code> 进行内存标记，可视化查看内存的变化情况，找出异常点。</p></blockquote><h2 id="四、服务端与网络"><a href="#四、服务端与网络" class="headerlink" title="四、服务端与网络"></a>四、服务端与网络</h2><h3 id="1-http-https-协议"><a href="#1-http-https-协议" class="headerlink" title="1. http/https 协议"></a>1. http/https 协议</h3><p><strong>1.0 协议缺陷:</strong></p><ul><li>无法复用链接，完成即断开，重新慢启动和 <code>TCP 3</code>次握手</li><li><code>head of line blocking</code>: 线头阻塞，导致请求之间互相影响</li></ul><p><strong>1.1 改进:</strong></p><ul><li>长连接(默认 <code>keep-alive</code>)，复用</li><li><code>host</code> 字段指定对应的虚拟站点</li><li><strong>新增功能:</strong><ul><li>断点续传</li><li>身份认证</li><li>状态管理</li><li><code>cache</code> 缓存<ul><li><code>Cache-Control</code></li><li><code>Expires</code></li><li><code>Last-Modified</code></li><li><code>Etag</code></li></ul></li></ul></li></ul><p><strong>2.0:</strong></p><ul><li>多路复用</li><li>二进制分帧层: 应用层和传输层之间</li><li>首部压缩</li><li>服务端推送</li></ul><p><strong>https: 较为安全的网络传输协议</strong></p><ul><li>证书(公钥)</li><li><code>SSL</code> 加密</li><li>端口 <code>443</code></li></ul><p><strong>TCP:</strong></p><ul><li>三次握手</li><li>四次挥手</li><li>滑动窗口: 流量控制</li><li>拥塞处理<ul><li>慢开始</li><li>拥塞避免</li><li>快速重传</li><li>快速恢复</li></ul></li></ul><p><strong>缓存策略: 可分为 强缓存 和 协商缓存</strong></p><ul><li><code>Cache-Control/Expires</code>: 浏览器判断缓存是否过期，未过期时，直接使用强缓存，<code>Cache-Control</code>的 <code>max-age</code> 优先级高于 <code>Expires</code></li><li>当缓存已经过期时，使用协商缓存<ul><li>唯一标识方案: <code>Etag</code>(<code>response</code> 携带) &amp; <code>If-None-Match</code>(<code>request</code>携带，上一次返回的 <code>Etag</code>): 服务器判断资源是否被修改</li><li>最后一次修改时间: <code>Last-Modified(response) &amp; If-Modified-Since</code>(<code>request</code>，上一次返回的<code>Last-Modified</code>)<ul><li>如果一致，则直接返回 304 通知浏览器使用缓存</li><li>如不一致，则服务端返回新的资源</li></ul></li></ul></li><li><code>Last-Modified</code> 缺点：<ul><li>周期性修改，但内容未变时，会导致缓存失效</li><li>最小粒度只到 <code>s</code>， <code>s</code> 以内的改动无法检测到</li></ul></li><li><code>Etag</code> 的优先级高于<code>Last-Modified</code></li></ul><h3 id="2-常见状态码"><a href="#2-常见状态码" class="headerlink" title="2. 常见状态码"></a>2. 常见状态码</h3><ul><li><code>1xx</code>: 接受，继续处理</li><li><code>200</code>: 成功，并返回数据</li><li><code>201</code>: 已创建</li><li><code>202</code>: 已接受</li><li><code>203</code>: 成为，但未授权</li><li><code>204</code>: 成功，无内容</li><li><code>205</code>: 成功，重置内容</li><li><code>206</code>: 成功，部分内容</li><li><code>301</code>: 永久移动，重定向</li><li><code>302</code>: 临时移动，可使用原有URI</li><li><code>304</code>: 资源未修改，可使用缓存</li><li><code>305</code>: 需代理访问</li><li><code>400</code>: 请求语法错误</li><li><code>401</code>: 要求身份认证</li><li><code>403</code>: 拒绝请求</li><li><code>404</code>: 资源不存在</li><li><code>500</code>: 服务器错误</li></ul><h3 id="3-get-post"><a href="#3-get-post" class="headerlink" title="3. get / post"></a>3. get / post</h3><ul><li><code>get</code>: 缓存、请求长度受限、会被历史保存记录<ul><li>无副作用(不修改资源)，幂等(请求次数与资源无关)的场景</li></ul></li><li><code>post</code>: 安全、大数据、更多编码类型</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/2/14/168e9d9050b9d08a" alt=""></p><h3 id="4-Websocket"><a href="#4-Websocket" class="headerlink" title="4. Websocket"></a>4. Websocket</h3><blockquote><p><code>Websocket</code> 是一个 持久化的协议， 基于 <code>http</code> ， 服务端可以 主动 <code>push</code></p></blockquote><p><strong>兼容：</strong></p><blockquote><ul><li><code>FLASH Socket</code></li><li>长轮询： 定时发送 <code>ajax</code></li><li><code>long poll</code>： 发送 –&gt; 有消息时再 <code>response</code></li></ul></blockquote><ul><li><code>new WebSocket(url)</code></li><li><code>ws.onerror = fn</code></li><li><code>ws.onclose = fn</code></li><li><code>ws.onopen = fn</code></li><li><code>ws.onmessage = fn</code></li><li><code>ws.send()</code></li></ul><h3 id="5-TCP三次握手"><a href="#5-TCP三次握手" class="headerlink" title="5. TCP三次握手"></a>5. TCP三次握手</h3><blockquote><p>建立连接前，客户端和服务端需要通过握手来确认对方:</p></blockquote><ul><li>客户端发送 <code>syn</code>(同步序列编号) 请求，进入 <code>syn_send</code> 状态，等待确认</li><li>服务端接收并确认 <code>syn</code> 包后发送 <code>syn+ack</code> 包，进入 <code>syn_recv</code> 状态</li><li>客户端接收 <code>syn+ack</code> 包后，发送 <code>ack</code> 包，双方进入 <code>established</code> 状态</li></ul><h3 id="6-TCP四次挥手"><a href="#6-TCP四次挥手" class="headerlink" title="6. TCP四次挥手"></a>6. TCP四次挥手</h3><ul><li>客户端 – FIN –&gt; 服务端， FIN—WAIT</li><li>服务端 – ACK –&gt; 客户端， CLOSE-WAIT</li><li>服务端 – ACK,FIN –&gt; 客户端， LAST-ACK</li><li>客户端 – ACK –&gt; 服务端，CLOSED</li></ul><h3 id="7-Node-的-Event-Loop-6个阶段"><a href="#7-Node-的-Event-Loop-6个阶段" class="headerlink" title="7. Node 的 Event Loop: 6个阶段"></a>7. Node 的 Event Loop: 6个阶段</h3><ul><li><p><code>timer</code> 阶段: 执行到期的<code>setTimeout / setInterval</code>队列回调</p></li><li><p><code>I/O</code> 阶段: 执行上轮循环残流的<code>callback</code></p></li><li><p><code>idle</code>, <code>prepare</code></p></li><li><p><code>poll</code>: 等待回调</p><ul><li><ol><li>执行回调</li></ol></li><li><ol start="2"><li>执行定时器</li></ol><ul><li>如有到期的<code>setTimeout / setInterval</code>， 则返回 <code>timer</code> 阶段</li><li>如有<code>setImmediate</code>，则前往 <code>check</code> 阶段</li></ul></li></ul></li><li><p><code>check</code></p><ul><li>执行<code>setImmediate</code></li></ul></li><li><p><code>close callbacks</code></p></li></ul><h3 id="8-跨域"><a href="#8-跨域" class="headerlink" title="8. 跨域"></a>8. 跨域</h3><ul><li><code>JSONP</code>: 利用<code>&lt;script&gt;</code>标签不受跨域限制的特点，缺点是只能支持 <code>get</code> 请求</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonp</span>(<span class="params">url, jsonpCallback, success</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>)</span><br><span class="line">  script.src = url</span><br><span class="line">  script.async = <span class="literal">true</span></span><br><span class="line">  script.type = <span class="string">'text/javascript'</span></span><br><span class="line">  <span class="built_in">window</span>[jsonpCallback] = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    success &amp;&amp; success(data)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(script)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>设置 <code>CORS: Access-Control-Allow-Origin：*</code></li><li><code>postMessage</code></li></ul><h3 id="9-安全"><a href="#9-安全" class="headerlink" title="9. 安全"></a>9. 安全</h3><ul><li><code>XSS</code>攻击: 注入恶意代码<ul><li><code>cookie</code> 设置 <code>httpOnly</code></li><li>转义页面上的输入内容和输出内容</li></ul></li><li><code>CSRF</code>: 跨站请求伪造，防护:<ul><li><code>get</code>不修改数据</li><li>不被第三方网站访问到用户的 <code>cookie</code></li><li>设置白名单，不被第三方网站请求</li><li>请求校验</li></ul></li></ul><h2 id="五、框架：Vue"><a href="#五、框架：Vue" class="headerlink" title="五、框架：Vue"></a>五、框架：Vue</h2><h3 id="1-nextTick"><a href="#1-nextTick" class="headerlink" title="1. nextTick"></a>1. nextTick</h3><blockquote><p>在下次<code>dom</code>更新循环结束之后执行延迟回调，可用于获取更新后的<code>dom</code>状态</p></blockquote><ul><li>新版本中默认是<code>mincrotasks</code>, <code>v-on</code>中会使用<code>macrotasks</code></li><li><code>macrotasks</code>任务的实现:<ul><li><code>setImmediate / MessageChannel / setTimeout</code></li></ul></li></ul><h3 id="2-生命周期"><a href="#2-生命周期" class="headerlink" title="2. 生命周期"></a>2. 生命周期</h3><p><strong><em>init</em></strong></p><ul><li><code>initLifecycle/Event</code>，往vm上挂载各种属性</li><li><code>callHook: beforeCreated</code>: 实例刚创建</li><li><code>initInjection/initState</code>: 初始化注入和 <code>data</code> 响应性</li><li><code>created: 创建完成，属性已经绑定， 但还未生成真实</code>dom`</li><li>进行元素的挂载： <code>$el / vm.$mount()</code></li><li>是否有<code>template</code>: 解析成 <code>render function</code> <ul><li><code>*.vue</code>文件: <code>vue-loader</code>会将<code>&lt;template&gt;</code>编译成<code>render function</code></li></ul></li><li><code>beforeMount</code>: 模板编译/挂载之前</li><li>执行<code>render function</code>，生成真实的<code>dom</code>，并替换到<code>dom tree</code>中</li><li><code>mounted</code>: 组件已挂载</li></ul><p><strong>update</strong></p><ul><li>执行<code>diff</code>算法，比对改变是否需要触发<code>UI</code>更新</li><li><code>flushScheduleQueue</code></li><li><code>watcher.before</code>: 触发<code>beforeUpdate</code>钩子    - <code>watcher.run()</code>: 执行<code>watcher</code>中的 <code>notify</code>，通知所有依赖项更新UI</li><li>触发<code>updated</code>钩子: 组件已更新</li><li><code>actived / deactivated(keep-alive)</code>: 不销毁，缓存，组件激活与失活</li><li><code>destroy</code><ul><li><code>beforeDestroy</code>: 销毁开始</li><li>销毁自身且递归销毁子组件以及事件监听<ul><li><code>remove()</code>: 删除节点</li><li><code>watcher.teardown()</code>: 清空依赖</li><li><code>vm.$off()</code>: 解绑监听</li></ul></li><li><code>destroyed</code>: 完成后触发钩子</li></ul></li></ul><blockquote><p>上面是vue的声明周期的简单梳理，接下来我们直接以代码的形式来完成vue的初始化</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化Vue实例</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="comment">// 挂载属性</span></span><br><span class="line">    initLifeCycle(vm) </span><br><span class="line">    <span class="comment">// 初始化事件系统，钩子函数等</span></span><br><span class="line">    initEvent(vm) </span><br><span class="line">    <span class="comment">// 编译slot、vnode</span></span><br><span class="line">    initRender(vm) </span><br><span class="line">    <span class="comment">// 触发钩子</span></span><br><span class="line">    callHook(vm, <span class="string">'beforeCreate'</span>)</span><br><span class="line">    <span class="comment">// 添加inject功能</span></span><br><span class="line">    initInjection(vm)</span><br><span class="line">    <span class="comment">// 完成数据响应性 props/data/watch/computed/methods</span></span><br><span class="line">    initState(vm)</span><br><span class="line">    <span class="comment">// 添加 provide 功能</span></span><br><span class="line">    initProvide(vm)</span><br><span class="line">    <span class="comment">// 触发钩子</span></span><br><span class="line">    callHook(vm, <span class="string">'created'</span>)</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 挂载节点</span></span><br><span class="line">    <span class="keyword">if</span> (vm.$options.el) &#123;</span><br><span class="line">        vm.$mount(vm.$options.el)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 挂载节点实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountComponent</span>(<span class="params">vm</span>) </span>&#123;</span><br><span class="line"> <span class="comment">// 获取 render function</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.options.render) &#123;</span><br><span class="line">        <span class="comment">// template to render</span></span><br><span class="line">        <span class="comment">// Vue.compile = compileToFunctions</span></span><br><span class="line">        <span class="keyword">let</span> &#123; render &#125; = compileToFunctions() </span><br><span class="line">        <span class="keyword">this</span>.options.render = render</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 触发钩子</span></span><br><span class="line">    callHook(<span class="string">'beforeMounte'</span>)</span><br><span class="line">    <span class="comment">// 初始化观察者</span></span><br><span class="line">    <span class="comment">// render 渲染 vdom， </span></span><br><span class="line">    vdom = vm.render()</span><br><span class="line">    <span class="comment">// update: 根据 diff 出的 patchs 挂载成真实的 dom </span></span><br><span class="line">    vm._update(vdom)</span><br><span class="line">    <span class="comment">// 触发钩子  </span></span><br><span class="line">    callHook(vm, <span class="string">'mounted'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新节点实现</span></span><br><span class="line">funtion queueWatcher(watcher) &#123;</span><br><span class="line">nextTick(flushScheduleQueue)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空队列</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushScheduleQueue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="comment">// 遍历队列中所有修改</span></span><br><span class="line">    <span class="keyword">for</span>()&#123;</span><br><span class="line">    <span class="comment">// beforeUpdate</span></span><br><span class="line">        watcher.before()</span><br><span class="line">         </span><br><span class="line">        <span class="comment">// 依赖局部更新节点</span></span><br><span class="line">        watcher.update() </span><br><span class="line">        callHook(<span class="string">'updated'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁实例实现</span></span><br><span class="line">Vue.prototype.$destory = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="comment">// 触发钩子</span></span><br><span class="line">    callHook(vm, <span class="string">'beforeDestory'</span>)</span><br><span class="line">    <span class="comment">// 自身及子节点</span></span><br><span class="line">    remove() </span><br><span class="line">    <span class="comment">// 删除依赖</span></span><br><span class="line">    watcher.teardown() </span><br><span class="line">    <span class="comment">// 删除监听</span></span><br><span class="line">    vm.$off() </span><br><span class="line">    <span class="comment">// 触发钩子</span></span><br><span class="line">    callHook(vm, <span class="string">'destoryed'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-Proxy-相比于-defineProperty-的优势"><a href="#3-Proxy-相比于-defineProperty-的优势" class="headerlink" title="3. Proxy 相比于 defineProperty 的优势"></a>3. Proxy 相比于 defineProperty 的优势</h3><ul><li>数组变化也能监听到</li><li>不需要深度遍历监听</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> data = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">let</span> reactiveData = <span class="keyword">new</span> <span class="built_in">Proxy</span>(data, &#123;</span><br><span class="line"><span class="keyword">get</span>: function(target, name)&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="4-vue-router"><a href="#4-vue-router" class="headerlink" title="4. vue-router"></a>4. vue-router</h3><p><strong>mode</strong></p><ul><li><code>hash</code></li><li><code>history</code></li></ul><p><strong>跳转</strong></p><ul><li><code>this.$router.push()</code></li><li><code>&lt;router-link to=&quot;&quot;&gt;&lt;/router-link&gt;</code></li></ul><p><strong>占位</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;router-view&gt;&lt;&#x2F;router-view&gt;</span><br></pre></td></tr></table></figure><h3 id="5-vuex"><a href="#5-vuex" class="headerlink" title="5. vuex"></a>5. vuex</h3><ul><li><code>state</code>: 状态中心</li><li><code>mutations</code>: 更改状态</li><li><code>actions</code>: 异步更改状态</li><li><code>getters</code>: 获取状态</li><li><code>modules</code>: 将<code>state</code>分成多个<code>modules</code>，便于管理</li></ul><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      <categories>
          
          <category> 资料整理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>前端知识 - HTML</title>
      <link href="/2018/01/26/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%20-%20HTML/"/>
      <url>/2018/01/26/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%20-%20HTML/</url>
      
        <content type="html"><![CDATA[<h5 id="前端知识-HTML"><a href="#前端知识-HTML" class="headerlink" title="前端知识 - HTML"></a>前端知识 - HTML</h5><p>JavaScript资料整理</p><a id="more"></a><h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><hr><p><strong>语义化</strong></p><ul><li>HTML标签的语义化是指：通过使用包含语义的标签（如h1-h6）恰当地表示文档结构</li><li>css命名的语义化是指：为html标签添加有意义的class</li><li>为什么需要语义化：<ul><li>去掉样式后页面呈现清晰的结构</li><li>盲人使用读屏器更好地阅读</li><li>搜索引擎更好地理解页面，有利于收录</li><li>便团队项目的可持续运作及维护</li></ul></li></ul><p><strong>简述一下你对HTML语义化的理解？</strong></p><ul><li>用正确的标签做正确的事情。</li><li>html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析;</li><li>即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的;</li><li>搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO;</li><li>使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解</li></ul><p><strong>Doctype作用？标准模式与兼容模式各有什么区别?</strong></p><ul><li><code>&lt;!DOCTYPE&gt;</code>声明位于位<code>于HTML</code>文档中的第一行，处于 <code>&lt;html&gt;</code> 标签之前。告知浏览器的解析器用什么文档标准解析这个文档。<code>DOCTYPE</code>不存在或格式不正确会导致文档以兼容模式呈现</li><li>标准模式的排版 和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作</li></ul><p><strong>HTML5 为什么只需要写 <!DOCTYPE HTML>？</strong></p><ul><li>HTML5 不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）</li><li>而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型</li></ul><p><strong>行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？</strong></p><ul><li>行内元素有：<code>a b span img input select strong</code>（强调的语气）</li><li>块级元素有：<code>div ul ol li dl dt dd h1 h2 h3 h4…p</code></li><li>常见的空元素:<code>&lt;br&gt; &lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;link&gt; &lt;meta&gt;</code></li></ul><p><strong>页面导入样式时，使用link和@import有什么区别？</strong></p><ul><li><code>link</code>属于<code>XHTML</code>标签，除了加载<code>CSS</code>外，还能用于定义<code>RSS</code>,定义<code>rel</code>连接属性等作用；而<code>@import</code>是<code>CSS</code>提供的，只能用于加载<code>CSS</code></li><li>页面被加载的时，<code>link</code>会同时被加载，而<code>@import</code>引用的<code>CSS</code>会等到页面被加载完再加载</li><li><code>import</code>是<code>CSS2.1</code> 提出的，只在<code>IE5</code>以上才能被识别，而<code>link</code>是<code>XHTML</code>标签，无兼容问题</li></ul><p><strong>介绍一下你对浏览器内核的理解？</strong></p><ul><li>主要分成两部分：渲染引擎(<code>layout engineer</code>或<code>Rendering Engine</code>)和<code>JS</code>引擎</li><li>渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核</li><li>JS引擎则：解析和执行javascript来实现网页的动态效果</li><li>最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎</li></ul><p><strong>常见的浏览器内核有哪些？</strong></p><ul><li><code>Trident</code>内核：<code>IE,MaxThon,TT,The World,360</code>,搜狗浏览器等。[又称MSHTML]</li><li><code>Gecko</code>内核：<code>Netscape6</code>及以上版本，<code>FF,MozillaSuite/SeaMonkey</code>等</li><li><code>Presto</code>内核：<code>Opera7</code>及以上。      [<code>Opera</code>内核原为：Presto，现为：<code>Blink</code>;]</li><li><code>Webkit</code>内核：<code>Safari,Chrome</code>等。   [ <code>Chrome</code>的<code>Blink</code>（<code>WebKit</code>的分支）]</li></ul><p><strong>html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？</strong></p><ul><li>HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加<ul><li>绘画 canvas</li><li>用于媒介回放的 video 和 audio 元素</li><li>本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失</li><li>sessionStorage 的数据在浏览器关闭后自动删除</li><li>语意化更好的内容元素，比如 article、footer、header、nav、section</li><li>表单控件，calendar、date、time、email、url、search</li><li>新的技术webworker, websocket, Geolocation</li></ul></li><li>移除的元素：<ul><li>纯表现的元素：basefont，big，center，font, s，strike，tt，u</li><li>对可用性产生负面影响的元素：frame，frameset，noframes</li></ul></li><li>支持HTML5新标签：<ul><li>IE8/IE7/IE6支持通过document.createElement方法产生的标签</li><li>可以利用这一特性让这些浏览器支持HTML5新标签</li><li>浏览器支持新标签后，还需要添加标签默认的样式</li></ul></li><li>当然也可以直接使用成熟的框架、比如html5shim</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--[if lt IE 9]&gt;</span><br><span class="line">&lt;script&gt; src&#x3D;&quot;http:&#x2F;&#x2F;html5shim.googlecode.com</span><br><span class="line">&#x2F;svn&#x2F;trunk&#x2F;html5.js&quot;&lt;&#x2F;script&gt;&lt;![endif]--&gt;</span><br></pre></td></tr></table></figure><ul><li>如何区分HTML5： DOCTYPE声明\新增的结构元素\功能元素</li></ul><p><strong>HTML5的离线储存怎么使用，工作原理能不能解释一下？</strong></p><ul><li>在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件</li><li>原理：HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示</li><li>如何使用：<ul><li>页面头部像下面一样加入一个manifest的属性；</li><li>在cache.manifest文件的编写离线存储的资源</li><li>在离线状态时，操作window.applicationCache进行需求实现</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line">    #v0.11</span><br><span class="line">    CACHE:</span><br><span class="line">    js&#x2F;app.js</span><br><span class="line">    css&#x2F;style.css</span><br><span class="line">    NETWORK:</span><br><span class="line">    resourse&#x2F;logo.png</span><br><span class="line">    FALLBACK:</span><br><span class="line">    &#x2F; &#x2F;offline.html</span><br></pre></td></tr></table></figure><p><strong>浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？</strong></p><ul><li>在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。</li><li>离线的情况下，浏览器就直接使用离线存储的资源。</li></ul><p><strong>请描述一下 cookies，sessionStorage 和 localStorage 的区别？</strong></p><ul><li>cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）</li><li>cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递</li><li><code>sessionStorage</code>和<code>localStorage</code>不会自动把数据发给服务器，仅在本地保存</li><li>存储大小：<ul><li><code>cookie</code>数据大小不能超过4k</li><li><code>sessionStorage</code>和<code>localStorage</code>虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大</li></ul></li><li>有期时间：<ul><li><code>localStorage</code> 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据</li><li><code>sessionStorage</code>  数据在当前浏览器窗口关闭后自动删除</li><li><code>cookie</code>  设置的<code>cookie</code>过期时间之前一直有效，即使窗口或浏览器关闭</li></ul></li></ul><p><strong>iframe有那些缺点？</strong></p><ul><li>iframe会阻塞主页面的Onload事件</li><li>搜索引擎的检索程序无法解读这种页面，不利于SEO</li><li>iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载</li><li>使用<code>iframe</code>之前需要考虑这两个缺点。如果需要使用<code>iframe</code>，最好是通过<code>javascript</code>动态给<code>iframe</code>添加<code>src</code>属性值，这样可以绕开以上两个问题</li></ul><p><strong>Label的作用是什么？是怎么用的？</strong></p><ul><li>label标签来定义表单控制间的关系,当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件</li></ul><p><strong>HTML5的form如何关闭自动完成功能？</strong></p><ul><li>给不想要提示的 form 或某个 input 设置为 autocomplete=off。</li></ul><p><strong>如何实现浏览器内多个标签页之间的通信? (阿里)</strong></p><ul><li>WebSocket、SharedWorker</li><li>也可以调用localstorge、cookies等本地存储方式</li></ul><p><strong>webSocket如何兼容低浏览器？(阿里)</strong></p><ul><li>Adobe Flash Socket 、</li><li>ActiveX HTMLFile (IE) 、</li><li>基于 multipart 编码发送 XHR 、</li><li>基于长轮询的 XHR</li></ul><p><strong>页面可见性（Page Visibility API） 可以有哪些用途？</strong></p><ul><li>通过 visibilityState 的值检测页面当前是否可见，以及打开网页的时间等;</li><li>在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放</li></ul><p><strong>如何在页面上实现一个圆形的可点击区域？</strong></p><ul><li>map+area或者svg</li><li>border-radius</li><li>纯js实现 需要求一个点在不在圆上简单算法、获取鼠标坐标等等</li></ul><p><strong>实现不使用 border 画出1px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div style&#x3D;&quot;height:1px;overflow:hidden;background:red&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p><strong>网页验证码是干嘛的，是为了解决什么安全问题</strong></p><ul><li>区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水</li><li>有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试</li></ul><p><strong>title与h1的区别、b与strong的区别、i与em的区别？</strong></p><ul><li><code>title</code>属性没有明确意义只表示是个标题，H1则表示层次明确的标题，对页面信息的抓取也有很大的影响<!-- - `strong`是标明重点内容，有语气加强的含义，使用阅读设备阅读网络时：<strong>会重读，而<B>是展示强调内容 --></li><li>i内容展示为斜体，em表示强调的文本</li></ul><p><strong>页面导入样式时，使用 link 和 @import 有什么区别？</strong></p><ul><li>link 属于HTML标签，除了加载CSS外，还能用于定 RSS等；@import 只能用于加载CSS</li><li>页面加载的时，link 会同时被加载，而 @import 引用的 CSS 会等到页面被加载完再加载</li><li>@import 只在 IE5 以上才能被识别，而 link 是HTML标签，无兼容问题</li></ul><p><strong>介绍一下你对浏览器内核的理解？</strong></p><ul><li>浏览器内核主要分为两部分：渲染引擎(layout engineer 或 Rendering Engine) 和 JS引擎</li><li>渲染引擎负责取得网页的内容进行布局计和样式渲染，然后会输出至显示器或打印机</li><li>JS引擎则负责解析和执行JS脚本来实现网页的动态效果和用户交互</li><li>最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎</li></ul><p><strong>常见的浏览器内核有哪些？</strong></p><ul><li>Blink内核：新版 Chrome、新版 Opera</li><li>Webkit内核：Safari、原Chrome</li><li>Gecko内核：FireFox、Netscape6及以上版本</li><li>Trident内核（又称MSHTML内核）：IE、国产浏览器</li><li>Presto内核：原Opera7及以上</li></ul><p><strong>HTML5有哪些新特性？</strong></p><ul><li>新增选择器 document.querySelector、document.querySelectorAll</li><li>拖拽释放(Drag and drop) API</li><li>媒体播放的 video 和 audio</li><li>本地存储 localStorage 和 sessionStorage</li><li>离线应用 manifest</li><li>桌面通知 Notifications</li><li>语意化标签 article、footer、header、nav、section</li><li>增强表单控件 calendar、date、time、email、url、search</li><li>地理位置 Geolocation</li><li>多任务 webworker</li><li>全双工通信协议 websocket</li><li>历史管理 history</li><li>跨域资源共享(CORS) Access-Control-Allow-Origin</li><li>页面可见性改变事件 visibilitychange</li><li>跨窗口通信 PostMessage</li><li>Form Data 对象</li><li>绘画 canvas</li></ul><p><strong>HTML5移除了那些元素？</strong></p><ul><li>纯表现的元素：basefont、big、center、font、s、strike、tt、u</li><li>对可用性产生负面影响的元素：frame、frameset、noframes</li></ul><p><strong>如何处理HTML5新标签的浏览器兼容问题？</strong></p><ul><li>通过 document.createElement 创建新标签</li><li>使用垫片 html5shiv.js</li></ul><p><strong>如何区分 HTML 和 HTML5？</strong></p><ul><li>DOCTYPE声明、新增的结构元素、功能元素</li></ul><p><strong>HTML5的离线储存工作原理能不能解释一下，怎么使用？</strong></p><ul><li>HTML5的离线储存原理：<ul><li>用户在线时，保存更新用户机器上的缓存文件；当用户离线时，可以正常访离线储存问站点或应用内容</li></ul></li><li>HTML5的离线储存使用：<ul><li>在文档的 html 标签设置 manifest 属性，如 manifest=”/offline.appcache”</li><li>在项目中新建 manifest 文件，manifest 文件的命名建议：xxx.appcache</li><li>在 web 服务器配置正确的 MIME-type，即 text/cache-manifest</li></ul></li></ul><p><strong>浏览器是怎么对HTML5的离线储存资源进行管理和加载的？</strong></p><ul><li>在线的情况下，浏览器发现 html 标签有 manifest 属性，它会请求 manifest 文件</li><li>如果是第一次访问app，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储</li><li>如果已经访问过app且资源已经离线存储了，浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作。如果文件改变了，那么就会重新下载文件中的资源并进行离线存储</li><li>离线的情况下，浏览器就直接使用离线存储的资源。</li></ul><p><strong>iframe 有那些优点和缺点？</strong></p><ul><li>优点：<ul><li>用来加载速度较慢的内容（如广告）</li><li>可以使脚本可以并行下载</li><li>可以实现跨子域通信</li></ul></li><li>缺点：<ul><li>iframe 会阻塞主页面的 onload 事件</li><li>无法被一些搜索引擎索识别</li><li>会产生很多页面，不容易管理</li></ul></li></ul><p><strong>label 的作用是什么？怎么使用的？</strong></p><ul><li>label标签来定义表单控件的关系：<ul><li>当用户选择label标签时，浏览器会自动将焦点转到和label标签相关的表单控件上</li></ul></li><li>使用方法1：<ul><li><code>&lt;label for=&quot;mobile&quot;&gt;Number:&lt;/label&gt;</code></li><li><code>&lt;input type=&quot;text&quot; id=&quot;mobile&quot;/&gt;</code></li></ul></li><li>使用方法2：<ul><li><code>&lt;label&gt;Date:&lt;input type=&quot;text&quot;/&gt;&lt;/label&gt;</code></li></ul></li></ul><p><strong>如何实现浏览器内多个标签页之间的通信？</strong></p><ul><li>iframe + contentWindow</li><li>postMessage</li><li>SharedWorker(Web Worker API)</li><li>storage 事件(localStorge API)</li><li>WebSocket</li></ul><p><strong>webSocket 如何兼容低浏览器？</strong></p><ul><li>Adobe Flash Socket</li><li>ActiveX HTMLFile (IE)</li><li>基于 multipart 编码发送 XHR</li><li>基于长轮询的 XHR</li></ul><p><strong>页面可见性（Page Visibility API） 可以有哪些用途？</strong></p><ul><li>在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放</li><li>当用户浏览其他页面，暂停网站首页幻灯自动播放</li><li>完成登陆后，无刷新自动同步其他页面的登录状态</li></ul><p><strong>title 与 h1 的区别、b 与 strong 的区别、i 与 em 的区别？</strong></p><ul><li>title 表示是整个页面标题，h1 则表示层次明确的标题，对页面信息的抓取有很大的影响</li><li>strong 标明重点内容，有语气加强的含义，使用阅读设备阅读网络时，strong 会重读，而 b </li></ul><p><strong>是展示强调内容</strong></p><ul><li>i 内容展示为斜体，em 表示强调的文本</li><li>自然样式标签：b, i, u, s, pre</li><li>语义样式标签：strong, em, ins, del, code</li><li>应该准确使用语义样式标签, 但不能滥用。如果不能确定时，首选使用自然样式标签</li></ul><p>html5有哪些新特性、移除了那些元素？</p><ul><li><code>HTML5</code> 现在已经不是 <code>SGML</code> 的子集，主要是关于图像，位置，存储，多任务等功能的增加<ul><li>绘画 <code>canvas</code></li><li>用于媒介回放的 <code>video</code> 和 <code>audio</code> 元素</li><li>本地离线存储 <code>localStorage</code> 长期存储数据，浏览器关闭后数据不丢失</li><li><code>sessionStorage</code> 的数据在浏览器关闭后自动删除</li><li>语意化更好的内容元素，比如<code>article</code>、<code>footer</code>、<code>header</code>、<code>nav</code>、<code>section</code></li><li>表单控件，<code>calendar</code>、<code>date</code>、<code>time</code>、<code>email</code>、<code>url</code>、<code>search</code></li><li>新的技术<code>webworker</code>、 <code>websocket</code>、 <code>Geolocation</code></li></ul></li><li>移除的元素：<ul><li>纯表现的元素：<code>basefont</code>、<code>big</code>、<code>center</code>、<code>font</code>、 <code>s</code>、<code>strike</code>、<code>tt</code>、<code>u</code></li><li>对可用性产生负面影响的元素：<code>frame</code>、<code>frameset</code>、<code>noframes</code></li></ul></li><li>支持<code>HTML5</code>新标签：<ul><li><code>IE8/IE7/IE6</code>支持通过<code>document.createElement</code>方法产生的标签</li><li>可以利用这一特性让这些浏览器支持<code>HTML5</code>新标签</li><li>浏览器支持新标签后，还需要添加标签默认的样式</li></ul></li><li>当然也可以直接使用成熟的框架、比如<code>html5shim</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 小知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript知识 - HTTP协议</title>
      <link href="/2018/01/23/JavaScript%E7%9F%A5%E8%AF%86%20-%20HTTP%E5%8D%8F%E8%AE%AE/"/>
      <url>/2018/01/23/JavaScript%E7%9F%A5%E8%AF%86%20-%20HTTP%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h5 id="JavaScript知识-HTTP协议"><a href="#JavaScript知识-HTTP协议" class="headerlink" title="JavaScript知识 - HTTP协议"></a>JavaScript知识 - HTTP协议</h5><p>JavaScript资料整理</p><a id="more"></a><p>一面中，如果有笔试，考HTTP协议的可能性较大。</p><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>一面要讲的内容：</p><ul><li><code>HTTP</code>协议的主要特点</li><li><code>HTTP</code>报文的组成部分</li><li><code>HTTP</code>方法</li><li><code>get</code> 和 <code>post</code>的区别</li><li><code>HTTP</code>状态码</li><li>什么是持久连接</li><li>什么是管线化</li></ul><p>二面要讲的内容；</p><ul><li>缓存</li><li><code>CSRF</code>攻击</li></ul><h2 id="2-HTTP协议的主要特点"><a href="#2-HTTP协议的主要特点" class="headerlink" title="2. HTTP协议的主要特点"></a>2. HTTP协议的主要特点</h2><ul><li>简单快速</li><li>灵活</li><li><strong>无连接</strong></li><li><strong>无状态</strong></li></ul><blockquote><p>通常我们要答出以上四个内容。如果实在记不住，一定要记得后面的两个：<strong>无连接、无状态</strong>。</p></blockquote><p>我们分别来解释一下。</p><h3 id="2-1-简单快速"><a href="#2-1-简单快速" class="headerlink" title="2.1 简单快速"></a>2.1 简单快速</h3><blockquote><p><strong>简单</strong>：每个资源（比如图片、页面）都通过 url 来定位。这都是固定的，在<code>http</code>协议中，处理起来也比较简单，想访问什么资源，直接输入url即可。</p></blockquote><h3 id="2-2-灵活"><a href="#2-2-灵活" class="headerlink" title="2.2 灵活"></a>2.2 灵活</h3><blockquote><p><code>http</code>协议的头部有一个<code>数据类型</code>，通过<code>http</code>协议，就可以完成不同数据类型的传输。</p></blockquote><h3 id="2-3-无连接"><a href="#2-3-无连接" class="headerlink" title="2.3 无连接"></a>2.3 无连接</h3><blockquote><p>连接一次，就会断开，不会继续保持连接。</p></blockquote><h3 id="2-4-无状态"><a href="#2-4-无状态" class="headerlink" title="2.4 无状态"></a>2.4 无状态</h3><blockquote><p>客户端和服务器端是两种身份。第一次请求结束后，就断开了，第二次请求时，<strong>服务器端并没有记住之前的状态</strong>，也就是说，服务器端无法区分客户端是否为同一个人、同一个身份。</p></blockquote><blockquote><p>有的时候，我们访问网站时，网站能记住我们的账号，这个是通过其他的手段（比如 <code>session</code>）做到的，并不是<code>http</code>协议能做到的。</p></blockquote><h2 id="3-HTTP报文的组成部分"><a href="#3-HTTP报文的组成部分" class="headerlink" title="3 HTTP报文的组成部分"></a>3 HTTP报文的组成部分</h2><p><img src="http://img.smyhvae.com/20180306_1400.png" alt=""></p><blockquote><p>在回答此问题时，我们要按照顺序回答：</p></blockquote><ul><li>先回答的是，<code>http</code>报文包括：<strong>请求报文</strong>和<strong>响应报文</strong>。</li><li>再回答的是，每个报文包含什么部分。</li><li>最后回答，每个部分的内容是什么</li></ul><h3 id="3-1-请求报文包括："><a href="#3-1-请求报文包括：" class="headerlink" title="3.1 请求报文包括："></a>3.1 请求报文包括：</h3><p><img src="http://img.smyhvae.com/20180228_1505.jpg" alt=""></p><ul><li>请求行：包括请求方法、请求的<code>url</code>、<code>http</code>协议及版本。</li><li>请求头：一大堆的键值对。</li><li><strong>空行</strong>指的是：当服务器在解析请求头的时候，如果遇到了空行，则表明，后面的内容是请求体</li><li>请求体：数据部分。</li></ul><h3 id="3-2-响应报文包括："><a href="#3-2-响应报文包括：" class="headerlink" title="3.2 响应报文包括："></a>3.2 响应报文包括：</h3><p><img src="http://img.smyhvae.com/20180228_1510.jpg" alt=""></p><ul><li>状态行：<code>http</code>协议及版本、状态码及状态描述。</li><li>响应头</li><li>空行</li><li>响应体</li></ul><h2 id="4-HTTP方法"><a href="#4-HTTP方法" class="headerlink" title="4 HTTP方法"></a>4 HTTP方法</h2><p>包括：</p><ul><li><code>GET</code>：获取资源</li><li><code>POST</code>：传输资源</li><li><code>put</code>：更新资源</li><li><code>DELETE</code>：删除资源</li><li><code>HEAD</code>：获得报文首部</li></ul><blockquote><p><code>HTTP</code>方法有很多，但是上面这五个方法，要求在面试时全部说出来，不要漏掉。</p></blockquote><ul><li><code>get</code> <code>和</code>post` 比较常见。</li><li><code>put</code> 和 <code>delete</code> 在实际应用中用的很少。况且，业务中，一般不删除服务器端的资源。</li><li><code>head</code> 可能偶尔用的到。</li></ul><h2 id="5-get-和-post的区别"><a href="#5-get-和-post的区别" class="headerlink" title="5 get 和 post的区别"></a>5 get 和 post的区别</h2><p><img src="http://img.smyhvae.com/20180306_1415.png" alt=""></p><ul><li>区别有很多，如果记不住，面试时，至少要任意答出其中的三四条。</li><li>有一点要强调，<strong>get是相对不隐私的，而post是相对隐私的</strong>。</li></ul><blockquote><p>我们大概要记住以下几点：</p></blockquote><ol><li>浏览器在回退时，<code>get</code> <strong>不会重新请求</strong>，但是<code>post</code>会重新请求。【重要】</li><li><code>get</code>请求会被浏览器<strong>主动缓存</strong>，而<code>post</code>不会。【重要】</li><li><code>get</code>请求的参数，会报<strong>保留</strong>在浏览器的<strong>历史记录</strong>里，而<code>post</code>不会。做业务时要注意。为了防止<code>CSRF</code>攻击，很多公司把<code>get</code>统一改成了<code>post</code>。</li><li><code>get</code>请求在<code>url</code>中<code>传递的参数有大小限制，基本是</code>2kb`，不同的浏览器略有不同。而post没有注意。</li><li><code>get</code>的参数是直接暴露在<code>url</code>上的，相对不安全。而<code>post</code>是放在请求体中的。</li></ol><h2 id="6-http状态码"><a href="#6-http状态码" class="headerlink" title="6 http状态码"></a>6 http状态码</h2><blockquote><p><code>http</code>状态码分类：</p></blockquote><p><img src="http://img.smyhvae.com/20180306_1430.png" alt=""></p><blockquote><p>常见的<code>http</code>状态码：</p></blockquote><p><img src="http://img.smyhvae.com/20180306_1431.png" alt=""></p><p><strong>部分解释</strong>：</p><ul><li><code>206</code>的应用：<code>range</code>指的是请求的范围，客户端只请求某个大文件里的一部分内容。比如说，如果播放视频地址或音频地址的前面一部分，可以用到<code>206</code>。</li><li><code>301</code>：重定向（永久）。</li><li><code>302</code>：重定向（临时）。</li><li><code>304</code>：我这个服务器告诉客户端，你已经有缓存了，不需要从我这里取了。</li></ul><p><img src="http://img.smyhvae.com/20180306_1440.png" alt=""></p><ul><li><code>400</code>和<code>401</code>用的不多,未授权。<code>403</code>指的是请求被拒绝。<code>404</code>指的是资源不存在。</li></ul><h2 id="7-持久链接-http长连接"><a href="#7-持久链接-http长连接" class="headerlink" title="7 持久链接/http长连接"></a>7 持久链接/http长连接</h2><blockquote><p>如果你能答出持久链接，这是面试官很想知道的一个点。</p></blockquote><ul><li><strong>轮询</strong>：<code>http1.0</code>中，客户端每隔很短的时间，都会对服务器发出请求，查看是否有新的消息，只要轮询速度足够快，例如<code>1</code>秒，就能给人造成交互是实时进行的印象。这种做法是无奈之举，实际上对服务器、客户端双方都造成了大量的性能浪费。</li><li><strong>长连接</strong>：<code>HTTP1.1</code>中，通过使用<code>Connection:keep-alive</code>进行长连接，。客户端只请求一次，但是服务器会将继续保持连接，当再次请求时，避免了重新建立连接。</li></ul><blockquote><p>注意，<code>HTTP 1.1</code>默认进行持久连接。在一次 <code>TCP</code> 连接中可以完成多个 <code>HTTP</code> 请求，但是对<strong>每个请求仍然要单独发 header</strong>，<code>Keep-Alive</code>不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如<code>Apache</code>）中设定这个时间。</p></blockquote><h2 id="8-长连接中的管线化"><a href="#8-长连接中的管线化" class="headerlink" title="8 长连接中的管线化"></a>8 长连接中的管线化</h2><blockquote><p>如果能答出<strong>管线化</strong>，则属于加分项。</p></blockquote><h3 id="8-1-管线化的原理"><a href="#8-1-管线化的原理" class="headerlink" title="8.1 管线化的原理"></a>8.1 管线化的原理</h3><blockquote><p>长连接时，<strong>默认</strong>的请求这样的：</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">请求1 --&gt; 响应1 --&gt;请求2 --&gt; 响应2 --&gt; 请求3 --&gt; 响应3</span><br></pre></td></tr></table></figure><blockquote><p>管线化就是，我把现在的请求打包，一次性发过去，你也给我一次响应回来。</p></blockquote><h3 id="8-2-管线化的注意事项"><a href="#8-2-管线化的注意事项" class="headerlink" title="8.2 管线化的注意事项"></a>8.2 管线化的注意事项</h3><blockquote><p>面试时，不会深究管线化。如果真要问你，就回答：“我没怎么研究过，准备回去看看~”</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 小知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript知识 - HTTP</title>
      <link href="/2018/01/22/JavaScript%E7%9F%A5%E8%AF%86%20-%20HTTP/"/>
      <url>/2018/01/22/JavaScript%E7%9F%A5%E8%AF%86%20-%20HTTP/</url>
      
        <content type="html"><![CDATA[<h5 id="JavaScript知识-HTTP"><a href="#JavaScript知识-HTTP" class="headerlink" title="JavaScript知识 - HTTP"></a>JavaScript知识 - HTTP</h5><p>JavaScript资料整理</p><a id="more"></a><h2 id="http状态码有那些？分别代表是什么意思？"><a href="#http状态码有那些？分别代表是什么意思？" class="headerlink" title="http状态码有那些？分别代表是什么意思？"></a>http状态码有那些？分别代表是什么意思？</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">简单版</span><br><span class="line">   [</span><br><span class="line">       100  Continue   继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息</span><br><span class="line">       200  OK         正常返回信息</span><br><span class="line">       201  Created    请求成功并且服务器创建了新的资源</span><br><span class="line">       202  Accepted   服务器已接受请求，但尚未处理</span><br><span class="line">       301  Moved Permanently  请求的网页已永久移动到新位置。</span><br><span class="line">       302 Found       临时性重定向。</span><br><span class="line">       303 See Other   临时性重定向，且总是使用 GET 请求新的 URI。</span><br><span class="line">       304  Not Modified 自从上次请求后，请求的网页未修改过。</span><br><span class="line"></span><br><span class="line">       400 Bad Request  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。</span><br><span class="line">       401 Unauthorized 请求未授权。</span><br><span class="line">       403 Forbidden   禁止访问。</span><br><span class="line">       404 Not Found   找不到如何与 URI 相匹配的资源。</span><br><span class="line"></span><br><span class="line">       500 Internal Server Error  最常见的服务器端错误。</span><br><span class="line">       503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。</span><br><span class="line">   ]</span><br></pre></td></tr></table></figure><p><strong>一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）</strong></p><ul><li>注：这题胜在区分度高，知识点覆盖广，再不懂的人，也能答出几句，</li><li>而高手可以根据自己擅长的领域自由发挥，从URL规范、HTTP协议、DNS、CDN、数据库查询、</li><li>到浏览器流式解析、CSS规则构建、layout、paint、onload/domready、JS执行、JS API绑定等等；</li><li>详细版：<ul><li>浏览器会开启一个线程来处理这个请求，对 URL 分析判断如果是 http 协议就按照 Web 方式来处理;</li><li>调用浏览器内核中的对应方法，比如 WebView 中的 loadUrl 方法;</li><li>通过DNS解析获取网址的IP地址，设置 UA 等信息发出第二个GET请求;</li><li>进行HTTP协议会话，客户端发送报头(请求报头);</li><li>进入到web服务器上的 Web Server，如 Apache、Tomcat、Node.JS 等服务器;</li><li>进入部署好的后端应用，如 PHP、Java、JavaScript、Python 等，找到对应的请求处理;</li><li>处理结束回馈报头，此处如果浏览器访问过，缓存上有对应资源，会与服务器最后修改时间对比，一致则返回304;</li><li>浏览器开始下载html文档(响应报头，状态码200)，同时使用缓存;</li><li>文档树建立，根据标记请求所需指定MIME类型的文件（比如css、js）,同时设置了cookie;</li><li>页面开始渲染DOM，JS根据DOM API操作DOM,执行事件绑定等，页面显示完成。</li></ul></li><li>简洁版：<ul><li>浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求；</li><li>服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）；</li><li>浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）；</li><li>载入解析到的资源文件，渲染页面，完成。</li></ul></li></ul><p><strong>说说TCP传输的三次握手四次挥手策略</strong></p><ul><li>为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送出去后，TCP不会对传送 后的情况置之不理，它一定会向对方确认是否成功送达。握手过程中使用了TCP的标志：SYN和ACK</li><li>发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。 最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。 若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包</li></ul><p><strong>断开一个TCP连接则需要“四次握手”：</strong></p><ul><li>第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据</li><li>第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）</li><li>第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了</li><li>第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手</li></ul><p><strong>TCP和UDP的区别</strong></p><ul><li>TCP（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“对话”才能建立起来</li><li>UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！ UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境</li></ul><p><strong>HTTP和HTTPS</strong></p><ul><li>HTTP协议通常承载于TCP协议之上，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的HTTPS</li><li>默认HTTP的端口号为80，HTTPS的端口号为443</li></ul><p><strong>为什么HTTPS安全</strong></p><ul><li>因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果使用HTTPS，密钥在你和终点站才有。https之所以比http安全，是因为他利用ssl/tls协议传输。它包含证书，卸载，流量转发，负载均衡，页面适配，浏览器适配，refer传递等。保障了传输过程的安全性</li></ul><p><strong>关于Http 2.0 你知道多少？</strong></p><ul><li>HTTP/2引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前就主动地将数据发送到客户端缓存中，从而提高性能。</li><li>HTTP/2提供更多的加密支持</li><li>HTTP/2使用多路技术，允许多个消息在一个连接上同时交差。</li><li>它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的header都只会占用很小比例的带宽</li></ul><p><strong>GET和POST的区别，何时使用POST？</strong></p><ul><li>GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符</li><li>POST：一般用于修改服务器上的资源，对所发送的信息没有限制。</li><li>GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值，也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。</li><li>然而，在以下情况中，请使用 POST 请求：<ul><li>无法使用缓存文件（更新服务器上的文件或数据库）</li><li>向服务器发送大量数据（POST 没有数据量限制）</li><li>发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</li></ul></li></ul><p><strong>说说网络分层里七层模型是哪七层</strong></p><ul><li>应用层：应用层、表示层、会话层（从上往下）（HTTP、FTP、SMTP、DNS）</li><li>传输层（TCP和UDP）</li><li>网络层（IP）</li><li>物理和数据链路层（以太网）</li><li>每一层的作用如下：<ul><li>物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）<br>数据链路层：将比特组装成帧和点到点的传递（帧Frame）</li><li>网络层：负责数据包从源到宿的传递和网际互连（包PackeT）</li><li>传输层：提供端到端的可靠报文传递和错误恢复（段Segment）</li><li>会话层：建立、管理和终止会话（会话协议数据单元SPDU）</li><li>表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）</li><li>应用层：允许访问OSI环境的手段（应用协议数据单元APDU）</li></ul></li></ul><p><strong>讲讲304缓存的原理</strong></p><ul><li>服务器首先产生ETag，服务器可在稍后使用它来判断页面是否已经被修改。本质上，客户端通过将该记号传回服务器要求服务器验证其（客户端）缓存</li><li>304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状态码后，会使用浏览器已缓存的文件</li><li>客户端请求一个页面（A）。 服务器返回页面A，并在给A加上一个ETag。 客户端展现该页面，并将页面连同ETag一起缓存。 客户再次请求页面A，并将上次请求时服务器返回的ETag一起传递给服务器。 服务器检查该ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体</li></ul><p><strong>HTTP/2 与 HTTP/1.x 的关键区别</strong></p><ul><li>二进制协议代替文本协议，更加简洁高效</li><li>针对每个域只使用一个多路复用的连接</li><li>压缩头部信息减小开销</li><li>允许服务器主动推送应答到客户端的缓存中</li></ul><p><strong>一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？</strong></p><ul><li>01.浏览器查找域名对应的IP地址(DNS 查询：浏览器缓存-&gt;系统缓存-&gt;路由器缓存-&gt;ISP DNS 缓存-&gt;根域名服务器)</li><li>02.浏览器向 Web 服务器发送一个 HTTP 请求（TCP三次握手）</li><li>03.服务器 301 重定向（从 <a href="http://example.com" target="_blank" rel="noopener">http://example.com</a> 重定向到 <a href="http://www.example.com）" target="_blank" rel="noopener">http://www.example.com）</a></li><li>04.浏览器跟踪重定向地址，请求另一个带 www 的网址</li><li>05.服务器处理请求（通过路由读取资源）</li><li>06.服务器返回一个 HTTP 响应（报头中把 Content-type 设置为 ‘text/html’）</li><li>07.浏览器进 DOM 树构建</li><li>08.浏览器发送请求获取嵌在 HTML 中的资源（如图片、音频、视频、CSS、JS等）</li><li>09.浏览器显示完成页面</li><li>10.浏览器发送异步请求</li></ul>]]></content>
      
      
      <categories>
          
          <category> 小知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript知识 - this</title>
      <link href="/2017/09/25/JavaScript%E7%9F%A5%E8%AF%86%20-%20this/"/>
      <url>/2017/09/25/JavaScript%E7%9F%A5%E8%AF%86%20-%20this/</url>
      
        <content type="html"><![CDATA[<h5 id="JavaScript知识-this"><a href="#JavaScript知识-this" class="headerlink" title="JavaScript知识- this"></a>JavaScript知识- this</h5><p>JavaScript资料整理</p><a id="more"></a><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">foo()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">a: <span class="number">2</span>,</span><br><span class="line">foo: foo</span><br><span class="line">&#125;</span><br><span class="line">obj.foo()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上两者情况 `this` 只依赖于调用函数前的对象，优先级是第二个情况大于第一个情况</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下情况是优先级最高的，`this` 只会绑定在 `c` 上，不会被任何方式修改 `this` 指向</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> foo()</span><br><span class="line">c.a = <span class="number">3</span></span><br><span class="line"><span class="built_in">console</span>.log(c.a)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 还有种就是利用 call，apply，bind 改变 this，这个优先级仅次于 new</span></span><br></pre></td></tr></table></figure><blockquote><p>看看箭头函数中的 <code>this</code></p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a()()())</span><br></pre></td></tr></table></figure><blockquote><p>箭头函数其实是没有 <code>this</code> 的，这个函数中的 <code>this</code> 只取决于他外面的第一个不是箭头函数的函数的 <code>this</code>。在这个例子中，因为调用 <code>a</code> 符合前面代码中的第一个情况，所以 <code>this</code> 是 <code>window</code>。并且 this 一旦绑定了上下文，就不会被任何代码改变</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 小知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>前端知识 - 框架小常识</title>
      <link href="/2017/09/08/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%20-%20%E6%A1%86%E6%9E%B6%E5%B0%8F%E5%B8%B8%E8%AF%86/"/>
      <url>/2017/09/08/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%20-%20%E6%A1%86%E6%9E%B6%E5%B0%8F%E5%B8%B8%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h5 id="前端知识-框架小常识"><a href="#前端知识-框架小常识" class="headerlink" title="前端知识 - 框架小常识"></a>前端知识 - 框架小常识</h5><p>资料整理</p><a id="more"></a><p><strong>什么是单页面应用(SPA)？</strong></p><ul><li>单页面应用(SPA)是指用户在浏览器加载单一的HTML页面，后续请求都无需再离开此页</li><li>目标：旨在用为用户提供了更接近本地移动APP或桌面应用程序的体验。</li><li>流程：第一次请求时，将导航页传输到客户端，其余请求通过 REST API 获取 JSON 数据</li><li>实现：数据的传输通过 Web Socket API 或 RPC(远程过程调用)。</li><li>优点：用户体验流畅，服务器压力小，前后端职责分离</li><li>缺点：关键词布局难度加大，不利于 SEO</li></ul><p><strong>什么是“前端路由”? 什么时候适用“前端路由”? 有哪些优点和缺点?</strong></p><ul><li>前端路由通过 URL 和 History 来实现页面切换</li><li>应用：前端路由主要适用于“前后端分离”的单页面应用(SPA)项目</li><li>优点：用户体验好，交互流畅</li><li>缺点：浏览器“前进”、“后退”会重新请求，无法合理利用缓存</li></ul><p><strong>模块化开发怎么做？</strong></p><ul><li>封装对象作为命名空间 – 内部状态可以被外部改写</li><li>立即执行函数(IIFE) – 需要依赖多个JS文件，并且严格按顺序加载</li><li>使用模块加载器 – require.js, sea.js, EC6 模块</li></ul><p><strong>通行的 Javascript 模块的规范有哪些？</strong></p><ul><li>CommonJS – 主要用在服务器端 node.js</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> math = <span class="built_in">require</span>(<span class="string">'./math'</span>);</span><br><span class="line">math.add(<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure><ul><li>AMD(异步模块定义) – require.js</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">'./math'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">math</span>) </span>&#123;</span><br><span class="line">    math.add(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>CMD(通用模块定义) – sea.js </li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> math = <span class="built_in">require</span>(<span class="string">'./math'</span>);</span><br><span class="line">math.add(<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure><ul><li>ES6 模块</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;math&#125; <span class="keyword">from</span> <span class="string">'./math'</span>;</span><br><span class="line">math.add(<span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p><strong>AMD 与 CMD 规范的区别？</strong></p><ul><li>规范化产出：<ul><li>AMD 由 RequireJS 推广产出</li><li>CMD 由 SeaJS 推广产出</li></ul></li><li>模块的依赖:<ul><li>AMD 提前执行，推崇依赖前置</li><li>CMD 延迟执行，推崇依赖就近</li></ul></li><li>API 功能:<ul><li>AMD 的 API 默认多功能（分全局 require 和局部 require）</li><li>CMD 的 API 推崇职责单一纯粹（没有全局 require）</li></ul></li><li>模块定义规则：<ul><li>AMD 默认一开始就载入全部依赖模块</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">define([<span class="string">'./a'</span>, <span class="string">'./b'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    a.doSomething();</span><br><span class="line">    b.doSomething();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>CMD 依赖模块在用到时才就近载入</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>);</span><br><span class="line">    a.doSomething();</span><br><span class="line">    <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">'./b'</span>);</span><br><span class="line">    b.doSomething();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>requireJS的核心原理是什么？</strong></p><ul><li>每个模块所依赖模块都会比本模块预先加载</li></ul><p><strong>对 Node.js 的优点、缺点提出了自己的看法？ Node.js的特点和适用场景？</strong></p><ul><li><p>Node.js的特点：单线程，非阻塞I/O，事件驱动</p></li><li><p>Node.js的优点：擅长处理高并发；适合I/O密集型应用</p></li><li><p>Node.js的缺点：不适合CPU密集运算；不能充分利用多核CPU；可靠性低，某个环节出错会导致整个系统崩溃</p></li><li><p>Node.js的适用场景：</p><ul><li>RESTful API</li><li>实时应用：在线聊天、图文直播</li><li>工具类应用：前端部署(npm, gulp)</li><li>表单收集：问卷系统</li></ul></li></ul><p><strong>如何判断当前脚本运行在浏览器还是node环境中？</strong></p><ul><li>判断 Global 对象是否为 window，如果不为 window，当前脚本没有运行在浏览器中</li></ul><p><strong>什么是 npm ？</strong></p><ul><li>npm 是 Node.js 的模块管理和发布工具</li></ul><p><strong>什么是 WebKit ？</strong></p><ul><li>WebKit 是一个开源的浏览器内核，由渲染引擎(WebCore)和JS解释引擎(JSCore)组成</li><li>通常所说的 WebKit 指的是 WebKit(WebCore)，主要工作是进行 HTML/CSS 渲染</li><li>WebKit 一直是 Safari 和 Chrome(之前) 使用的浏览器内核，后来 Chrome 改用Blink 内核</li></ul><p><strong>如何测试前端代码? 知道 Unit Test，BDD, TDD 么? 怎么测试你的前端工程(mocha, jasmin..)?</strong></p><ul><li>通过为前端代码编写单元测试(Unit Test)来测试前端代码</li><li>Unit Test：一段用于测试一个模块或接口是否能达到预期结果的代码</li><li>BDD：行为驱动开发 – 业务需求描述产出产品代码的开发方法</li><li>TDD：测试驱动开发 – 单元测试用例代码产出产品代码的开发方法</li><li>单元测试框架：</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mocha 示例</span></span><br><span class="line">describe(<span class="string">'Test add'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  it(<span class="string">'1 + 2 = 3'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      expect(add(<span class="number">1</span>, <span class="number">2</span>)).to.be.equal(<span class="number">3</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// jasmin 示例</span></span><br><span class="line">describe(<span class="string">'Test add'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    it(<span class="string">'1 + 2 = 3'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        expect(add(<span class="number">1</span>, <span class="number">2</span>)).toEqual(<span class="number">3</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>介绍你知道的前端模板引擎？</strong></p><ul><li>artTemplate, underscore, handlebars</li></ul><p><strong>什么是 Modernizr？ Modernizr 工作原理？</strong></p><ul><li>Modernizr 是一个开源的 JavaScript 库，用于检测用户浏览器对 HTML5 与 CSS3 的支持情况</li></ul><p><strong>移动端最小触控区域是多大？</strong></p><ul><li>44 * 44 px</li></ul><p><strong>移动端的点击事件的延迟时间是多长，为什么会有延迟？ 如何解决这个延时？</strong></p><ul><li>移动端 click 有 300ms 延迟，浏览器为了区分“双击”（放大页面）还是“单击”而设计</li><li>解决方案：<ul><li>禁用缩放(对safari无效)</li><li>使用指针事件(IE私有特性，且仅IE10+)</li><li>使用 Zepto 的 tap 事件(有点透BUG)</li><li>使用 FastClick 插件(体积大[压缩后8k])</li></ul></li></ul><p><strong>什么是函数式编程？</strong></p><ul><li>函数式编程是一种”编程范式”，主要思想是把运算过程尽量写成一系列嵌套的函数调用</li><li>例如：var result = subtract(multiply(add(1,2), 3), 4);</li><li>函数式编程的特点：<ul><li>函数核心化：函数可以作为变量的赋值、另一函数的参数、另一函数的返回值</li><li>只用“表达式”，不用“语句”：要求每一步都是单纯的运算，都必须有返回值</li><li>没有”副作用”：所有功能只为返回一个新的值，不修改外部变量</li><li>引用透明：运行不依赖于外部变量，只依赖于输入的参数</li></ul></li><li>函数式编程的优点：<ul><li>代码简洁，接近自然语言，易于理解</li><li>便于维护，利于测试、除错、组合</li><li>易于“并发编程“，不用担心一个线程的数据，被另一个线程修改</li><li>可“热升级”代码，在运行状态下直接升级代码，不需要重启，也不需要停机</li></ul></li></ul><p><strong>什么是函数柯里化Currying)？</strong></p><ul><li>柯里化：<ul><li>通常也称部分求值，含义是给函数分步传递参数，每次递参部分应用参数，并返回一个更具体的函数，继续接受剩余参数</li><li>期间会连续返回具体函数，直至返回最后结果。因此，函数柯里化是逐步传参，逐步缩小函数的适用范围，逐步求解的过程</li><li>柯里化的作用：延迟计算；参数复用；动态创建函数</li></ul></li><li>柯里化的缺点：<ul><li>函数柯里化会产生开销（函数嵌套，比普通函数占更多内存），但性能瓶颈首先来自其它原因（DOM 操作等）</li></ul></li></ul><p><strong>什么是依赖注入？</strong></p><ul><li>当一个类的实例依赖另一个类的实例时，自己不创建该实例，由IOC容器创建并注入给自己，因此称为依赖注入。</li><li>依赖注入解决的就是如何有效组织代码依赖模块的问题</li></ul><p><strong>设计模式：什么是 singleton, factory, strategy, decorator？</strong></p><ul><li>Singleton(单例)   一个类只有唯一实例，这个实例在整个程序中有一个全局的访问点</li><li>Factory (工厂)    解决实列化对象产生重复的问题</li><li>Strategy(策略)    将每一个算法封装起来，使它们还可以相互替换，让算法独立于使用</li><li>Observer(观察者)  多个观察者同时监听一个主体，当主体对象发生改变时，所有观察者都将得到通知</li><li>Prototype(原型)   一个完全初始化的实例，用于拷贝或者克隆</li><li>Adapter(适配器)   将不同类的接口进行匹配调整，尽管内部接口不兼容，不同的类还是可以协同工作</li><li>Proxy(代理模式)   一个充当过滤转发的对象用来代表一个真实的对象</li><li>Iterator(迭代器)  在不需要直到集合内部工作原理的情况下，顺序访问一个集合里面的元素</li><li>Chain of Responsibility(职责连)  处理请求组成的对象一条链，请求链中传递，直到有对象可以处理</li></ul><p><strong>什么是前端工程化？</strong></p><ul><li><p>前端工程化就是把一整套前端工作流程使用工具自动化完成</p></li><li><p>前端开发基本流程：</p><ul><li>项目初始化：yeoman, FIS</li><li>引入依赖包：bower, npm</li><li>模块化管理：npm, browserify, Webpack</li><li>代码编译：babel, sass, less</li><li>代码优化(压缩/合并)：Gulp, Grunt</li><li>代码检查：JSHint, ESLint</li><li>代码测试：Mocha</li></ul></li><li><p>目前最知名的构建工具：Gulp, Grunt, npm + Webpack</p></li></ul><p><strong>介绍 Yeoman 是什么？</strong></p><ul><li>Yeoman –前端开发脚手架工具，自动将最佳实践和工具整合起来构建项目骨架</li><li>Yeoman 其实是三类工具的合体，三类工具各自独立：<ul><li>yo — 脚手架，自动生成工具（相当于一个粘合剂，把 Yeoman 工具粘合在一起）</li><li>Grunt、gulp — 自动化构建工具 （最初只有grunt，之后加入了gulp）</li><li>Bower、npm — 包管理工具 （原来是bower，之后加入了npm）</li></ul></li></ul><p><strong>介绍 WebPack 是什么？ 有什么优势？</strong></p><ul><li>WebPack 是一款[模块加载器]兼[打包工具]，用于把各种静态资源（js/css/image等）作为模块来使用</li><li>WebPack 的优势：<ul><li>WebPack 同时支持 commonJS 和 AMD/CMD，方便代码迁移</li><li>不仅仅能被模块化 JS ，还包括 CSS、Image 等</li><li>能替代部分 grunt/gulp 的工作，如打包、压缩混淆、图片base64</li><li>扩展性强，插件机制完善，特别是支持 React 热插拔的功能</li></ul></li></ul><p><strong>介绍类库和框架的区别？</strong></p><ul><li>类库是一些函数的集合，帮助开发者写WEB应用，起主导作用的是开发者的代码</li><li>框架是已实现的特殊WEB应用，开发者只需对它填充具体的业务逻辑，起主导作用是框架</li></ul><p><strong>什么是 MVC/MVP/MVVM/Flux？</strong></p><ul><li>MVC(Model-View-Controller) <ul><li>V-&gt;C, C-&gt;M, M-&gt;V</li><li>通信都是单向的；C只起路由作用，业务逻辑都部署在V</li><li>Backbone</li></ul></li><li>MVP(Model-View-Presenter)<ul><li>V&lt;-&gt;P, P&lt;-&gt;M</li><li>通信都是双向的；V和M不发生联系(通过P传)；V非常薄，逻辑都部署在P</li><li>Riot.js</li></ul></li><li>MVVM(Model-View-ViewModel)<ul><li>V-&gt;VM, VM&lt;-&gt;M</li><li>采用双向数据绑定：View 和 ViewModel 的变动都会相互映射到对象上面</li><li>Angular</li></ul></li><li>Flux(Dispatcher-Store-View)<ul><li>Action-&gt;Dispatcher-&gt;Store-&gt;View, View-&gt;Action</li><li>Facebook 为了解决在 MVC 应用中碰到的工程性问题提出一个架构思想</li><li>基于一个简单的原则：数据在应用中单向流动（单向数据流）</li><li>React(Flux 中 View，只关注表现层)</li></ul></li></ul><p><strong>Backbone 是什么？</strong></p><ul><li>Backbone 是一个基于 jquery 和 underscore 的前端(MVC)框架</li></ul><p><strong>AngularJS 是什么？</strong></p><ul><li>AngularJS 是一个完善的前端 MVVM 框架，包含模板、数据双向绑定、路由、模块化、服务、依赖注入等</li><li>AngularJS 由 Google 维护，用来协助大型单一页面应用开发。</li></ul><p><strong>React 是什么？</strong></p><ul><li>React 不是 MV* 框架，用于构建用户界面的 JavaScript 库，侧重于 View 层</li><li>React 主要的原理：<ul><li>虚拟 DOM + diff 算法 -&gt; 不直接操作 DOM 对象</li><li>Components 组件 -&gt; Virtual DOM 的节点</li><li>State 触发视图的渲染 -&gt; 单向数据绑定</li><li>React 解决方案：React + Redux + react-router + Fetch + webpack</li></ul></li></ul><p><strong>react-router 路由系统的实现原理？</strong></p><ul><li><p>实现原理：location 与 components 之间的同步</p></li><li><p>路由的职责是保证 UI 和 URL 的同步</p></li><li><p>在 react-router 中，URL 对应 Location 对象，UI 由 react components 决定</p></li><li><p>因此，路由在 react-router 中就转变成 location 与 components 之间的同步</p></li></ul><p><strong>Meteor 是什么</strong></p><ul><li>Meteor 是一个全栈开发框架，基础构架是 Node.JS + MongoDB，并把延伸到了浏览器端。</li><li>Meteor 统一了服务器端和客户端的数据访问，使开发者可以轻松完成全栈式开发工作。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 小知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>前端知识 - DOM</title>
      <link href="/2017/08/18/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%20-%20DOM/"/>
      <url>/2017/08/18/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%20-%20DOM/</url>
      
        <content type="html"><![CDATA[<h5 id="前端知识-DOM"><a href="#前端知识-DOM" class="headerlink" title="前端知识 - DOM"></a>前端知识 - DOM</h5><p>资料整理</p><a id="more"></a><h2 id="DOM事件的总结"><a href="#DOM事件的总结" class="headerlink" title="DOM事件的总结"></a>DOM事件的总结</h2><p><strong>知识点主要包括以下几个方面：</strong></p><ul><li>基本概念：<code>DOM</code>事件的级别</li></ul><blockquote><p>面试不会直接问你，DOM有几个级别。但会在题目中体现：“请用<code>DOM2</code> ….”。</p></blockquote><ul><li><code>DOM</code>事件模型、<code>DOM</code>事件流</li></ul><blockquote><p>面试官如果问你“<strong>DOM事件模型</strong>”，你不一定知道怎么回事。其实说的就是<strong>捕获和冒泡</strong>。</p></blockquote><p><strong>DOM事件流</strong>，指的是事件传递的<strong>三个阶段</strong>。</p><ul><li>描述<code>DOM</code>事件捕获的具体流程</li></ul><blockquote><p>讲的是事件的传递顺序。参数为<code>false</code>（默认）、参数为<code>true</code>，各自代表事件在什么阶段触发。</p></blockquote><p>能回答出来的人，寥寥无几。也许有些人可以说出一大半，但是一字不落的人，极少。</p><ul><li><code>Event</code>对象的常见应用（<code>Event</code>的常用<code>api</code>方法）</li></ul><blockquote><p><code>DOM</code>事件的知识点，一方面包括事件的流程；另一方面就是：怎么去注册事件，也就是监听用户的交互行为。第三点：在响应时，<code>Event</code>对象是非常重要的。</p></blockquote><p><strong>自定义事件（非常重要）</strong></p><blockquote><p>一般人可以讲出事件和注册事件，但是如果让你讲<strong>自定义事件</strong>，能知道的人，就更少了。</p></blockquote><p><strong>DOM事件的级别</strong></p><blockquote><p><code>DOM</code>事件的级别，准确来说，是<strong>DOM标准</strong>定义的级别。包括：</p></blockquote><p><strong>DOM0的写法：</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">element.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面的代码是在 <code>js</code> 中的写法；如果要在<code>html</code>中写，写法是：在<code>onclick</code>属性中，加 <code>js</code> 语句。</p></blockquote><p><strong>DOM2的写法：</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">element.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><blockquote><p>【重要】上面的第三参数中，<strong>true</strong>表示事件在<strong>捕获阶段</strong>触发，<strong>false</strong>表示事件在<strong>冒泡阶段</strong>触发（默认）。如果不写，则默认为false。</p></blockquote><p><strong>DOM3的写法：</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">element.addEventListener(<span class="string">'keyup'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><blockquote><p><code>DOM3</code>中，增加了很多事件类型，比如鼠标事件、键盘事件等。</p></blockquote><blockquote><p>PS：为何事件没有<code>DOM1</code>的写法呢？因为，<code>DOM1</code>标准制定的时候，没有涉及与事件相关的内容。</p></blockquote><p><strong>总结</strong>：关于“DOM事件的级别”，能回答出以上内容即可，不会出题目让你做。</p><p><strong>DOM事件模型</strong></p><blockquote><p><code>DOM</code>事件模型讲的就是<strong>捕获和冒泡</strong>，一般人都能回答出来。</p></blockquote><ul><li>捕获：从上往下。</li><li>冒泡：从下（目标元素）往上。</li></ul><p><strong>DOM事件流</strong></p><blockquote><p><code>DOM</code>事件流讲的就是：浏览器在于当前页面做交互时，这个事件是怎么传递到页面上的。</p></blockquote><p><strong>完整的事件流，分三个阶段：</strong></p><ol><li>捕获：从 <code>window</code> 对象传到 目标元素。</li><li>目标阶段：事件通过捕获，到达目标元素，这个阶段就是目标阶段。</li><li>冒泡：从<strong>目标元素</strong>传到 <code>Window</code> 对象。</li></ol><p><img src="http://img.smyhvae.com/20180306_1058.png" alt=""></p><p><img src="http://img.smyhvae.com/20180204_1218.jpg" alt=""></p><p><strong>描述DOM事件捕获的具体流程</strong></p><blockquote><p>很少有人能说完整。</p></blockquote><p><strong>捕获的流程</strong></p><p><img src="http://img.smyhvae.com/20180306_1103.png" alt=""></p><p><strong>说明</strong>：捕获阶段，事件依次传递的顺序是：<code>window</code> –&gt; <code>document</code> –&gt; <code>html</code>–&gt; <code>body</code> –&gt; 父元素、子元素、目标元素。</p><ul><li>PS1：第一个接收到事件的对象是 <strong>window</strong>（有人会说<code>body</code>，有人会说<code>html</code>，这都是错误的）。</li><li>PS2：<code>JS</code>中涉及到<code>DOM</code>对象时，有两个对象最常用：<code>window</code>、<code>doucument</code>。它们俩也是最先获取到事件的。</li></ul><p>代码如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">"捕获 window"</span>);</span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">"捕获 document"</span>);</span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.documentElement.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">"捕获 html"</span>);</span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">"捕获 body"</span>);</span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">fatherBox.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">"捕获 father"</span>);</span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">childBox.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">"捕获 child"</span>);</span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p><strong>补充一个知识点：</strong></p><blockquote><p>在 <code>js</code>中：</p></blockquote><ul><li>如果想获取 <code>body</code> 节点，方法是：<code>document.body</code>；</li><li>但是，如果想获取 <code>html</code>节点，方法是<code>document.documentElement</code>。</li></ul><p><strong>冒泡的流程</strong></p><blockquote><p>与捕获的流程相反</p></blockquote><p><strong>Event对象的常见 api 方法</strong></p><blockquote><p>用户做的是什么操作（比如，是敲键盘了，还是点击鼠标了），这些事件基本都是通过<code>Event</code>对象拿到的。这些都比较简单，我们就不讲了。我们来看看下面这几个方法：</p></blockquote><p><strong>方法一</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">event.preventDefault();</span><br></pre></td></tr></table></figure><ul><li>解释：阻止默认事件。</li><li>比如，已知<code>&lt;a&gt;</code>标签绑定了click事件，此时，如果给<code>&lt;a&gt;</code>设置了这个方法，就阻止了链接的默认跳转。</li></ul><p><strong>方法二：阻止冒泡</strong></p><blockquote><p>这个在业务中很常见。</p></blockquote><blockquote><p>有的时候，业务中不需要事件进行冒泡。比如说，业务这样要求：单击子元素做事件<code>A</code>，单击父元素做事件B，如果不阻止冒泡的话，出现的问题是：单击子元素时，子元素和父元素都会做事件<code>A</code>。这个时候，就要用到阻止冒泡了。</p></blockquote><blockquote><p><code>w3c</code>的方法：（火狐、谷歌、<code>IE11</code>）</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">event.stopPropagation();</span><br></pre></td></tr></table></figure><blockquote><p><code>IE10</code>以下则是：</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">event.cancelBubble = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><blockquote><p>兼容代码如下：</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">box3.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">     alert(<span class="string">"child"</span>);</span><br><span class="line"></span><br><span class="line">     <span class="comment">//阻止冒泡</span></span><br><span class="line">     event = event || <span class="built_in">window</span>.event;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (event &amp;&amp; event.stopPropagation) &#123;</span><br><span class="line">         event.stopPropagation();</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         event.cancelBubble = <span class="literal">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>上方代码中，我们对<code>box3</code>进行了阻止冒泡，产生的效果是：事件不会继续传递到 <code>father</code>、<code>grandfather</code>、<code>body</code>了。</p></blockquote><p><strong>方法三：设置事件优先级</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">event.stopImmediatePropagation();</span><br></pre></td></tr></table></figure><p>这个方法比较长，一般人没听说过。解释如下：</p><blockquote><p>比如说，我用<code>addEventListener</code>给某按钮同时注册了事件<code>A</code>、事件<code>B</code>。此时，如果我单击按钮，就会依次执行事件A和事件<code>B</code>。现在要求：单击按钮时，只执行事件A，不执行事件<code>B</code>。该怎么做呢？这是时候，就可以用到<code>stopImmediatePropagation</code>方法了。做法是：在事件A的响应函数中加入这句话。</p></blockquote><blockquote><p>大家要记住 <code>event</code> 有这个方法。</p></blockquote><p><strong>属性4、属性5（事件委托中用到）</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">event.currentTarget   <span class="comment">//当前所绑定的事件对象。在事件委托中，指的是【父元素】。</span></span><br><span class="line"></span><br><span class="line">event.target  <span class="comment">//当前被点击的元素。在事件委托中，指的是【子元素】。</span></span><br></pre></td></tr></table></figure><p>上面这两个属性，在事件委托中经常用到。</p><blockquote><p><strong>总结</strong>：上面这几项，非常重要，但是容易弄混淆。</p></blockquote><p><strong>自定义事件</strong></p><blockquote><p>自定义事件的代码如下：</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">var</span> myEvent = <span class="keyword">new</span> Event(<span class="string">'clickTest'</span>);</span><br><span class="line">   element.addEventListener(<span class="string">'clickTest'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'smyhvae'</span>);</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//元素注册事件</span></span><br><span class="line">   element.dispatchEvent(myEvent); <span class="comment">//注意，参数是写事件对象 myEvent，不是写 事件名 clickTest</span></span><br></pre></td></tr></table></figure><blockquote><p>上面这个事件是定义完了之后，就直接自动触发了。在正常的业务中，这个事件一般是和别的事件结合用的。比如延时器设置按钮的动作：</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myEvent = <span class="keyword">new</span> Event(<span class="string">'clickTest'</span>);</span><br><span class="line"></span><br><span class="line">element.addEventListener(<span class="string">'clickTest'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'smyhvae'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    element.dispatchEvent(myEvent); <span class="comment">//注意，参数是写事件对象 myEvent，不是写 事件名 clickTest</span></span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 小知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript知识 - Generator</title>
      <link href="/2017/07/25/JavaScript%E7%9F%A5%E8%AF%86%20-%20Generator/"/>
      <url>/2017/07/25/JavaScript%E7%9F%A5%E8%AF%86%20-%20Generator/</url>
      
        <content type="html"><![CDATA[<h5 id="JavaScript知识-Generator"><a href="#JavaScript知识-Generator" class="headerlink" title="JavaScript知识 - Generator"></a>JavaScript知识 - Generator</h5><p>JavaScript资料整理</p><a id="more"></a><h3 id="Generator-实现"><a href="#Generator-实现" class="headerlink" title="Generator 实现"></a>Generator 实现</h3><blockquote><p><code>Generator</code> 是 <code>ES6</code>中新增的语法，和 <code>Promise</code> 一样，都可以用来异步编程</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 * 表示这是一个 Generator 函数</span></span><br><span class="line"><span class="comment">// 内部可以通过 yield 暂停代码</span></span><br><span class="line"><span class="comment">// 通过调用 next 恢复执行</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span> + <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = test();</span><br><span class="line"><span class="built_in">console</span>.log(b.next()); <span class="comment">// &gt;  &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(b.next()); <span class="comment">// &gt;  &#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(b.next()); <span class="comment">// &gt;  &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>从以上代码可以发现，加上 <code>*</code> 的函数执行后拥有了 <code>next</code>函数，也就是说函数执行后返回了一个对象。每次调用 <code>next</code>函数可以继续执行被暂停的代码。以下是 <code>Generator</code> 函数的简单实现</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cb 也就是编译过的 test 函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generator</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> object = &#123;</span><br><span class="line">      next: <span class="number">0</span>,</span><br><span class="line">      stop: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> ret = cb(object);</span><br><span class="line">        <span class="keyword">if</span> (ret === <span class="literal">undefined</span>) <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          value: ret,</span><br><span class="line">          done: <span class="literal">false</span></span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果你使用 babel 编译后可以发现 test 函数变成了这样</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a;</span><br><span class="line">  <span class="keyword">return</span> generator(<span class="function"><span class="keyword">function</span>(<span class="params">_context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">switch</span> ((_context.prev = _context.next)) &#123;</span><br><span class="line">        <span class="comment">// 可以发现通过 yield 将代码分割成几块</span></span><br><span class="line">        <span class="comment">// 每次执行 next 函数就执行一块代码</span></span><br><span class="line">        <span class="comment">// 并且表明下次需要执行哪块代码</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">          a = <span class="number">1</span> + <span class="number">2</span>;</span><br><span class="line">          _context.next = <span class="number">4</span>;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">          _context.next = <span class="number">6</span>;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 执行完毕</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"end"</span>:</span><br><span class="line">          <span class="keyword">return</span> _context.stop();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 小知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>前端知识 - 框架通识</title>
      <link href="/2017/07/22/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%20-%20%E6%A1%86%E6%9E%B6%E9%80%9A%E8%AF%86/"/>
      <url>/2017/07/22/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%20-%20%E6%A1%86%E6%9E%B6%E9%80%9A%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h5 id="前端知识-框架通识"><a href="#前端知识-框架通识" class="headerlink" title="前端知识 - 框架通识"></a>前端知识 - 框架通识</h5><p>资料整理</p><a id="more"></a><h2 id="框架通识"><a href="#框架通识" class="headerlink" title="框架通识"></a>框架通识</h2><h3 id="1-MVVM"><a href="#1-MVVM" class="headerlink" title="1 MVVM"></a>1 MVVM</h3><blockquote><p><code>MVVM</code> 由以下三个内容组成</p></blockquote><ul><li><code>View</code>：界面</li><li><code>Model</code>：数据模型</li><li><code>ViewModel</code>：作为桥梁负责沟通 <code>View</code> 和 <code>Model</code></li></ul><blockquote><p>在 <code>JQuery</code> 时期，如果需要刷新 <code>UI</code> 时，需要先取到对应的 <code>DOM</code> 再更新 <code>UI</code>，这样数据和业务的逻辑就和页面有强耦合。</p></blockquote><p>::: tip MVVM<br>在 <code>MVVM</code> 中，<code>UI</code> 是通过数据驱动的，数据一旦改变就会相应的刷新对应的 <code>UI</code>，<code>UI</code> 如果改变，也会改变对应的数据。这种方式就可以在业务处理中只关心数据的流转，而无需直接和页面打交道。<code>ViewModel</code> 只关心数据和业务的处理，不关心 <code>View</code> 如何处理数据，在这种情况下，<code>View</code> 和 <code>Model</code> 都可以独立出来，任何一方改变了也不一定需要改变另一方，并且可以将一些可复用的逻辑放在一个 <code>ViewModel</code> 中，让多个 <code>View</code>复用这个 <code>ViewModel</code>。<br>:::</p><ul><li>在 <code>MVVM</code> 中，最核心的也就是数据双向绑定，例如 <code>Angluar</code> 的脏数据检测，<code>Vue</code> 中的数据劫持。</li></ul><p><strong>脏数据检测</strong></p><blockquote><p>当触发了指定事件后会进入脏数据检测，这时会调用 <code>$digest</code> 循环遍历所有的数据观察者，判断当前值是否和先前的值有区别，如果检测到变化的话，会调用 <code>$watch</code> 函数，然后再次调用 <code>$digest</code> 循环直到发现没有变化。循环至少为二次 ，至多为十次。</p></blockquote><blockquote><p>脏数据检测虽然存在低效的问题，但是不关心数据是通过什么方式改变的，都可以完成任务，但是这在 <code>Vue</code> 中的双向绑定是存在问题的。并且脏数据检测可以实现批量检测出更新的值，再去统一更新 <code>UI</code>，大大减少了操作 <code>DOM</code> 的次数。所以低效也是相对的，这就仁者见仁智者见智了。</p></blockquote><p><strong>数据劫持</strong></p><blockquote><p><code>Vue</code> 内部使用了 <code>Object.defineProperty()</code> 来实现双向绑定，通过这个函数可以监听到 <code>set</code> 和 <code>get</code> 的事件。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123; <span class="attr">name</span>: <span class="string">'yck'</span> &#125;</span><br><span class="line">observe(data)</span><br><span class="line"><span class="keyword">let</span> name = data.name <span class="comment">// -&gt; get value</span></span><br><span class="line">data.name = <span class="string">'yyy'</span> <span class="comment">// -&gt; change value</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断类型</span></span><br><span class="line">  <span class="keyword">if</span> (!obj || <span class="keyword">typeof</span> obj !== <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Object</span>.keys(obj).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    defineReactive(obj, key, obj[key])</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj, key, val</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 递归子属性</span></span><br><span class="line">  observe(val)</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    <span class="keyword">get</span>: function reactiveGetter() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'get value'</span>)</span><br><span class="line">      <span class="keyword">return</span> val</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function reactiveSetter(newVal) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'change value'</span>)</span><br><span class="line">      val = newVal</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以上代码简单的实现了如何监听数据的 <code>set</code> 和 <code>get</code> 的事件，但是仅仅如此是不够的，还需要在适当的时候给属性添加发布订阅</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    &#123;&#123;name&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>在解析如上模板代码时，遇到 <code></code> 就会给属性 <code>name</code> 添加发布订阅。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过 Dep 解耦</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs = []</span><br><span class="line">  &#125;</span><br><span class="line">  addSub(sub) &#123;</span><br><span class="line">    <span class="comment">// sub 是 Watcher 实例</span></span><br><span class="line">    <span class="keyword">this</span>.subs.push(sub)</span><br><span class="line">  &#125;</span><br><span class="line">  notify() &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs.forEach(<span class="function"><span class="params">sub</span> =&gt;</span> &#123;</span><br><span class="line">      sub.update()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 全局属性，通过该属性配置 Watcher</span></span><br><span class="line">Dep.target = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.querySelector(<span class="string">'div'</span>).innerText = value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(obj, key, cb) &#123;</span><br><span class="line">    <span class="comment">// 将 Dep.target 指向自己</span></span><br><span class="line">    <span class="comment">// 然后触发属性的 getter 添加监听</span></span><br><span class="line">    <span class="comment">// 最后将 Dep.target 置空</span></span><br><span class="line">    Dep.target = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">this</span>.cb = cb</span><br><span class="line">    <span class="keyword">this</span>.obj = obj</span><br><span class="line">    <span class="keyword">this</span>.key = key</span><br><span class="line">    <span class="keyword">this</span>.value = obj[key]</span><br><span class="line">    Dep.target = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  update() &#123;</span><br><span class="line">    <span class="comment">// 获得新值</span></span><br><span class="line">    <span class="keyword">this</span>.value = <span class="keyword">this</span>.obj[<span class="keyword">this</span>.key]</span><br><span class="line">    <span class="comment">// 调用 update 方法更新 Dom</span></span><br><span class="line">    <span class="keyword">this</span>.cb(<span class="keyword">this</span>.value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> data = &#123; <span class="attr">name</span>: <span class="string">'yck'</span> &#125;</span><br><span class="line">observe(data)</span><br><span class="line"><span class="comment">// 模拟解析到 `&#123;&#123;name&#125;&#125;` 触发的操作</span></span><br><span class="line"><span class="keyword">new</span> Watcher(data, <span class="string">'name'</span>, update)</span><br><span class="line"><span class="comment">// update Dom innerText</span></span><br><span class="line">data.name = <span class="string">'yyy'</span></span><br></pre></td></tr></table></figure><blockquote><p>接下来,对 <code>defineReactive</code> 函数进行改造</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj, key, val</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 递归子属性</span></span><br><span class="line">  observe(val)</span><br><span class="line">  <span class="keyword">let</span> dp = <span class="keyword">new</span> Dep()</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    <span class="keyword">get</span>: function reactiveGetter() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'get value'</span>)</span><br><span class="line">      <span class="comment">// 将 Watcher 添加到订阅</span></span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        dp.addSub(Dep.target)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> val</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function reactiveSetter(newVal) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'change value'</span>)</span><br><span class="line">      val = newVal</span><br><span class="line">      <span class="comment">// 执行 watcher 的 update 方法</span></span><br><span class="line">      dp.notify()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以上实现了一个简易的双向绑定，核心思路就是手动触发一次属性的 <code>getter</code> 来实现发布订阅的添加</p></blockquote><p><strong>Proxy 与 Object.defineProperty 对比</strong></p><blockquote><p><code>Object.defineProperty</code> 虽然已经能够实现双向绑定了，但是他还是有缺陷的。</p></blockquote><ul><li>只能对属性进行数据劫持，所以需要深度遍历整个对象<br>对于数组不能监听到数据的变化</li><li>虽然 <code>Vue</code> 中确实能检测到数组数据的变化，但是其实是使用了 <code>hack</code>的办法，并且也是有缺陷的。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arrayProto = <span class="built_in">Array</span>.prototype</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> arrayMethods = <span class="built_in">Object</span>.create(arrayProto)</span><br><span class="line"><span class="comment">// hack 以下几个函数</span></span><br><span class="line"><span class="keyword">const</span> methodsToPatch = [</span><br><span class="line">  <span class="string">'push'</span>,</span><br><span class="line">  <span class="string">'pop'</span>,</span><br><span class="line">  <span class="string">'shift'</span>,</span><br><span class="line">  <span class="string">'unshift'</span>,</span><br><span class="line">  <span class="string">'splice'</span>,</span><br><span class="line">  <span class="string">'sort'</span>,</span><br><span class="line">  <span class="string">'reverse'</span></span><br><span class="line">]</span><br><span class="line">methodsToPatch.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">method</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获得原生函数</span></span><br><span class="line">  <span class="keyword">const</span> original = arrayProto[method]</span><br><span class="line">  def(arrayMethods, method, <span class="function"><span class="keyword">function</span> <span class="title">mutator</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 调用原生函数</span></span><br><span class="line">    <span class="keyword">const</span> result = original.apply(<span class="keyword">this</span>, args)</span><br><span class="line">    <span class="keyword">const</span> ob = <span class="keyword">this</span>.__ob__</span><br><span class="line">    <span class="keyword">let</span> inserted</span><br><span class="line">    <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'push'</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'unshift'</span>:</span><br><span class="line">        inserted = args</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'splice'</span>:</span><br><span class="line">        inserted = args.slice(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (inserted) ob.observeArray(inserted)</span><br><span class="line">    <span class="comment">// 触发更新</span></span><br><span class="line">    ob.dep.notify()</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>反观 <code>Proxy</code>就没以上的问题，原生支持监听数组变化，并且可以直接对整个对象进行拦截，所以 <code>Vue</code> 也将在下个大版本中使用 <code>Proxy</code> 替换 <code>Object.defineProperty</code></p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> onWatch = <span class="function">(<span class="params">obj, setBind, getLogger</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> handler = &#123;</span><br><span class="line">    <span class="keyword">get</span>(target, property, receiver) &#123;</span><br><span class="line">      getLogger(target, property)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, property, receiver);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>(target, property, value, receiver) &#123;</span><br><span class="line">      setBind(value);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, property, value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, handler);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">let</span> value</span><br><span class="line"><span class="keyword">let</span> p = onWatch(obj, (v) =&gt; &#123;</span><br><span class="line">  value = v</span><br><span class="line">&#125;, (target, property) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Get '<span class="subst">$&#123;property&#125;</span>' = <span class="subst">$&#123;target[property]&#125;</span>`</span>);</span><br><span class="line">&#125;)</span><br><span class="line">p.a = <span class="number">2</span> <span class="comment">// bind `value` to `2`</span></span><br><span class="line">p.a <span class="comment">// -&gt; Get 'a' = 2</span></span><br></pre></td></tr></table></figure><h3 id="2-路由原理"><a href="#2-路由原理" class="headerlink" title="2 路由原理"></a>2 路由原理</h3><blockquote><p>前端路由实现起来其实很简单，本质就是监听 <code>URL</code> 的变化，然后匹配路由规则，显示相应的页面，并且无须刷新。目前单页面使用的路由就只有两种实现方式</p></blockquote><ul><li><code>hash</code> 模式</li><li><code>history</code> 模式</li></ul><blockquote><p><code>www.test.com/##/</code> 就是 <code>Hash URL</code>，当 <code>##</code> 后面的哈希值发生变化时，不会向服务器请求数据，可以通过<br><code>hashchange</code> 事件来监听到 <code>URL</code> 的变化，从而进行跳转页面。</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/7/11/164888109d57995f?w=942&h=493&f=png&s=39581" alt=""></p><blockquote><p><code>History</code>模式是 <code>HTML5</code> 新推出的功能，比之 <code>Hash URL</code> 更加美观</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/7/11/164888478584a217?w=1244&h=585&f=png&s=59637" alt=""></p><h3 id="3-Virtual-Dom"><a href="#3-Virtual-Dom" class="headerlink" title="3 Virtual Dom"></a>3 Virtual Dom</h3><p><strong>为什么需要 Virtual Dom</strong></p><blockquote><p>众所周知，操作 <code>DOM</code> 是很耗费性能的一件事情，既然如此，我们可以考虑通过 <code>JS</code> 对象来模拟 <code>DOM</code> 对象，毕竟操作 <code>JS</code> 对象比操作 <code>DOM</code> 省时的多</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设这里模拟一个 ul，其中包含了 5 个 li</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="comment">// 这里替换上面的 li</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure><blockquote><p>从上述例子中，我们一眼就可以看出先前的 <code>ul</code> 中的第三个 <code>li</code> 被移除了，四五替换了位置。</p></blockquote><ul><li>如果以上操作对应到 <code>DOM</code> 中，那么就是以下代码</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除第三个 li</span></span><br><span class="line">ul.childNodes[<span class="number">2</span>].remove()</span><br><span class="line"><span class="comment">// 将第四个 li 和第五个交换位置</span></span><br><span class="line"><span class="keyword">let</span> fromNode = ul.childNodes[<span class="number">4</span>]</span><br><span class="line"><span class="keyword">let</span> toNode = node.childNodes[<span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> cloneFromNode = fromNode.cloneNode(<span class="literal">true</span>)</span><br><span class="line"><span class="keyword">let</span> cloenToNode = toNode.cloneNode(<span class="literal">true</span>)</span><br><span class="line">ul.replaceChild(cloneFromNode, toNode)</span><br><span class="line">ul.replaceChild(cloenToNode, fromNode)</span><br></pre></td></tr></table></figure><blockquote><p>当然在实际操作中，我们还需要给每个节点一个标识，作为判断是同一个节点的依据。所以这也是 <code>Vue</code> 和 <code>React</code> 中官方推荐列表里的节点使用唯一的 <code>key</code> 来保证性能。</p></blockquote><ul><li>那么既然 <code>DOM</code> 对象可以通过 <code>JS</code> 对象来模拟，反之也可以通过 <code>JS</code> 对象来渲染出对应的 <code>DOM</code></li><li>以下是一个 <code>JS</code> 对象模拟 <code>DOM</code> 对象的简单实现</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>tag 'div'</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> </span>props &#123; class: 'item' &#125;</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;Array&#125;</span> </span>children [ Element1, 'text']</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>key option</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">constructor</span>(tag, props, children, key) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tag = tag</span><br><span class="line">    <span class="keyword">this</span>.props = props</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(children)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.children = children</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isString(children)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.key = children</span><br><span class="line">      <span class="keyword">this</span>.children = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (key) <span class="keyword">this</span>.key = key</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 渲染</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">let</span> root = <span class="keyword">this</span>._createElement(</span><br><span class="line">      <span class="keyword">this</span>.tag,</span><br><span class="line">      <span class="keyword">this</span>.props,</span><br><span class="line">      <span class="keyword">this</span>.children,</span><br><span class="line">      <span class="keyword">this</span>.key</span><br><span class="line">    )</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(root)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">  &#125;</span><br><span class="line">  create() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._createElement(<span class="keyword">this</span>.tag, <span class="keyword">this</span>.props, <span class="keyword">this</span>.children, <span class="keyword">this</span>.key)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建节点</span></span><br><span class="line">  _createElement(tag, props, child, key) &#123;</span><br><span class="line">    <span class="comment">// 通过 tag 创建节点</span></span><br><span class="line">    <span class="keyword">let</span> el = <span class="built_in">document</span>.createElement(tag)</span><br><span class="line">    <span class="comment">// 设置节点属性</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> props) &#123;</span><br><span class="line">      <span class="keyword">if</span> (props.hasOwnProperty(key)) &#123;</span><br><span class="line">        <span class="keyword">const</span> value = props[key]</span><br><span class="line">        el.setAttribute(key, value)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (key) &#123;</span><br><span class="line">      el.setAttribute(<span class="string">'key'</span>, key)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归添加子节点</span></span><br><span class="line">    <span class="keyword">if</span> (child) &#123;</span><br><span class="line">      child.forEach(<span class="function"><span class="params">element</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> child</span><br><span class="line">        <span class="keyword">if</span> (element <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">          child = <span class="keyword">this</span>._createElement(</span><br><span class="line">            element.tag,</span><br><span class="line">            element.props,</span><br><span class="line">            element.children,</span><br><span class="line">            element.key</span><br><span class="line">          )</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          child = <span class="built_in">document</span>.createTextNode(element)</span><br><span class="line">        &#125;</span><br><span class="line">        el.appendChild(child)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> el</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Virtual Dom 算法简述</strong></p><ul><li>既然我们已经通过 <code>JS</code> 来模拟实现了 <code>DOM</code>，那么接下来的难点就在于如何判断旧的对象和新的对象之间的差异。</li><li><code>DOM</code> 是多叉树的结构，如果需要完整的对比两颗树的差异，那么需要的时间复杂度会是 <code>O(n ^ 3)</code>，这个复杂度肯定是不能接受的。于是 <code>React</code>团队优化了算法，实现了 <code>O(n)</code> 的复杂度来对比差异。</li><li>实现<code>O(n)</code> 复杂度的关键就是只对比同层的节点，而不是跨层对比，这也是考虑到在实际业务中很少会去跨层的移动 <code>DOM</code> 元素</li></ul><blockquote><p>所以判断差异的算法就分为了两步</p></blockquote><ul><li>首先从上至下，从左往右遍历对象，也就是树的深度遍历，这一步中会给每个节点添加索引，便于最后渲染差异</li><li>一旦节点有子元素，就去判断子元素是否有不同</li></ul><p><strong>Virtual Dom 算法实现</strong></p><p><strong>树的递归</strong></p><ul><li>首先我们来实现树的递归算法，在实现该算法前，先来考虑下两个节点对比会有几种情况</li><li>新的节点的 <code>tagName</code> 或者 <code>key</code> 和旧的不同，这种情况代表需要替换旧的节点，并且也不再需要遍历新旧节点的子元素了，因为整个旧节点都被删掉了</li><li>新的节点的 <code>tagName</code> 和 <code>key</code>（可能都没有）和旧的相同，开始遍历子树</li><li>没有新的节点，那么什么都不用做</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; StateEnums, isString, move &#125; <span class="keyword">from</span> <span class="string">'./util'</span></span><br><span class="line"><span class="keyword">import</span> Element <span class="keyword">from</span> <span class="string">'./element'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">diff</span>(<span class="params">oldDomTree, newDomTree</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 用于记录差异</span></span><br><span class="line">  <span class="keyword">let</span> pathchs = &#123;&#125;</span><br><span class="line">  <span class="comment">// 一开始的索引为 0</span></span><br><span class="line">  dfs(oldDomTree, newDomTree, <span class="number">0</span>, pathchs)</span><br><span class="line">  <span class="keyword">return</span> pathchs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">oldNode, newNode, index, patches</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 用于保存子树的更改</span></span><br><span class="line">  <span class="keyword">let</span> curPatches = []</span><br><span class="line">  <span class="comment">// 需要判断三种情况</span></span><br><span class="line">  <span class="comment">// 1.没有新的节点，那么什么都不用做</span></span><br><span class="line">  <span class="comment">// 2.新的节点的 tagName 和 `key` 和旧的不同，就替换</span></span><br><span class="line">  <span class="comment">// 3.新的节点的 tagName 和 key（可能都没有） 和旧的相同，开始遍历子树</span></span><br><span class="line">  <span class="keyword">if</span> (!newNode) &#123;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newNode.tag === oldNode.tag &amp;&amp; newNode.key === oldNode.key) &#123;</span><br><span class="line">    <span class="comment">// 判断属性是否变更</span></span><br><span class="line">    <span class="keyword">let</span> props = diffProps(oldNode.props, newNode.props)</span><br><span class="line">    <span class="keyword">if</span> (props.length) curPatches.push(&#123; <span class="attr">type</span>: StateEnums.ChangeProps, props &#125;)</span><br><span class="line">    <span class="comment">// 遍历子树</span></span><br><span class="line">    diffChildren(oldNode.children, newNode.children, index, patches)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 节点不同，需要替换</span></span><br><span class="line">    curPatches.push(&#123; <span class="attr">type</span>: StateEnums.Replace, <span class="attr">node</span>: newNode &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (curPatches.length) &#123;</span><br><span class="line">    <span class="keyword">if</span> (patches[index]) &#123;</span><br><span class="line">      patches[index] = patches[index].concat(curPatches)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      patches[index] = curPatches</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>判断属性的更改</strong></p><blockquote><p>判断属性的更改也分三个步骤</p></blockquote><ul><li>遍历旧的属性列表，查看每个属性是否还存在于新的属性列表中</li><li>遍历新的属性列表，判断两个列表中都存在的属性的值是否有变化</li><li>在第二步中同时查看是否有属性不存在与旧的属性列列表中</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffProps</span>(<span class="params">oldProps, newProps</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断 Props 分以下三步骤</span></span><br><span class="line">  <span class="comment">// 先遍历 oldProps 查看是否存在删除的属性</span></span><br><span class="line">  <span class="comment">// 然后遍历 newProps 查看是否有属性值被修改</span></span><br><span class="line">  <span class="comment">// 最后查看是否有属性新增</span></span><br><span class="line">  <span class="keyword">let</span> change = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> oldProps) &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldProps.hasOwnProperty(key) &amp;&amp; !newProps[key]) &#123;</span><br><span class="line">      change.push(&#123;</span><br><span class="line">        prop: key</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> newProps) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newProps.hasOwnProperty(key)) &#123;</span><br><span class="line">      <span class="keyword">const</span> prop = newProps[key]</span><br><span class="line">      <span class="keyword">if</span> (oldProps[key] &amp;&amp; oldProps[key] !== newProps[key]) &#123;</span><br><span class="line">        change.push(&#123;</span><br><span class="line">          prop: key,</span><br><span class="line">          value: newProps[key]</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!oldProps[key]) &#123;</span><br><span class="line">        change.push(&#123;</span><br><span class="line">          prop: key,</span><br><span class="line">          value: newProps[key]</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> change</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>判断列表差异算法实现</strong></p><blockquote><p>这个算法是整个 <code>Virtual Dom</code> 中最核心的算法，且让我一一为你道来。 这里的主要步骤其实和判断属性差异是类似的，也是分为三步</p></blockquote><ul><li>遍历旧的节点列表，查看每个节点是否还存在于新的节点列表中</li><li>遍历新的节点列表，判断是否有新的节点</li><li>在第二步中同时判断节点是否有移动</li></ul><blockquote><p>PS：该算法只对有 <code>key</code> 的节点做处理</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">listDiff</span>(<span class="params">oldList, newList, index, patches</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 为了遍历方便，先取出两个 list 的所有 keys</span></span><br><span class="line">  <span class="keyword">let</span> oldKeys = getKeys(oldList)</span><br><span class="line">  <span class="keyword">let</span> newKeys = getKeys(newList)</span><br><span class="line">  <span class="keyword">let</span> changes = []</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于保存变更后的节点数据</span></span><br><span class="line">  <span class="comment">// 使用该数组保存有以下好处</span></span><br><span class="line">  <span class="comment">// 1.可以正确获得被删除节点索引</span></span><br><span class="line">  <span class="comment">// 2.交换节点位置只需要操作一遍 DOM</span></span><br><span class="line">  <span class="comment">// 3.用于 `diffChildren` 函数中的判断，只需要遍历</span></span><br><span class="line">  <span class="comment">// 两个树中都存在的节点，而对于新增或者删除的节点来说，完全没必要</span></span><br><span class="line">  <span class="comment">// 再去判断一遍</span></span><br><span class="line">  <span class="keyword">let</span> list = []</span><br><span class="line">  oldList &amp;&amp;</span><br><span class="line">    oldList.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> key = item.key</span><br><span class="line">      <span class="keyword">if</span> (isString(item)) &#123;</span><br><span class="line">        key = item</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 寻找新的 children 中是否含有当前节点</span></span><br><span class="line">      <span class="comment">// 没有的话需要删除</span></span><br><span class="line">      <span class="keyword">let</span> index = newKeys.indexOf(key)</span><br><span class="line">      <span class="keyword">if</span> (index === <span class="number">-1</span>) &#123;</span><br><span class="line">        list.push(<span class="literal">null</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> list.push(key)</span><br><span class="line">    &#125;)</span><br><span class="line">  <span class="comment">// 遍历变更后的数组</span></span><br><span class="line">  <span class="keyword">let</span> length = list.length</span><br><span class="line">  <span class="comment">// 因为删除数组元素是会更改索引的</span></span><br><span class="line">  <span class="comment">// 所有从后往前删可以保证索引不变</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="comment">// 判断当前元素是否为空，为空表示需要删除</span></span><br><span class="line">    <span class="keyword">if</span> (!list[i]) &#123;</span><br><span class="line">      list.splice(i, <span class="number">1</span>)</span><br><span class="line">      changes.push(&#123;</span><br><span class="line">        type: StateEnums.Remove,</span><br><span class="line">        index: i</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 遍历新的 list，判断是否有节点新增或移动</span></span><br><span class="line">  <span class="comment">// 同时也对 `list` 做节点新增和移动节点的操作</span></span><br><span class="line">  newList &amp;&amp;</span><br><span class="line">    newList.forEach(<span class="function">(<span class="params">item, i</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> key = item.key</span><br><span class="line">      <span class="keyword">if</span> (isString(item)) &#123;</span><br><span class="line">        key = item</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 寻找旧的 children 中是否含有当前节点</span></span><br><span class="line">      <span class="keyword">let</span> index = list.indexOf(key)</span><br><span class="line">      <span class="comment">// 没找到代表新节点，需要插入</span></span><br><span class="line">      <span class="keyword">if</span> (index === <span class="number">-1</span> || key == <span class="literal">null</span>) &#123;</span><br><span class="line">        changes.push(&#123;</span><br><span class="line">          type: StateEnums.Insert,</span><br><span class="line">          node: item,</span><br><span class="line">          index: i</span><br><span class="line">        &#125;)</span><br><span class="line">        list.splice(i, <span class="number">0</span>, key)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 找到了，需要判断是否需要移动</span></span><br><span class="line">        <span class="keyword">if</span> (index !== i) &#123;</span><br><span class="line">          changes.push(&#123;</span><br><span class="line">            type: StateEnums.Move,</span><br><span class="line">            <span class="keyword">from</span>: index,</span><br><span class="line">            to: i</span><br><span class="line">          &#125;)</span><br><span class="line">          move(list, index, i)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  <span class="keyword">return</span> &#123; changes, list &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getKeys</span>(<span class="params">list</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> keys = []</span><br><span class="line">  <span class="keyword">let</span> text</span><br><span class="line">  list &amp;&amp;</span><br><span class="line">    list.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> key</span><br><span class="line">      <span class="keyword">if</span> (isString(item)) &#123;</span><br><span class="line">        key = [item]</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">        key = item.key</span><br><span class="line">      &#125;</span><br><span class="line">      keys.push(key)</span><br><span class="line">    &#125;)</span><br><span class="line">  <span class="keyword">return</span> keys</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>遍历子元素打标识</strong></p><blockquote><p>对于这个函数来说，主要功能就两个</p></blockquote><ul><li>判断两个列表差异<ul><li>给节点打上标记</li><li>总体来说，该函数实现的功能很简单</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffChildren</span>(<span class="params">oldChild, newChild, index, patches</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; changes, list &#125; = listDiff(oldChild, newChild, index, patches)</span><br><span class="line">  <span class="keyword">if</span> (changes.length) &#123;</span><br><span class="line">    <span class="keyword">if</span> (patches[index]) &#123;</span><br><span class="line">      patches[index] = patches[index].concat(changes)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      patches[index] = changes</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 记录上一个遍历过的节点</span></span><br><span class="line">  <span class="keyword">let</span> last = <span class="literal">null</span></span><br><span class="line">  oldChild &amp;&amp;</span><br><span class="line">    oldChild.forEach(<span class="function">(<span class="params">item, i</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> child = item &amp;&amp; item.children</span><br><span class="line">      <span class="keyword">if</span> (child) &#123;</span><br><span class="line">        index =</span><br><span class="line">          last &amp;&amp; last.children ? index + last.children.length + <span class="number">1</span> : index + <span class="number">1</span></span><br><span class="line">        <span class="keyword">let</span> keyIndex = list.indexOf(item.key)</span><br><span class="line">        <span class="keyword">let</span> node = newChild[keyIndex]</span><br><span class="line">        <span class="comment">// 只遍历新旧中都存在的节点，其他新增或者删除的没必要遍历</span></span><br><span class="line">        <span class="keyword">if</span> (node) &#123;</span><br><span class="line">          dfs(item, node, index, patches)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> index += <span class="number">1</span></span><br><span class="line">      last = item</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>渲染差异</strong></p><blockquote><p>通过之前的算法，我们已经可以得出两个树的差异了。既然知道了差异，就需要局部去更新 <code>DOM</code> 了，下面就让我们来看看 <code>Virtual Dom</code> 算法的最后一步骤</p></blockquote><p><strong>这个函数主要两个功能</strong></p><ul><li>深度遍历树，将需要做变更操作的取出来</li><li>局部更新 <code>DOM</code></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">patch</span>(<span class="params">node, patchs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> changes = patchs[index]</span><br><span class="line">  <span class="keyword">let</span> childNodes = node &amp;&amp; node.childNodes</span><br><span class="line">  <span class="comment">// 这里的深度遍历和 diff 中是一样的</span></span><br><span class="line">  <span class="keyword">if</span> (!childNodes) index += <span class="number">1</span></span><br><span class="line">  <span class="keyword">if</span> (changes &amp;&amp; changes.length &amp;&amp; patchs[index]) &#123;</span><br><span class="line">    changeDom(node, changes)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> last = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">if</span> (childNodes &amp;&amp; childNodes.length) &#123;</span><br><span class="line">    childNodes.forEach(<span class="function">(<span class="params">item, i</span>) =&gt;</span> &#123;</span><br><span class="line">      index =</span><br><span class="line">        last &amp;&amp; last.children ? index + last.children.length + <span class="number">1</span> : index + <span class="number">1</span></span><br><span class="line">      patch(item, patchs)</span><br><span class="line">      last = item</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeDom</span>(<span class="params">node, changes, noChild</span>) </span>&#123;</span><br><span class="line">  changes &amp;&amp;</span><br><span class="line">    changes.forEach(<span class="function"><span class="params">change</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> &#123; type &#125; = change</span><br><span class="line">      <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> StateEnums.ChangeProps:</span><br><span class="line">          <span class="keyword">let</span> &#123; props &#125; = change</span><br><span class="line">          props.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (item.value) &#123;</span><br><span class="line">              node.setAttribute(item.prop, item.value)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              node.removeAttribute(item.prop)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> StateEnums.Remove:</span><br><span class="line">          node.childNodes[change.index].remove()</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> StateEnums.Insert:</span><br><span class="line">          <span class="keyword">let</span> dom</span><br><span class="line">          <span class="keyword">if</span> (isString(change.node)) &#123;</span><br><span class="line">            dom = <span class="built_in">document</span>.createTextNode(change.node)</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (change.node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">            dom = change.node.create()</span><br><span class="line">          &#125;</span><br><span class="line">          node.insertBefore(dom, node.childNodes[change.index])</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> StateEnums.Replace:</span><br><span class="line">          node.parentNode.replaceChild(change.node.create(), node)</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> StateEnums.Move:</span><br><span class="line">          <span class="keyword">let</span> fromNode = node.childNodes[change.from]</span><br><span class="line">          <span class="keyword">let</span> toNode = node.childNodes[change.to]</span><br><span class="line">          <span class="keyword">let</span> cloneFromNode = fromNode.cloneNode(<span class="literal">true</span>)</span><br><span class="line">          <span class="keyword">let</span> cloenToNode = toNode.cloneNode(<span class="literal">true</span>)</span><br><span class="line">          node.replaceChild(cloneFromNode, toNode)</span><br><span class="line">          node.replaceChild(cloenToNode, fromNode)</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Virtual Dom 算法的实现也就是以下三步</strong></p><ul><li>通过 <code>JS</code> 来模拟创建 <code>DOM</code> 对象</li><li>判断两个对象的差异</li><li>渲染差异</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> test4 = <span class="keyword">new</span> Element(<span class="string">'div'</span>, &#123; <span class="attr">class</span>: <span class="string">'my-div'</span> &#125;, [<span class="string">'test4'</span>])</span><br><span class="line"><span class="keyword">let</span> test5 = <span class="keyword">new</span> Element(<span class="string">'ul'</span>, &#123; <span class="attr">class</span>: <span class="string">'my-div'</span> &#125;, [<span class="string">'test5'</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> test1 = <span class="keyword">new</span> Element(<span class="string">'div'</span>, &#123; <span class="attr">class</span>: <span class="string">'my-div'</span> &#125;, [test4])</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> test2 = <span class="keyword">new</span> Element(<span class="string">'div'</span>, &#123; <span class="attr">id</span>: <span class="string">'11'</span> &#125;, [test5, test4])</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> root = test1.render()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pathchs = diff(test1, test2)</span><br><span class="line"><span class="built_in">console</span>.log(pathchs)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'开始更新'</span>)</span><br><span class="line">  patch(root, pathchs)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'结束更新'</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><script>export default {  mounted () {    var script = document.createElement("script");    script.type = "text/javascript"    script.charset="UTF-8"    script.src = "http://tajs.qq.com/stats?sId=59154049"    document.body.appendChild(script); }}</script>]]></content>
      
      
      <categories>
          
          <category> 小知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript知识 - 深拷贝浅拷贝</title>
      <link href="/2017/07/20/JavaScript%E7%9F%A5%E8%AF%86%20-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
      <url>/2017/07/20/JavaScript%E7%9F%A5%E8%AF%86%20-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<h5 id="JavaScript知识-深拷贝浅拷贝"><a href="#JavaScript知识-深拷贝浅拷贝" class="headerlink" title="JavaScript知识 - 深拷贝浅拷贝"></a>JavaScript知识 - 深拷贝浅拷贝</h5><p>JavaScript资料整理</p><a id="more"></a><h3 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">letet a a = &#123;</span><br><span class="line">    age     : <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = a</span><br><span class="line">a.age = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(b.age) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><ul><li>从上述例子中我们可以发现，如果给一个变量赋值一个对象，那么两者的值会是同一个引用，其中一方改变，另一方也会相应改变。</li><li>通常在开发中我们不希望出现这样的问题，我们可以使用浅拷贝来解决这个问题</li></ul><p><strong>浅拷贝</strong></p><blockquote><p>首先可以通过 <code>Object.assign</code> 来解决这个问题</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    age: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Object</span>.assign(&#123;&#125;, a)</span><br><span class="line">a.age = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(b.age) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><blockquote><p>当然我们也可以通过展开运算符<code>（…）</code>来解决</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    age: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = &#123;...a&#125;</span><br><span class="line">a.age = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(b.age) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><blockquote><p>通常浅拷贝就能解决大部分问题了，但是当我们遇到如下情况就需要使用到深拷贝了</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    age: <span class="number">1</span>,</span><br><span class="line">    jobs: &#123;</span><br><span class="line">        first: <span class="string">'FE'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = &#123;...a&#125;</span><br><span class="line">a.jobs.first = <span class="string">'native'</span></span><br><span class="line"><span class="built_in">console</span>.log(b.jobs.first) <span class="comment">// native</span></span><br></pre></td></tr></table></figure><blockquote><p>浅拷贝只解决了第一层的问题，如果接下去的值中还有对象的话，那么就又回到刚开始的话题了，两者享有相同的引用。要解决这个问题，我们需要引入深拷</p></blockquote><p><strong>深拷贝</strong></p><blockquote><p>这个问题通常可以通过 <code>JSON.parse(JSON.stringify(object))</code> 来解决</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    age: <span class="number">1</span>,</span><br><span class="line">    jobs: &#123;</span><br><span class="line">        first: <span class="string">'FE'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(a))</span><br><span class="line">a.jobs.first = <span class="string">'native'</span></span><br><span class="line"><span class="built_in">console</span>.log(b.jobs.first) <span class="comment">// FE</span></span><br></pre></td></tr></table></figure><blockquote><p>但是该方法也是有局限性的：</p></blockquote><ul><li>会忽略 <code>undefined</code></li><li>不能序列化函数</li><li>不能解决循环引用的对象</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: &#123;</span><br><span class="line">    c: <span class="number">2</span>,</span><br><span class="line">    d: <span class="number">3</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">obj.c = obj.b</span><br><span class="line">obj.e = obj.a</span><br><span class="line">obj.b.c = obj.c</span><br><span class="line">obj.b.d = obj.b</span><br><span class="line">obj.b.e = obj.b.c</span><br><span class="line"><span class="keyword">let</span> newObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj))</span><br><span class="line"><span class="built_in">console</span>.log(newObj)</span><br></pre></td></tr></table></figure><blockquote><p>如果你有这么一个循环引用对象，你会发现你不能通过该方法深拷贝</p></blockquote><ul><li>在遇到函数或者 <code>undefined</code> 的时候，该对象也不能正常的序列化</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    age: <span class="literal">undefined</span>,</span><br><span class="line">    jobs: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">    name: <span class="string">'poetries'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(a))</span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// &#123;name: "poetries"&#125;</span></span><br></pre></td></tr></table></figure><ul><li>你会发现在上述情况中，该方法会忽略掉函数和`undefined。</li><li>但是在通常情况下，复杂数据都是可以序列化的，所以这个函数可以解决大部分问题，并且该函数是内置函数中处理深拷贝性能最快的。当然如果你的数据中含有以上三种情况下，可以使用 <code>lodash</code> 的深拷贝函数。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 小知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>前端知识 - ES6</title>
      <link href="/2017/07/19/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%20-%20ES6/"/>
      <url>/2017/07/19/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%20-%20ES6/</url>
      
        <content type="html"><![CDATA[<h5 id="前端知识-ES6"><a href="#前端知识-ES6" class="headerlink" title="前端知识 - ES6"></a>前端知识 - ES6</h5><p>资料整理</p><a id="more"></a><h2 id="1、ES5、ES6和ES2015有什么区别"><a href="#1、ES5、ES6和ES2015有什么区别" class="headerlink" title="1、ES5、ES6和ES2015有什么区别?"></a>1、ES5、ES6和ES2015有什么区别?</h2><blockquote><p><code>ES2015</code>特指在<code>2015</code>年发布的新一代<code>JS</code>语言标准，<code>ES6</code>泛指下一代JS语言标准，包含<code>ES2015</code>、<code>ES2016</code>、<code>ES2017</code>、<code>ES2018</code>等。现阶段在绝大部分场景下，<code>ES2015</code>默认等同<code>ES6</code>。<code>ES5</code>泛指上一代语言标准。<code>ES2015</code>可以理解为<code>ES5</code>和<code>ES6</code>的时间分界线</p></blockquote><h2 id="2、babel是什么，有什么作用"><a href="#2、babel是什么，有什么作用" class="headerlink" title="2、babel是什么，有什么作用?"></a>2、babel是什么，有什么作用?</h2><blockquote><p><code>babel</code>是一个 <code>ES6</code> 转码器，可以将 <code>ES6</code> 代码转为 <code>ES5</code> 代码，以便兼容那些还没支持<code>ES6</code>的平台</p></blockquote><h2 id="3、let有什么用，有了var为什么还要用let？"><a href="#3、let有什么用，有了var为什么还要用let？" class="headerlink" title="3、let有什么用，有了var为什么还要用let？"></a>3、let有什么用，有了var为什么还要用let？</h2><blockquote><p>在<code>ES6</code>之前，声明变量只能用<code>var</code>，<code>var</code>方式声明变量其实是很不合理的，准确的说，是因为<code>ES5</code>里面没有块级作用域是很不合理的。没有块级作用域回来带很多难以理解的问题，比如<code>for</code>循环<code>var</code>变量泄露，变量覆盖等问题。<code>let</code>声明的变量拥有自己的块级作用域，且修复了<code>var</code>声明变量带来的变量提升问题。</p></blockquote><h2 id="4、举一些ES6对String字符串类型做的常用升级优化"><a href="#4、举一些ES6对String字符串类型做的常用升级优化" class="headerlink" title="4、举一些ES6对String字符串类型做的常用升级优化?"></a>4、举一些ES6对String字符串类型做的常用升级优化?</h2><p><strong>优化部分</strong></p><blockquote><p><code>ES6</code>新增了字符串模板，在拼接大段字符串时，用反斜杠<code>(</code>)`取代以往的字符串相加的形式，能保留所有空格和换行，使得字符串拼接看起来更加直观，更加优雅</p></blockquote><p><strong>升级部分</strong></p><blockquote><p><code>ES6</code>在<code>String</code>原型上新增了<code>includes()</code>方法，用于取代传统的只能用<code>indexOf</code>查找包含字符的方法(<code>indexOf</code>返回<code>-1</code>表示没查到不如<code>includes</code>方法返回<code>false</code>更明确，语义更清晰), 此外还新增了<code>startsWith()</code>, <code>endsWith(),</code> <code>padStart()</code>,<code>padEnd()</code>,<code>repeat()</code>等方法，可方便的用于查找，补全字符串</p></blockquote><h2 id="5、举一些ES6对Array数组类型做的常用升级优化"><a href="#5、举一些ES6对Array数组类型做的常用升级优化" class="headerlink" title="5、举一些ES6对Array数组类型做的常用升级优化"></a>5、举一些ES6对Array数组类型做的常用升级优化</h2><p><strong>优化部分</strong></p><ul><li>数组解构赋值。<code>ES6</code>可以直接以<code>let [a,b,c] = [1,2,3]</code>形式进行变量赋值，在声明较多变量时，不用再写很多<code>let(var),</code>且映射关系清晰，且支持赋默认值</li><li>扩展运算符。<code>ES6</code>新增的扩展运算符(<code>...</code>)(重要),可以轻松的实现数组和松散序列的相互转化，可以取代<code>arguments</code>对象和<code>apply</code>方法，轻松获取未知参数个数情况下的参数集合。（尤其是在<code>ES5</code>中，<code>arguments</code>并不是一个真正的数组，而是一个类数组的对象，但是扩展运算符的逆运算却可以返回一个真正的数组）。扩展运算符还可以轻松方便的实现数组的复制和解构赋值（<code>let a = [2,3,4]</code>; <code>let b = [...a]</code>）</li></ul><p><strong>升级部分</strong></p><blockquote><p><code>ES6</code>在<code>Array</code>原型上新增了<code>find()</code>方法，用于取代传统的只能用<code>indexOf</code>查找包含数组项目的方法,且修复了<code>indexOf</code>查找不到<code>NaN的bug([NaN].indexOf(NaN) === -1)</code>.此外还新增了<code>copyWithin()</code>,<code>includes()</code>, <code>fill()</code>,<code>flat()</code>等方法，可方便的用于字符串的查找，补全,转换等</p></blockquote><h2 id="6、举一些ES6对Number数字类型做的常用升级优化"><a href="#6、举一些ES6对Number数字类型做的常用升级优化" class="headerlink" title="6、举一些ES6对Number数字类型做的常用升级优化"></a>6、举一些ES6对Number数字类型做的常用升级优化</h2><p><strong>优化部分</strong></p><blockquote><p>ES6在<code>Number</code>原型上新增了<code>isFinite()</code>, <code>isNaN()</code>方法，用来取代传统的全局<code>isFinite(),</code> <code>isNaN()</code>方法检测数值是否有限、是否是<code>NaN</code>。<code>ES5</code>的<code>isFinite()</code>, <code>isNaN()</code>方法都会先将非数值类型的参数转化为<code>Number</code>类型再做判断，这其实是不合理的，最造成i<code>sNaN(&#39;NaN&#39;) === true</code>的奇怪行为<code>--&#39;NaN&#39;</code>是一个字符串，但是<code>isNaN</code>却说这就是<code>NaN</code>。而<code>Number.isFinite()</code>和<code>Number.isNaN()</code>则不会有此类问题(<code>Number.isNaN(&#39;NaN&#39;) === false</code>)。（<code>isFinite()</code>同上）</p></blockquote><p><strong>升级部分</strong></p><blockquote><p><code>ES6</code>在<code>Math</code>对象上新增了<code>Math.cbrt()</code>，<code>trunc()</code>，<code>hypot()</code>等等较多的科学计数法运算方法，可以更加全面的进行立方根、求和立方根等等科学计算</p></blockquote><h2 id="7、举一些ES6对Object类型做的常用升级优化-重要"><a href="#7、举一些ES6对Object类型做的常用升级优化-重要" class="headerlink" title="7、举一些ES6对Object类型做的常用升级优化?(重要)"></a>7、举一些ES6对Object类型做的常用升级优化?(重要)</h2><p><strong>优化部分</strong></p><blockquote><p>对象属性变量式声明。<code>ES6</code>可以直接以变量形式声明对象属性或者方法，。比传统的键值对形式声明更加简洁，更加方便，语义更加清晰</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [apple, orange] = [<span class="string">'red appe'</span>, <span class="string">'yellow orange'</span>];</span><br><span class="line"><span class="keyword">let</span> myFruits = &#123;apple, orange&#125;;    <span class="comment">// let myFruits = &#123;apple: 'red appe', orange: 'yellow orange'&#125;;</span></span><br></pre></td></tr></table></figure><blockquote><p>尤其在对象解构赋值(见优化部分b.)或者模块输出变量时，这种写法的好处体现的最为明显</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;keys, values, entries&#125; = <span class="built_in">Object</span>;</span><br><span class="line"><span class="keyword">let</span> MyOwnMethods = &#123;keys, values, entries&#125;; <span class="comment">// let MyOwnMethods = &#123;keys: keys, values: values, entries: entries&#125;</span></span><br></pre></td></tr></table></figure><p>可以看到属性变量式声明属性看起来更加简洁明了。方法也可以采用简洁写法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> es5Fun = &#123;</span><br><span class="line">    method: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> es6Fun = &#123;</span><br><span class="line">    method()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对象的解构赋值。 <code>ES6</code>对象也可以像数组解构赋值那样，进行变量的解构赋值</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;apple, orange&#125; = &#123;<span class="attr">apple</span>: <span class="string">'red appe'</span>, <span class="attr">orange</span>: <span class="string">'yellow orange'</span>&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>对象的扩展运算符(<code>...</code>)。 ES6对象的扩展运算符和数组扩展运算符用法本质上差别不大，毕竟数组也就是特殊的对象。对象的扩展运算符一个最常用也最好用的用处就在于可以轻松的取出一个目标对象内部全部或者部分的可遍历属性，从而进行对象的合并和分解</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;apple, orange, ...otherFruits&#125; = &#123;<span class="attr">apple</span>: <span class="string">'red apple'</span>, <span class="attr">orange</span>: <span class="string">'yellow orange'</span>, <span class="attr">grape</span>: <span class="string">'purple grape'</span>, <span class="attr">peach</span>: <span class="string">'sweet peach'</span>&#125;; </span><br><span class="line"><span class="comment">// otherFruits  &#123;grape: 'purple grape', peach: 'sweet peach'&#125;</span></span><br><span class="line"><span class="comment">// 注意: 对象的扩展运算符用在解构赋值时，扩展运算符只能用在最有一个参数(otherFruits后面不能再跟其他参数)</span></span><br><span class="line"><span class="keyword">let</span> moreFruits = &#123;<span class="attr">watermelon</span>: <span class="string">'nice watermelon'</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> allFruits = &#123;apple, orange, ...otherFruits, ...moreFruits&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><code>super</code> 关键字。<code>ES6</code>在<code>Class</code>类里新增了类似<code>this</code>的关键字<code>super</code>。同<code>this</code>总是指向当前函数所在的对象不同，<code>super</code>关键字总是指向当前函数所在对象的原型对象</p></blockquote><p><strong>升级部分</strong></p><blockquote><p><code>ES6</code>在<code>Object</code>原型上新增了<code>is()</code>方法，做两个目标对象的相等比较，用来完善<code>&#39;===&#39;</code>方法。<code>&#39;===&#39;</code>方法中<code>NaN === NaN //false</code>其实是不合理的，<code>Object.is</code>修复了这个小<code>bug</code>。<code>(Object.is(NaN, NaN) // true)</code></p></blockquote><blockquote><p><code>ES6</code>在<code>Object</code>原型上新增了<code>assign()</code>方法，用于对象新增属性或者多个对象合并</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> source1 = &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> source2 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(target, source1, source2);</span><br><span class="line">target <span class="comment">// &#123;a:1, b:2, c:3&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>: <code>assign</code>合并的对象<code>target</code>只能合并<code>source1</code>、s<code>ource2</code>中的自身属性，并不会合并<code>source1</code>、<code>source2</code>中的继承属性，也不会合并不可枚举的属性，且无法正确复制get和set属性（会直接执行<code>get/set</code>函数，取<code>return</code>的值）</p></blockquote><ul><li><code>ES6</code>在<code>Object</code>原型上新增了<code>getOwnPropertyDescriptors()</code>方法，此方法增强了<code>ES5</code>中<code>getOwnPropertyDescriptor()</code>方法，可以获取指定对象所有自身属性的描述对象。结合<code>defineProperties()</code>方法，可以完美复制对象，包括复制<code>get</code>和<code>set</code>属性</li><li><code>ES6</code>在<code>Object</code>原型上新增了<code>getPrototypeOf()</code>和<code>setPrototypeOf()</code>方法，用来获取或设置当前对象的<code>prototype</code>对象。这个方法存在的意义在于，<code>ES5</code>中获取设置<code>prototype</code>对像是通过<code>__proto__</code>属性来实现的，然而<code>__proto__</code>属性并不是ES规范中的明文规定的属性，只是浏览器各大产商“私自”加上去的属性，只不过因为适用范围广而被默认使用了，再非浏览器环境中并不一定就可以使用，所以为了稳妥起见，获取或设置当前对象的<code>prototype</code>对象时，都应该采用ES6新增的标准用法</li><li><code>ES6</code>在<code>Object</code>原型上还新增了<code>Object.keys()</code>，<code>Object.values()</code>，<code>Object.entries()</code>方法，用来获取对象的所有键、所有值和所有键值对数组</li></ul><h2 id="8、举一些ES6对Function函数类型做的常用升级优化"><a href="#8、举一些ES6对Function函数类型做的常用升级优化" class="headerlink" title="8、举一些ES6对Function函数类型做的常用升级优化?"></a>8、举一些ES6对Function函数类型做的常用升级优化?</h2><p><strong>优化部分</strong></p><blockquote><p>箭头函数(核心)。箭头函数是ES6核心的升级项之一，箭头函数里没有自己的this,这改变了以往JS函数中最让人难以理解的this运行机制。主要优化点</p></blockquote><ul><li>箭头函数内的this指向的是函数定义时所在的对象，而不是函数执行时所在的对象。ES5函数里的this总是指向函数执行时所在的对象，这使得在很多情况下<code>this</code>的指向变得很难理解，尤其是非严格模式情况下，<code>this</code>有时候会指向全局对象，这甚至也可以归结为语言层面的bug之一。ES6的箭头函数优化了这一点，它的内部没有自己的<code>this</code>,这也就导致了<code>this</code>总是指向上一层的<code>this</code>，如果上一层还是箭头函数，则继续向上指，直到指向到有自己<code>this</code>的函数为止，并作为自己的<code>this</code></li><li>箭头函数不能用作构造函数，因为它没有自己的<code>this</code>，无法实例化</li><li>也是因为箭头函数没有自己的this,所以箭头函数 内也不存在<code>arguments</code>对象。（可以用扩展运算符代替）</li><li>函数默认赋值。<code>ES6</code>之前，函数的形参是无法给默认值得，只能在函数内部通过变通方法实现。<code>ES6</code>以更简洁更明确的方式进行函数默认赋值</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">es6Fuc</span> (<span class="params">x, y = <span class="string">'default'</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line">es6Fuc(<span class="number">4</span>) <span class="comment">// 4, default</span></span><br></pre></td></tr></table></figure><p><strong>升级部分</strong></p><blockquote><p>ES6新增了双冒号运算符，用来取代以往的<code>bind</code>，<code>call</code>,和<code>apply</code>。(浏览器暂不支持，<code>Babel</code>已经支持转码)</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">foo::bar;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">bar.bind(foo);</span><br><span class="line"></span><br><span class="line">foo::bar(...arguments);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">bar.apply(foo, <span class="built_in">arguments</span>);</span><br></pre></td></tr></table></figure><h2 id="9、Symbol是什么，有什么作用？"><a href="#9、Symbol是什么，有什么作用？" class="headerlink" title="9、Symbol是什么，有什么作用？"></a>9、Symbol是什么，有什么作用？</h2><blockquote><p><code>Symbol</code>是<code>ES6</code>引入的第七种原始数据类型（说法不准确，应该是第七种数据类型，Object不是原始数据类型之一，已更正），所有Symbol()生成的值都是独一无二的，可以从根本上解决对象属性太多导致属性名冲突覆盖的问题。对象中<code>Symbol()</code>属性不能被<code>for...in</code>遍历，但是也不是私有属性</p></blockquote><h2 id="10、Set是什么，有什么作用？"><a href="#10、Set是什么，有什么作用？" class="headerlink" title="10、Set是什么，有什么作用？"></a>10、Set是什么，有什么作用？</h2><blockquote><p><code>Set</code>是<code>ES6</code>引入的一种类似<code>Array</code>的新的数据结构，<code>Set</code>实例的成员类似于数组<code>item</code>成员，区别是<code>Set</code>实例的成员都是唯一，不重复的。这个特性可以轻松地实现数组去重</p></blockquote><h2 id="11、Map是什么，有什么作用？"><a href="#11、Map是什么，有什么作用？" class="headerlink" title="11、Map是什么，有什么作用？"></a>11、Map是什么，有什么作用？</h2><blockquote><p><code>Map</code>是<code>ES6</code>引入的一种类似<code>Object</code>的新的数据结构，<code>Map</code>可以理解为是<code>Object</code>的超集，打破了以传统键值对形式定义对象，对象的<code>key</code>不再局限于字符串，也可以是<code>Object</code>。可以更加全面的描述对象的属性</p></blockquote><h2 id="12、Proxy是什么，有什么作用？"><a href="#12、Proxy是什么，有什么作用？" class="headerlink" title="12、Proxy是什么，有什么作用？"></a>12、Proxy是什么，有什么作用？</h2><blockquote><p><code>Proxy</code>是<code>ES6</code>新增的一个构造函数，可以理解为JS语言的一个代理，用来改变JS默认的一些语言行为，包括拦截默认的<code>get/set</code>等底层方法，使得JS的使用自由度更高，可以最大限度的满足开发者的需求。比如通过拦截对象的<code>get/set</code>方法，可以轻松地定制自己想要的<code>key</code>或者<code>value</code>。下面的例子可以看到，随便定义一个<code>myOwnObj</code>的<code>key</code>,都可以变成自己想要的函数`</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createMyOwnObj</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">//想把所有的key都变成函数，或者Promise,或者anything</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line"><span class="keyword">get</span>(target, propKey, receiver) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">let</span> randomBoolean = <span class="built_in">Math</span>.random() &gt; <span class="number">0.5</span>;</span><br><span class="line"><span class="keyword">let</span> Message;</span><br><span class="line"><span class="keyword">if</span> (randomBoolean) &#123;</span><br><span class="line">Message = <span class="string">`你的<span class="subst">$&#123;propKey&#125;</span>运气不错，成功了`</span>;</span><br><span class="line">resolve(Message);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">Message = <span class="string">`你的<span class="subst">$&#123;propKey&#125;</span>运气不行，失败了`</span>;</span><br><span class="line">reject(Message);</span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myOwnObj = createMyOwnObj();</span><br><span class="line"></span><br><span class="line">myOwnObj.hahaha.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(result) <span class="comment">//你的hahaha运气不错，成功了</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(error) <span class="comment">//你的hahaha运气不行，失败了</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">myOwnObj.wuwuwu.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(result) <span class="comment">//你的wuwuwu运气不错，成功了</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(error) <span class="comment">//你的wuwuwu运气不行，失败了</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="13、Reflect是什么，有什么作用？"><a href="#13、Reflect是什么，有什么作用？" class="headerlink" title="13、Reflect是什么，有什么作用？"></a>13、Reflect是什么，有什么作用？</h2><blockquote><p><code>Reflect</code>是<code>ES6</code>引入的一个新的对象，他的主要作用有两点，一是将原生的一些零散分布在<code>Object</code>、<code>Function</code>或者全局函数里的方法(如<code>apply</code>、<code>delete</code>、<code>get</code>、<code>set</code>等等)，统一整合到<code>Reflect</code>上，这样可以更加方便更加统一的管理一些原生<code>API</code>。其次就是因为<code>Proxy</code>可以改写默认的原生API，如果一旦原生<code>API</code>别改写可能就找不到了，所以<code>Reflect</code>也可以起到备份原生API的作用，使得即使原生<code>API</code>被改写了之后，也可以在被改写之后的<code>API</code>用上默认的<code>API</code></p></blockquote><h2 id="14、Promise是什么，有什么作用？"><a href="#14、Promise是什么，有什么作用？" class="headerlink" title="14、Promise是什么，有什么作用？"></a>14、Promise是什么，有什么作用？</h2><blockquote><p><code>Promise</code>是<code>ES6</code>引入的一个新的对象，他的主要作用是用来解决JS异步机制里，回调机制产生的“回调地狱”。它并不是什么突破性的<code>API</code>，只是封装了异步回调形式，使得异步回调可以写的更加优雅，可读性更高，而且可以链式调用</p></blockquote><h2 id="15、Iterator是什么，有什么作用？-重要"><a href="#15、Iterator是什么，有什么作用？-重要" class="headerlink" title="15、Iterator是什么，有什么作用？(重要)"></a>15、Iterator是什么，有什么作用？(重要)</h2><ul><li><code>Iterator</code>是<code>ES6</code>中一个很重要概念，它并不是对象，也不是任何一种数据类型。因为<code>ES6</code>新增了<code>Set</code>、<code>Map</code>类型，他们和<code>Array</code>、<code>Object</code>类型很像，<code>Array</code>、<code>Object</code>都是可以遍历的，但是<code>Set</code>、<code>Map</code>都不能用for循环遍历，解决这个问题有两种方案，一种是为<code>Set</code>、<code>Map</code>单独新增一个用来遍历的<code>API</code>，另一种是为<code>Set</code>、<code>Map</code>、<code>Array</code>、<code>Object</code>新增一个统一的遍历<code>API</code>，显然，第二种更好，<code>ES6</code>也就顺其自然的需要一种设计标准，来统一所有可遍历类型的遍历方式。<code>Iterator</code>正是这样一种标准。或者说是一种规范理念</li><li>就好像<code>JavaScript</code>是<code>ECMAScript</code>标准的一种具体实现一样，<code>Iterator</code>标准的具体实现是<code>Iterator</code>遍历器。<code>Iterator</code>标准规定，所有部署了<code>key</code>值为<code>[Symbol.iterator]</code>，且<code>[Symbol.iterator]</code>的<code>value</code>是标准的<code>Iterator</code>接口函数(标准的<code>Iterator</code>接口函数: 该函数必须返回一个对象，且对象中包含<code>next</code>方法，且执行<code>next()</code>能返回包含<code>value/done</code>属性的<code>Iterator</code>对象)的对象，都称之为可遍历对象，<code>next()</code>后返回的<code>Iterator</code>对象也就是<code>Iterator</code>遍历器</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//obj就是可遍历的，因为它遵循了Iterator标准，且包含[Symbol.iterator]方法，方法函数也符合标准的Iterator接口规范。</span></span><br><span class="line"><span class="comment">//obj.[Symbol.iterator]() 就是Iterator遍历器</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  data: [ <span class="string">'hello'</span>, <span class="string">'world'</span> ],</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      next() &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; self.data.length) &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123;</span><br><span class="line">            value: self.data[index++],</span><br><span class="line">            done: <span class="literal">false</span></span><br><span class="line">          &#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><code>ES6</code>给<code>Set</code>、<code>Map</code>、<code>Array</code>、<code>String</code>都加上了<code>[Symbol.iterator]</code>方法，且<code>[Symbol.iterator]</code>方法函数也符合标准的<code>Iterator</code>接口规范，所以<code>Set</code>、<code>Map</code>、<code>Array</code>、<code>String</code>默认都是可以遍历的</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Array</span></span><br><span class="line"><span class="keyword">let</span> array = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>];</span><br><span class="line">array[<span class="built_in">Symbol</span>.iterator]() <span class="comment">//Iterator遍历器</span></span><br><span class="line">array[<span class="built_in">Symbol</span>.iterator]().next() <span class="comment">//&#123;value: "red", done: false&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//String</span></span><br><span class="line"><span class="keyword">let</span> string = <span class="string">'1122334455'</span>;</span><br><span class="line">string[<span class="built_in">Symbol</span>.iterator]() <span class="comment">//Iterator遍历器</span></span><br><span class="line">string[<span class="built_in">Symbol</span>.iterator]().next() <span class="comment">//&#123;value: "1", done: false&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//set</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set(['red', 'green', 'blue']);</span><br><span class="line"><span class="keyword">set</span>[Symbol.iterator]() //Iterator遍历器</span><br><span class="line"><span class="keyword">set</span>[Symbol.iterator]().next() //&#123;value: <span class="string">"red"</span>, <span class="attr">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Map</span></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">let</span> obj= &#123;<span class="attr">map</span>: <span class="string">'map'</span>&#125;;</span><br><span class="line">map.set(obj, <span class="string">'mapValue'</span>);</span><br><span class="line">map[<span class="built_in">Symbol</span>.iterator]().next()  &#123;<span class="attr">value</span>: <span class="built_in">Array</span>(<span class="number">2</span>), <span class="attr">done</span>: <span class="literal">false</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="16、for…in-和for…of有什么区别？"><a href="#16、for…in-和for…of有什么区别？" class="headerlink" title="16、for…in 和for…of有什么区别？"></a>16、for…in 和for…of有什么区别？</h2><blockquote><p>如果看到问题十六，那么就很好回答。问题十六提到了ES6统一了遍历标准，制定了可遍历对象，那么用什么方法去遍历呢？答案就是用<code>for...of</code>。ES6规定，有所部署了载了<code>Iterator</code>接口的对象(可遍历对象)都可以通过<code>for...of</code>去遍历，而<code>for..in</code>仅仅可以遍历对象</p></blockquote><ul><li>这也就意味着，数组也可以用<code>for...of</code>遍历，这极大地方便了数组的取值，且避免了很多程序用<code>for..in</code>去遍历数组的恶习</li></ul><h2 id="17、Generator函数是什么，有什么作用？"><a href="#17、Generator函数是什么，有什么作用？" class="headerlink" title="17、Generator函数是什么，有什么作用？"></a>17、Generator函数是什么，有什么作用？</h2><ul><li>如果说<code>JavaScript</code>是<code>ECMAScript</code>标准的一种具体实现、<code>Iterator</code>遍历器是<code>Iterator</code>的具体实现，那么<code>Generator</code>函数可以说是<code>Iterator</code>接口的具体实现方式。</li><li>执行<code>Generator</code>函数会返回一个遍历器对象，每一次<code>Generator</code>函数里面的<code>yield</code>都相当一次遍历器对象的<code>next()</code>方法，并且可以通过<code>next(value)</code>方法传入自定义的value,来改变<code>Generator</code>函数的行为。</li><li><code>Generator</code>函数可以通过配合<code>Thunk</code> 函数更轻松更优雅的实现异步编程和控制流管理。</li></ul><h2 id="18、async函数是什么，有什么作用？"><a href="#18、async函数是什么，有什么作用？" class="headerlink" title="18、async函数是什么，有什么作用？"></a>18、async函数是什么，有什么作用？</h2><blockquote><p><code>async</code>函数可以理解为内置自动执行器的<code>Generator</code>函数语法糖，它配合<code>ES6</code>的<code>Promise</code>近乎完美的实现了异步编程解决方案</p></blockquote><h2 id="19、Class、extends是什么，有什么作用？"><a href="#19、Class、extends是什么，有什么作用？" class="headerlink" title="19、Class、extends是什么，有什么作用？"></a>19、Class、extends是什么，有什么作用？</h2><blockquote><p><code>ES6</code> 的<code>class</code>可以看作只是一个<code>ES5</code>生成实例对象的构造函数的语法糖。它参考了<code>java</code>语言，定义了一个类的概念，让对象原型写法更加清晰，对象实例化更像是一种面向对象编程。<code>Class</code>类可以通过<code>extends</code>实现继承。它和ES5构造函数的不同点</p></blockquote><p>类的内部定义的所有方法，都是不可枚举的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">///ES5</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ES5Fun</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.x = x;</span><br><span class="line"><span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line">ES5Fun.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> ES5Fun(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">p.toString();</span><br><span class="line"><span class="built_in">Object</span>.keys(ES5Fun.prototype); <span class="comment">//['toString']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ES6</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ES6Fun</span> </span>&#123;</span><br><span class="line"><span class="keyword">constructor</span> (x, y) &#123;</span><br><span class="line"><span class="keyword">this</span>.x = x;</span><br><span class="line"><span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line">toString () &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(ES6Fun.prototype); <span class="comment">//[]</span></span><br></pre></td></tr></table></figure><ul><li><code>ES6</code>的<code>class</code>类必须用<code>new</code>命令操作，而<code>ES5</code>的构造函数不用<code>new</code>也可以执行。</li><li><code>ES6</code>的<code>class</code>类不存在变量提升，必须先定义<code>class</code>之后才能实例化，不像<code>ES5</code>中可以将构造函数写在实例化之后。</li><li><code>ES5</code> 的继承，实质是先创造子类的实例对象<code>this</code>，然后再将父类的方法添加到<code>this</code>上面。<code>ES6</code> 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到<code>this</code>上面（所以必须先调用<code>super</code>方法），然后再用子类的构造函数修改<code>this</code>。</li></ul><h2 id="20、module、export、import是什么，有什么作用？"><a href="#20、module、export、import是什么，有什么作用？" class="headerlink" title="20、module、export、import是什么，有什么作用？"></a>20、module、export、import是什么，有什么作用？</h2><ul><li><code>module</code>、<code>export</code>、<code>import</code>是<code>ES6</code>用来统一前端模块化方案的设计思路和实现方案。<code>export</code>、<code>import</code>的出现统一了前端模块化的实现方案，整合规范了浏览器/服务端的模块化方法，用来取代传统的<code>AMD/CMD</code>、<code>requireJS</code>、<code>seaJS</code>、<code>commondJS</code>等等一系列前端模块不同的实现方案，使前端模块化更加统一规范，<code>JS</code>也能更加能实现大型的应用程序开发。</li><li><code>import</code>引入的模块是静态加载（编译阶段加载）而不是动态加载（运行时加载）。</li><li><code>import</code>引入<code>export</code>导出的接口值是动态绑定关系，即通过该接口，可以取到模块内部实时的值</li></ul><h2 id="21、日常前端代码开发中，有哪些值得用ES6去改进的编程优化或者规范？"><a href="#21、日常前端代码开发中，有哪些值得用ES6去改进的编程优化或者规范？" class="headerlink" title="21、日常前端代码开发中，有哪些值得用ES6去改进的编程优化或者规范？"></a>21、日常前端代码开发中，有哪些值得用ES6去改进的编程优化或者规范？</h2><ul><li>常用箭头函数来取代<code>var self = this</code>;的做法。</li><li>常用<code>let</code>取代<code>var</code>命令。</li><li>常用数组/对象的结构赋值来命名变量，结构更清晰，语义更明确，可读性更好。</li><li>在长字符串多变量组合场合，用模板字符串来取代字符串累加，能取得更好地效果和阅读体验。</li><li>用<code>Class</code>类取代传统的构造函数，来生成实例化对象。</li><li>在大型应用开发中，要保持<code>module</code>模块化开发思维，分清模块之间的关系，常用<code>import</code>、<code>export</code>方法。</li></ul><h2 id="22、ES6的了解"><a href="#22、ES6的了解" class="headerlink" title="22、ES6的了解"></a>22、ES6的了解</h2><blockquote><p>新增模板字符串（为JavaScript提供了简单的字符串插值功能）、箭头函数（操作符左边为输入的参数，而右边则是进行的操作以及返回的值Inputs=&gt;outputs。）、for-of（用来遍历数据—例如数组中的值。）arguments对象可被不定参数和默认参数完美代替。ES6将promise对象纳入规范，提供了原生的Promise对象。增加了let和const命令，用来声明变量。增加了块级作用域。let命令实际上就增加了块级作用域。ES6规定，var命令和function命令声明的全局变量，属于全局对象的属性；let命令、const命令、class命令声明的全局变量，不属于全局对象的属性。。还有就是引入module模块的概念</p></blockquote><h2 id="23、说说你对Promise的理解"><a href="#23、说说你对Promise的理解" class="headerlink" title="23、说说你对Promise的理解"></a>23、说说你对Promise的理解</h2><ul><li>依照 Promise/A+ 的定义，Promise 有四种状态：<ul><li>pending: 初始状态, 非 fulfilled 或 rejected.</li><li>fulfilled: 成功的操作.</li><li>rejected: 失败的操作.</li><li>settled: Promise已被fulfilled或rejected，且不是pending</li></ul></li><li>另外， fulfilled 与 rejected 一起合称 settled</li><li>Promise 对象用来进行延迟(deferred) 和异步(asynchronous ) 计算</li></ul><h2 id="24、Promise-的构造函数"><a href="#24、Promise-的构造函数" class="headerlink" title="24、Promise 的构造函数"></a>24、Promise 的构造函数</h2><ul><li>构造一个 Promise，最基本的用法如下：</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (...) &#123;  <span class="comment">// succeed</span></span><br><span class="line"></span><br><span class="line">            resolve(result);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;   <span class="comment">// fails</span></span><br><span class="line"></span><br><span class="line">            reject(<span class="built_in">Error</span>(errMessage));</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><ul><li>Promise 实例拥有 then 方法（具有 then 方法的对象，通常被称为thenable）。它的使用方法如下：</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">promise.then(onFulfilled, onRejected)</span><br></pre></td></tr></table></figure><ul><li>接收两个函数作为参数，一个在 fulfilled 的时候被调用，一个在rejected的时候被调用，接收参数就是 future，onFulfilled 对应 resolve, onRejected 对应 reject</li></ul><p><strong>什么是 Promise ？</strong></p><ul><li>Promise 就是一个对象，用来表示并传递异步操作的最终结果</li><li>Promise 最主要的交互方式：将回调函数传入 then 方法来获得最终结果或出错原因</li><li>Promise 代码书写上的表现：以“链式调用”代替回调函数层层嵌套（回调地狱）</li></ul><h2 id="25、谈一谈你了解ECMAScript6的新特性？"><a href="#25、谈一谈你了解ECMAScript6的新特性？" class="headerlink" title="25、谈一谈你了解ECMAScript6的新特性？"></a>25、谈一谈你了解ECMAScript6的新特性？</h2><ul><li>块级作用区域              <code>let a = 1;</code></li><li>可定义常量                <code>const PI = 3.141592654;</code></li><li>变量解构赋值              <code>var [a, b, c] = [1, 2, 3];</code></li><li>字符串的扩展(模板字符串)  <code>var sum =</code>${a + b}<code>;</code></li><li>数组的扩展(转换数组类型)   <code>Array.from($(&#39;li&#39;));</code></li><li>函数的扩展(扩展运算符)     <code>[1, 2].push(...[3, 4, 5]);</code></li><li>对象的扩展(同值相等算法)   <code>Object.is(NaN, NaN);</code></li><li>新增数据类型(Symbol)      <code>let uid = Symbol(&#39;uid&#39;);</code></li><li>新增数据结构(Map)        <code>let set = new Set([1, 2, 2, 3]);</code></li><li>for…of循环            <code>for(let val of arr){};</code></li><li>Promise对象            <code>var promise = new Promise(func);</code></li><li>Generator函数          <code>function* foo(x){yield x; return x*x;}</code></li><li>引入Class(类)          <code>class Foo {}</code></li><li>引入模块体系            <code>export default func;</code></li><li>引入async函数[ES7]    </li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncPrint</span>(<span class="params">value, ms</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">await</span> timeout(ms);</span><br><span class="line">      <span class="built_in">console</span>.log(value)</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h2 id="26、Object-is-与原来的比较操作符-、-的区别？"><a href="#26、Object-is-与原来的比较操作符-、-的区别？" class="headerlink" title="26、Object.is() 与原来的比较操作符 ===、== 的区别？"></a>26、Object.is() 与原来的比较操作符 ===、== 的区别？</h2><ul><li>== 相等运算符，比较时会自动进行数据类型转换</li><li>=== 严格相等运算符，比较时不进行隐式类型转换</li><li>Object.is 同值相等算法，在 === 基础上对 0 和 NaN 特别处理</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+0 &#x3D;&#x3D;&#x3D; -0 &#x2F;&#x2F;true</span><br><span class="line">NaN &#x3D;&#x3D;&#x3D; NaN &#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">Object.is(+0, -0) &#x2F;&#x2F; false</span><br><span class="line">Object.is(NaN, NaN) &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><h2 id="27、什么是-Babel"><a href="#27、什么是-Babel" class="headerlink" title="27、什么是 Babel"></a>27、什么是 Babel</h2><ul><li>Babel 是一个 JS 编译器，自带一组 ES6 语法转化器，用于转化 JS 代码。<br>这些转化器让开发者提前使用最新的 JS语法(ES6/ES7)，而不用等浏览器全部兼容。</li><li>Babel 默认只转换新的 JS 句法(syntax)，而不转换新的API。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 小知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>前端知识 - 性能优化</title>
      <link href="/2017/07/15/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%20-%20%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
      <url>/2017/07/15/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%20-%20%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h5 id="前端知识-性能优化"><a href="#前端知识-性能优化" class="headerlink" title="前端知识 - 性能优化"></a>前端知识 - 性能优化</h5><p>资料整理</p><a id="more"></a><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><h3 id="1-DNS-预解析"><a href="#1-DNS-预解析" class="headerlink" title="1 DNS 预解析"></a>1 DNS 预解析</h3><ul><li><code>DNS</code> 解析也是需要时间的，可以通过预解析的方式来预先获得域名所对应的 <code>IP</code></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"dns-prefetch"</span> <span class="attr">href</span>=<span class="string">"//shudong.wang"</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-缓存"><a href="#2-缓存" class="headerlink" title="2 缓存"></a>2 缓存</h3><ul><li>缓存对于前端性能优化来说是个很重要的点，良好的缓存策略可以降低资源的重复加载提高网页的整体加载速度</li><li>通常浏览器缓存策略分为两种：强缓存和协商缓存</li></ul><p><strong>强缓存</strong></p><blockquote><p>实现强缓存可以通过两种响应头实现：<code>Expires</code>和 <code>Cache-Control</code> 。强缓存表示在缓存期间不需要请求，<code>state code</code>为 <code>200</code></p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Expires: Wed, 22 Oct 2018 08:41:00 GMT</span><br></pre></td></tr></table></figure><blockquote><p><code>Expires</code> 是 <code>HTTP / 1.0</code> 的产物，表示资源会在 <code>Wed, 22 Oct 2018 08:41:00 GMT</code> 后过期，需要再次请求。并且 <code>Expires</code> 受限于本地时间，如果修改了本地时间，可能会造成缓存失效</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cache-control: max-age&#x3D;30</span><br></pre></td></tr></table></figure><blockquote><p><code>Cache-Control</code> 出现于 <code>HTTP / 1.1</code>，优先级高于 <code>Expires</code> 。该属性表示资源会在 <code>30</code> 秒后过期，需要再次请求</p></blockquote><p><strong>协商缓存</strong></p><ul><li>如果缓存过期了，我们就可以使用协商缓存来解决问题。协商缓存需要请求，如果缓存有效会返回 304</li><li>协商缓存需要客户端和服务端共同实现，和强缓存一样，也有两种实现方式</li></ul><p><code>Last-Modified</code> 和 <code>If-Modified-Since</code></p><ul><li><code>Last-Modified</code> 表示本地文件最后修改日期，<code>If-Modified-Since</code> 会将 <code>Last-Modified</code>的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来</li><li>但是如果在本地打开缓存文件，就会造成 <code>Last-Modified</code> 被修改，所以在 <code>HTTP / 1.1</code> 出现了 <code>ETag</code></li></ul><p><code>ETag</code> 和 <code>If-None-Match</code></p><ul><li><code>ETag</code> 类似于文件指纹，<code>If-None-Match</code> 会将当前 <code>ETag</code> 发送给服务器，询问该资源 ETag 是否变动，有变动的话就将新的资源发送回来。并且 <code>ETag</code> 优先级比 <code>Last-Modified</code> 高</li></ul><p><strong>选择合适的缓存策略</strong></p><blockquote><p>对于大部分的场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方可能需要选择特殊的缓存策略</p></blockquote><ul><li>对于某些不需要缓存的资源，可以使用 <code>Cache-control: no-store</code> ，表示该资源不需要缓存</li><li>对于频繁变动的资源，可以使用 <code>Cache-Control: no-cache</code> 并配合 <code>ETag</code> 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新。</li><li>对于代码文件来说，通常使用 <code>Cache-Control: max-age=31536000</code> 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件</li></ul><h3 id="3-使用-HTTP-2-0"><a href="#3-使用-HTTP-2-0" class="headerlink" title="3 使用 HTTP / 2.0"></a>3 使用 HTTP / 2.0</h3><ul><li>因为浏览器会有并发请求限制，在 <code>HTTP / 1.1</code> 时代，每个请求都需要建立和断开，消耗了好几个 <code>RTT</code> 时间，并且由于 <code>TCP</code> 慢启动的原因，加载体积大的文件会需要更多的时间</li><li>在 <code>HTTP / 2.0</code> 中引入了多路复用，能够让多个请求使用同一个 <code>TCP</code> 链接，极大的加快了网页的加载速度。并且还支持 <code>Header</code> 压缩，进一步的减少了请求的数据大小</li></ul><h3 id="4-预加载"><a href="#4-预加载" class="headerlink" title="4 预加载"></a>4 预加载</h3><ul><li>在开发中，可能会遇到这样的情况。有些资源不需要马上用到，但是希望尽早获取，这时候就可以使用预加载</li><li>预加载其实是声明式的 <code>fetch</code> ，强制浏览器请求资源，并且不会阻塞 <code>onload</code> 事件，可以使用以下代码开启预加载</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preload"</span> <span class="attr">href</span>=<span class="string">"http://example.com"</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>预加载可以一定程度上降低首屏的加载时间，因为可以将一些不影响首屏但重要的文件延后加载，唯一缺点就是兼容性不好</p></blockquote><h3 id="5-预渲染"><a href="#5-预渲染" class="headerlink" title="5 预渲染"></a>5 预渲染</h3><blockquote><p>可以通过预渲染将下载的文件预先在后台渲染，可以使用以下代码开启预渲染</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"prerender"</span> <span class="attr">href</span>=<span class="string">"http://poetries.com"</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>预渲染虽然可以提高页面的加载速度，但是要确保该页面百分百会被用户在之后打开，否则就白白浪费资源去渲染</li></ul><h3 id="6-懒执行与懒加载"><a href="#6-懒执行与懒加载" class="headerlink" title="6 懒执行与懒加载"></a>6 懒执行与懒加载</h3><p><strong>懒执行</strong></p><ul><li>懒执行就是将某些逻辑延迟到使用时再计算。该技术可以用于首屏优化，对于某些耗时逻辑并不需要在首屏就使用的，就可以使用懒执行。懒执行需要唤醒，一般可以通过定时器或者事件的调用来唤醒</li></ul><p><strong>懒加载</strong></p><ul><li>懒加载就是将不关键的资源延后加载</li></ul><blockquote><p>懒加载的原理就是只加载自定义区域（通常是可视区域，但也可以是即将进入可视区域）内需要加载的东西。对于图片来说，先设置图片标签的 <code>src</code> 属性为一张占位图，将真实的图片资源放入一个自定义属性中，当进入自定义区域时，就将自定义属性替换为 <code>src</code> 属性，这样图片就会去下载资源，实现了图片懒加载</p></blockquote><ul><li>懒加载不仅可以用于图片，也可以使用在别的资源上。比如进入可视区域才开始播放视频等</li></ul><h3 id="7-文件优化"><a href="#7-文件优化" class="headerlink" title="7 文件优化"></a>7 文件优化</h3>]]></content>
      
      
      <categories>
          
          <category> 小知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript知识 - event loop</title>
      <link href="/2017/07/15/JavaScript%E7%9F%A5%E8%AF%86%20-%20event%20loop/"/>
      <url>/2017/07/15/JavaScript%E7%9F%A5%E8%AF%86%20-%20event%20loop/</url>
      
        <content type="html"><![CDATA[<h5 id="JavaScript知识-event-loop"><a href="#JavaScript知识-event-loop" class="headerlink" title="JavaScript知识 - event loop"></a>JavaScript知识 - event loop</h5><p>JavaScript资料整理</p><a id="more"></a><h3 id="Event-loop"><a href="#Event-loop" class="headerlink" title="Event loop"></a>Event loop</h3><p><strong>JS中的event loop</strong></p><blockquote><p>众所周知 <code>JS</code> 是门非阻塞单线程语言，因为在最初 <code>JS</code> 就是为了和浏览器交互而诞生的。如果 <code>JS</code> 是门多线程的语言话，我们在多个线程中处理 <code>DOM</code> 就可能会发生问题（一个线程中新加节点，另一个线程中删除节点）</p></blockquote><ul><li><code>JS</code> 在执行的过程中会产生执行环境，这些执行环境会被顺序的加入到执行栈中。如果遇到异步的代码，会被挂起并加入到 <code>Task</code>（有多种 <code>task</code>） 队列中。一旦执行栈为空，<code>Event</code> <code>Loop</code> 就会从 <code>Task</code> 队列中拿出需要执行的代码并放入执行栈中执行，所以本质上来说 <code>JS</code> 中的异步还是同步行为</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>);</span><br></pre></td></tr></table></figure><blockquote><p>不同的任务源会被分配到不同的 <code>Task</code> 队列中，任务源可以分为 微任务（<code>microtask</code>） 和 宏任务（<code>macrotask</code>）。在 <code>ES6</code> 规范中，<code>microtask</code> 称为 jobs，macrotask 称为 task</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Promise'</span>)</span><br><span class="line">    resolve()</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise2'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>);</span><br><span class="line"><span class="comment">// script start =&gt; Promise =&gt; script end =&gt; promise1 =&gt; promise2 =&gt; setTimeout</span></span><br></pre></td></tr></table></figure><blockquote><p>以上代码虽然 <code>setTimeout</code> 写在 <code>Promise</code> 之前，但是因为 <code>Promise</code> 属于微任务而 <code>setTimeout</code> 属于宏任务</p></blockquote><p><strong>微任务</strong></p><ul><li><code>process.nextTick</code></li><li><code>promise</code></li><li><code>Object.observe</code></li><li><code>MutationObserver</code></li></ul><p><strong>宏任务</strong></p><ul><li><code>script</code></li><li><code>setTimeout</code></li><li><code>setInterval</code></li><li><code>setImmediate</code></li><li><code>I/O</code></li><li><code>UI rendering</code></li></ul><blockquote><p>宏任务中包括了 <code>script</code> ，浏览器会先执行一个宏任务，接下来有异步代码的话就先执行微任务</p></blockquote><p><strong>所以正确的一次 Event loop 顺序是这样的</strong></p><ul><li>执行同步代码，这属于宏任务</li><li>执行栈为空，查询是否有微任务需要执行</li><li>执行所有微任务</li><li>必要的话渲染 UI</li><li>然后开始下一轮 <code>Event loop</code>，执行宏任务中的异步代码</li></ul><blockquote><p>通过上述的 <code>Event loop</code> 顺序可知，如果宏任务中的异步代码有大量的计算并且需要操作 <code>DOM</code> 的话，为了更快的响应界面响应，我们可以把操作 <code>DOM</code> 放入微任务中</p></blockquote><p><strong>Node 中的 Event loop</strong></p><ul><li><code>Node</code> 中的 <code>Event loop</code> 和浏览器中的不相同。</li><li><code>Node</code> 的 <code>Event loop</code> 分为<code>6</code>个阶段，它们会按照顺序反复运行</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">┌───────────────────────┐</span><br><span class="line">┌─&gt;│        timers         │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     I/O callbacks     │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     idle, prepare     │</span><br><span class="line">│  └──────────┬────────────┘      ┌───────────────┐</span><br><span class="line">│  ┌──────────┴────────────┐      │   incoming:   │</span><br><span class="line">│  │         poll          │&lt;──connections───     │</span><br><span class="line">│  └──────────┬────────────┘      │   data, etc.  │</span><br><span class="line">│  ┌──────────┴────────────┐      └───────────────┘</span><br><span class="line">│  │        check          │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">└──┤    close callbacks    │</span><br><span class="line">   └───────────────────────┘</span><br></pre></td></tr></table></figure><p><strong>timer</strong></p><ul><li><code>timers</code> 阶段会执行 <code>setTimeout</code> 和 <code>setInterval</code></li><li>一个 timer 指定的时间并不是准确时间，而是在达到这个时间后尽快执行回调，可能会因为系统正在执行别的事务而延迟</li></ul><p><strong>I/O</strong></p><ul><li><code>I/O</code> 阶段会执行除了 <code>close</code> 事件，定时器和 <code>setImmediate</code> 的回调</li></ul><p><strong>poll</strong></p><ul><li><code>poll</code> 阶段很重要，这一阶段中，系统会做两件事情<ul><li>执行到点的定时器</li><li>执行 <code>poll</code> 队列中的事件</li></ul></li><li>并且当 <code>poll</code> 中没有定时器的情况下，会发现以下两件事情<ul><li>如果 <code>poll</code> 队列不为空，会遍历回调队列并同步执行，直到队列为空或者系统限制</li><li>如果 <code>poll</code> 队列为空，会有两件事发生</li><li>如果有 <code>setImmediate</code> 需要执行，<code>poll</code> 阶段会停止并且进入到 <code>check</code> 阶段执行 <code>setImmediate</code></li><li>如果没有 <code>setImmediate</code> 需要执行，会等待回调被加入到队列中并立即执行回调</li><li>如果有别的定时器需要被执行，会回到 <code>timer</code> 阶段执行回调。</li></ul></li></ul><p><strong>check</strong></p><ul><li><code>check</code> 阶段执行 <code>setImmediate</code></li></ul><p><strong>close callbacks</strong></p><ul><li><code>close callbacks</code> 阶段执行 <code>close</code> 事件</li><li>并且在 <code>Node</code> 中，有些情况下的定时器执行顺序是随机的</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line">setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setImmediate'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 这里可能会输出 setTimeout，setImmediate</span></span><br><span class="line"><span class="comment">// 可能也会相反的输出，这取决于性能</span></span><br><span class="line"><span class="comment">// 因为可能进入 event loop 用了不到 1 毫秒，这时候会执行 setImmediate</span></span><br><span class="line"><span class="comment">// 否则会执行 setTimeout</span></span><br></pre></td></tr></table></figure><blockquote><p>上面介绍的都是 <code>macrotask</code> 的执行情况，<code>microtask</code> 会在以上每个阶段完成后立即执行</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timer1'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timer2'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'promise2'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上代码在浏览器和 node 中打印情况是不同的</span></span><br><span class="line"><span class="comment">// 浏览器中一定打印 timer1, promise1, timer2, promise2</span></span><br><span class="line"><span class="comment">// node 中可能打印 timer1, timer2, promise1, promise2</span></span><br><span class="line"><span class="comment">// 也可能打印 timer1, promise1, timer2, promise2</span></span><br></pre></td></tr></table></figure><blockquote><p><code>Node</code> 中的 <code>process.nextTick</code> 会先于其他 <code>microtask</code> 执行</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">"timer1"</span>);</span><br><span class="line"></span><br><span class="line"> <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"promise1"</span>);</span><br><span class="line"> &#125;);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">"nextTick"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// nextTick, timer1, promise1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 小知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>前端知识 - CSS</title>
      <link href="/2017/07/12/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%20-%20CSS/"/>
      <url>/2017/07/12/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%20-%20CSS/</url>
      
        <content type="html"><![CDATA[<h5 id="前端知识-CSS"><a href="#前端知识-CSS" class="headerlink" title="前端知识 - CSS"></a>前端知识 - CSS</h5><p>资料整理</p><a id="more"></a><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><hr><p><strong>display: none; 与 visibility: hidden; 的区别</strong></p><ul><li>联系：它们都能让元素不可见</li><li>区别：<ul><li><code>display:none</code>;会让元素完全从渲染树中消失，渲染的时候不占据任何空间；<code>visibility: hidden</code>;不会让元素从渲染树消失，渲染师元素继续占据空间，只是内容不可见</li><li><code>display: none</code>;是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示；<code>visibility:hidden</code>;是继承属性，子孙节点消失由于继承了<code>hidden</code>，通过设置<code>visibility: visible</code>;可以让子孙节点显式</li><li>修改常规流中元素的<code>display</code>通常会造成文档重排。修改<code>visibility</code>属性只会造成本元素的重绘</li><li>读屏器不会读取<code>display: none;</code>元素内容；会读取<code>visibility: hidden</code>元素内容</li></ul></li></ul><p><strong>css hack原理及常用hack</strong></p><ul><li>原理：利用不同浏览器对CSS的支持和解析结果不一样编写针对特定浏览器样式。</li><li>常见的hack有<ul><li>属性hack</li><li>选择器hack</li><li>IE条件注释</li></ul></li></ul><p><strong>link 与 @import 的区别</strong></p><ul><li><code>link</code> 是<code>HTML</code>方式， <code>@import</code> 是<code>CSS</code>方式</li><li><code>link</code>最大限度支持并行下载，<code>@import</code> 过多嵌套导致串行下载，出现FOUC</li><li><code>link</code> 可以通过 <code>rel=&quot;alternate stylesheet&quot;</code> 指定候选样式</li><li>浏览器对 <code>link</code> 支持早于<code>@import</code> ，可以使用 <code>@import</code> 对老浏览器隐藏样式</li><li><code>@import</code> 必须在样式规则之前，可以在<code>css</code>文件中引用其他文件</li><li>总体来说：<code>link</code>优于<code>@import</code></li></ul><p><strong>CSS有哪些继承属性</strong></p><ul><li>关于文字排版的属性如：<ul><li><code>font</code></li><li><code>word-break</code></li><li><code>letter-spacing</code></li><li><code>text-align</code></li><li><code>text-rendering</code></li><li><code>word-spacing</code></li><li><code>white-space</code></li><li><code>text-indent</code></li><li><code>text-transform</code></li><li><code>text-shadow</code></li><li><code>line-height</code></li><li><code>color</code></li><li><code>visibility</code></li><li><code>cursor</code></li></ul></li></ul><p><strong>display,float,position的关系</strong></p><ul><li><p>如果 <code>display</code> 为<code>none</code>，那么<code>position</code>和<code>float</code>都不起作用，这种情况下元素不产生框</p></li><li><p>否则，如果<code>position</code>值为<code>absolute</code>或者<code>fixed</code>，框就是绝对定位的，<code>float</code>的计算值为<code>none</code>，<code>display</code>根据下面的表格进行调整</p></li><li><p>否则，如果<code>float</code>不是<code>none</code>，框是浮动的，<code>display</code>根据下表进行调整</p></li><li><p>否则，如果元素是根元素，<code>display</code>根据下表进行调整</p></li><li><p>其他情况下<code>display</code>的值为指定值 总结起来：绝对定位、浮动、根元素都需要调整 <code>display</code></p><p><img src="https://images2018.cnblogs.com/blog/715962/201805/715962-20180513012245079-391725349.png" alt="图片转自网络"></p></li></ul><p><strong>外边距折叠(collapsing margins)</strong></p><ul><li>毗邻的两个或多个 <code>margin</code> 会合并成一个<code>margin</code>，叫做外边距折叠。规则如下：<ul><li>两个或多个毗邻的普通流中的块元素垂直方向上的<code>margin</code>会折叠</li><li>浮动元素或<code>inline-block</code>元素或绝对定位元素的<code>margin</code>不会和垂直方向上的其他元素的margin折叠</li><li>创建了块级格式化上下文的元素，不会和它的子元素发生margin折叠</li><li>元素自身的<code>margin-bottom</code>和<code>margin-top</code>相邻时也会折</li></ul></li></ul><p><strong>介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？</strong></p><ul><li>有两种， IE 盒子模型、W3C 盒子模型；</li><li>盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)；</li><li>区  别： IE的content部分把 border 和 padding计算了进去;</li></ul><p><strong>CSS选择符有哪些？哪些属性可以继承？</strong></p><ul><li>id选择器（ # myid）</li><li>类选择器（.myclassname）</li><li>标签选择器（div, h1, p）</li><li>相邻选择器（h1 + p）</li><li>子选择器（ul &gt; li）</li><li>后代选择器（li a）</li><li>通配符选择器（ * ）</li><li>属性选择器（a[rel = “external”]）</li><li>伪类选择器（a:hover, li:nth-child）</li><li>可继承的样式： <code>font-size font-family color, UL LI DL DD DT</code></li><li>不可继承的样式：<code>border padding margin width height</code></li></ul><p><strong>CSS优先级算法如何计算？</strong></p><ul><li>优先级就近原则，同权重情况下样式定义最近者为准</li><li>载入样式以最后载入的定位为准</li><li>优先级为: <code>!important &gt;  id &gt; class &gt; tag</code> important 比 内联优先级高</li></ul><p><strong>CSS3新增伪类有那些？</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p:first-of-type 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</span><br><span class="line">p:last-of-type  选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</span><br><span class="line">p:only-of-type  选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。</span><br><span class="line">p:only-child        选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。</span><br><span class="line">p:nth-child(2)  选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。</span><br><span class="line"></span><br><span class="line">:after          在元素之前添加内容,也可以用来做清除浮动。</span><br><span class="line">:before         在元素之后添加内容</span><br><span class="line">:enabled        </span><br><span class="line">:disabled       控制表单控件的禁用状态。</span><br><span class="line">:checked        单选框或复选框被选中</span><br></pre></td></tr></table></figure><p><strong>如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？</strong></p><ul><li>给<code>div</code>设置一个宽度，然后添加<code>margin:0 auto</code>属性</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">div&#123;</span><br><span class="line">    width:200px;</span><br><span class="line">    margin:0 auto;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li>居中一个浮动元素</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;确定容器的宽高 宽500 高 300 的层</span><br><span class="line">&#x2F;&#x2F;设置层的外边距</span><br><span class="line"></span><br><span class="line"> .div &#123;</span><br><span class="line">      width:500px ; height:300px;&#x2F;&#x2F;高度可以不设</span><br><span class="line">      margin: -150px 0 0 -250px;</span><br><span class="line">      position:relative;         &#x2F;&#x2F;相对定位</span><br><span class="line">      background-color:pink;     &#x2F;&#x2F;方便看效果</span><br><span class="line">      left:50%;</span><br><span class="line">      top:50%;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li>让绝对定位的div居中</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">position: absolute;</span><br><span class="line">width: 1200px;</span><br><span class="line">background: none;</span><br><span class="line">margin: 0 auto;</span><br><span class="line">top: 0;</span><br><span class="line">left: 0;</span><br><span class="line">bottom: 0;</span><br><span class="line">right: 0;</span><br></pre></td></tr></table></figure><p><strong>display有哪些值？说明他们的作用</strong></p><ul><li>block         象块类型元素一样显示。</li><li>none          缺省值。象行内元素类型一样显示。</li><li>inline-block  象行内元素一样显示，但其内容象块类型元素一样显示。</li><li>list-item     象块类型元素一样显示，并添加样式列表标记。</li><li>table         此元素会作为块级表格来显示</li><li>inherit       规定应该从父元素继承 display 属性的值</li></ul><p><strong>position的值relative和absolute定位原点是？</strong></p><ul><li>absolute<ul><li>生成绝对定位的元素，相对于值不为 static的第一个父元素进行定位。</li></ul></li><li>fixed （老IE不支持）<ul><li>生成绝对定位的元素，相对于浏览器窗口进行定位。</li></ul></li><li>relative<ul><li>生成相对定位的元素，相对于其正常位置进行定位。</li></ul></li><li>static<ul><li>默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right - z-index 声明）。</li></ul></li><li>inherit<ul><li>规定从父元素继承 position 属性的值</li></ul></li></ul><p><strong>CSS3有哪些新特性？</strong></p><ul><li>新增各种CSS选择器  （: not(.input)：所有 class 不是“input”的节点）</li><li>圆角           （border-radius:8px）</li><li>多列布局        （multi-column layout）</li><li>阴影和反射        （Shadow\Reflect）</li><li>文字特效      （text-shadow、）</li><li>文字渲染      （Text-decoration）</li><li>线性渐变      （gradient）</li><li>旋转          （transform）</li><li>增加了旋转,缩放,定位,倾斜,动画，多背景</li><li><code>transform:\scale(0.85,0.90)\ translate(0px,-30px)\ skew(-9deg,0deg)\Animation:</code></li></ul><p><strong>用纯CSS创建一个三角形的原理是什么？</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 把上、左、右三条边隐藏掉（颜色设为 transparent）</span><br><span class="line">#demo &#123;</span><br><span class="line">  width: 0;</span><br><span class="line">  height: 0;</span><br><span class="line">  border-width: 20px;</span><br><span class="line">  border-style: solid;</span><br><span class="line">  border-color: transparent transparent red transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>一个满屏 品 字布局 如何设计?</strong></p><ul><li>简单的方式：<ul><li>上面的div宽100%，</li><li>下面的两个div分别宽50%，</li><li>然后用float或者inline使其不换行即可</li></ul></li></ul><p><strong>经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧 ？</strong></p><ul><li>png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.</li><li>浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一</li><li>IE下,可以使用获取常规属性的方法来获取自定义属性,也可以使用getAttribute()获取自定义属性;</li><li>Firefox下,只能使用getAttribute()获取自定义属性。<ul><li>解决方法:统一通过getAttribute()获取自定义属性</li></ul></li><li>IE下,even对象有x,y属性,但是没有pageX,pageY属性</li><li>Firefox下,event对象有pageX,pageY属性,但是没有x,y属性</li></ul><p><strong>li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？</strong></p><ul><li>行框的排列会受到中间空白（回车\空格）等的影响，因为空格也属于字符,这些空白也会被应用样式，占据空间，所以会有间隔，把字符大小设为0，就没有空格了</li></ul><p><strong>为什么要初始化CSS样式</strong></p><ul><li>因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异</li></ul><p><strong>对BFC规范(块级格式化上下文：block formatting context)的理解？</strong></p><ul><li>一个页面是由很多个 Box 组成的,元素的类型和 display 属性,决定了这个 Box 的类型</li><li>不同类型的 Box,会参与不同的 Formatting Context（决定如何渲染文档的容器）,因此Box内的元素会以不同的方式渲染,也就是说BFC内部的元素和外部的元素不会互相影响</li></ul><p><strong>css定义的权重</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 以下是权重的规则：标签的权重为1，class的权重为10，id的权重为100，以下&#x2F;&#x2F;&#x2F; 例子是演示各种定义的权重值：</span><br><span class="line"></span><br><span class="line">&#x2F;*权重为1*&#x2F;</span><br><span class="line">div&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*权重为10*&#x2F;</span><br><span class="line">.class1&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*权重为100*&#x2F;</span><br><span class="line">#id1&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*权重为100+1&#x3D;101*&#x2F;</span><br><span class="line">#id1 div&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*权重为10+1&#x3D;11*&#x2F;</span><br><span class="line">.class1 div&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*权重为10+10+1&#x3D;21*&#x2F;</span><br><span class="line">.class1 .class2 div&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果权重相同，则最后定义的样式会起作用，但是应该避免这种情况出现</span><br></pre></td></tr></table></figure><p><strong>display:inline-block 什么时候会显示间隙？(携程)</strong></p><ul><li>移除空格、使用margin负值、使用font-size:0、letter-spacing、word-spacing</li></ul><p><strong>谈谈浮动和清除浮动</strong></p><ul><li>浮动的框可以向左或向右移动，直到他的外边缘碰到包含框或另一个浮动框的边框为止。由于浮动框不在文档的普通流中，所以文档的普通流的块框表现得就像浮动框不存在一样。浮动的块框会漂浮在文档普通流的块框上</li></ul><p><strong>介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？</strong></p><ul><li>盒子模型构成：内容(content)、内填充(padding)、 边框(border)、外边距(margin)</li><li>IE8及其以下版本浏览器，未声明 DOCTYPE，内容宽高会包含内填充和边框，称为怪异盒模型(IE盒模型)</li><li>标准(W3C)盒模型：元素宽度 = width + padding + border + margin</li><li>怪异(IE)盒模型：元素宽度 = width + margin</li><li>标准浏览器通过设置 css3 的 box-sizing: border-box 属性，触发“怪异模式”解析计算宽高</li></ul><p><strong>box-sizing 常用的属性有哪些？分别有什么作用？</strong></p><ul><li>box-sizing: content-box;  // 默认的标准(W3C)盒模型元素效果</li><li>box-sizing: border-box;   // 触发怪异(IE)盒模型元素的效果</li><li>box-sizing: inherit;      //  继承父元素 box-sizing 属性的值</li></ul><p><strong>CSS选择器有哪些？</strong></p><ul><li>id选择器        #id</li><li>类选择器        .class</li><li>标签选择器      div, h1, p</li><li>相邻选择器      h1 + p</li><li>子选择器        ul &gt; li</li><li>后代选择器      li a</li><li>通配符选择器    *</li><li>属性选择器      a[rel=’external’]</li><li>伪类选择器      a:hover, li:nth-child</li></ul><p><strong>CSS哪些属性可以继承？哪些属性不可以继承？</strong></p><ul><li>可以继承的样式：font-size、font-family、color、list-style、cursor</li><li>不可继承的样式：width、height、border、padding、margin、background</li></ul><p><strong>CSS如何计算选择器优先？</strong></p><ul><li>相同权重，定义最近者为准：行内样式 &gt; 内部样式 &gt; 外部样式</li><li>含外部载入样式时，后载入样式覆盖其前面的载入的样式和内部样式</li><li>选择器优先级: 行内样式[1000] &gt; id[100] &gt; class[10] &gt; Tag[1]</li><li>在同一组属性设置中，!important 优先级最高，高于行内样式</li></ul><p><strong>CSS3新增伪类有哪些？</strong></p><ul><li>:root           选择文档的根元素，等同于 html 元素</li><li>:empty          选择没有子元素的元素</li><li>:target         选取当前活动的目标元素</li><li>:not(selector)  选择除 selector 元素意外的元素</li><li>:enabled        选择可用的表单元素</li><li>:disabled       选择禁用的表单元素</li><li>:checked        选择被选中的表单元素</li><li>:after          在元素内部最前添加内容</li><li>:before         在元素内部最后添加内容</li><li>:nth-child(n)      匹配父元素下指定子元素，在所有子元素中排序第n</li><li>:nth-last-child(n) 匹配父元素下指定子元素，在所有子元素中排序第n，从后向前数</li><li>:nth-child(odd)</li><li>:nth-child(even)</li><li>:nth-child(3n+1)</li><li>:first-child</li><li>:last-child</li><li>:only-child</li><li>:nth-of-type(n)      匹配父元素下指定子元素，在同类子元素中排序第n</li><li>:nth-last-of-type(n) 匹配父元素下指定子元素，在同类子元素中排序第n，从后向前数</li><li>:nth-of-type(odd)</li><li>:nth-of-type(even)</li><li>:nth-of-type(3n+1)</li><li>:first-of-type</li><li>:last-of-type</li><li>:only-of-type</li><li>::selection     选择被用户选取的元素部分</li><li>:first-line     选择元素中的第一行</li><li>:first-letter   选择元素中的第一个字符</li></ul><p><strong>请列举几种隐藏元素的方法</strong></p><ul><li>visibility: hidden;   这个属性只是简单的隐藏某个元素，但是元素占用的空间任然存在</li><li>opacity: 0;           CSS3属性，设置0可以使一个元素完全透明</li><li>position: absolute;   设置一个很大的 left 负值定位，使元素定位在可见区域之外</li><li>display: none;        元素会变得不可见，并且不会再占用文档的空间。</li><li>transform: scale(0);  将一个元素设置为缩放无限小，元素将不可见，元素原来所在的位置将被保留</li><li><code>&lt;div hidden=&quot;hidden&quot;&gt;</code> HTML5属性,效果和display:none;相同，但这个属性用于记录一个元素的状态</li><li>height: 0;            将元素高度设为 0 ，并消除边框</li><li>filter: blur(0);      CSS3属性，将一个元素的模糊度设置为0，从而使这个元素“消失”在页面中</li></ul><p><strong>rgba() 和 opacity 的透明效果有什么不同？</strong></p><ul><li>opacity 作用于元素以及元素内的所有内容（包括文字）的透明度</li><li>rgba() 只作用于元素自身的颜色或其背景色，子元素不会继承透明效果</li></ul><p><strong>css 属性 content 有什么作用？</strong></p><ul><li>content 属性专门应用在 before/after 伪元素上，用于插入额外内容或样式</li></ul><p><strong>CSS3有哪些新特性？</strong></p><ul><li>新增选择器     p:nth-child(n){color: rgba(255, 0, 0, 0.75)}</li><li>弹性盒模型     display: flex;</li><li>多列布局       column-count: 5;</li><li>媒体查询       @media (max-width: 480px) {.box: {column-count: 1;}}</li><li>个性化字体     @font-face{font-family: BorderWeb; src:url(BORDERW0.eot);}</li><li>颜色透明度     color: rgba(255, 0, 0, 0.75);</li><li>圆角           border-radius: 5px;</li><li>渐变           background:linear-gradient(red, green, blue);</li><li>阴影           box-shadow:3px 3px 3px rgba(0, 64, 128, 0.3);</li><li>倒影           box-reflect: below 2px;</li><li>文字装饰       text-stroke-color: red;</li><li>文字溢出       text-overflow:ellipsis;</li><li>背景效果       background-size: 100px 100px;</li><li>边框效果       border-image:url(bt_blue.png) 0 10;</li><li>转换<ul><li>旋转          transform: rotate(20deg);</li><li>倾斜          transform: skew(150deg, -10deg);</li><li>位移          transform: translate(20px, 20px);</li><li>缩放          transform: scale(.5);</li></ul></li><li>平滑过渡       transition: all .3s ease-in .1s;</li><li>动画           @keyframes anim-1 {50% {border-radius: 50%;}} animation: anim-1 1s;</li></ul><p><strong>请解释一下 CSS3 的 Flexbox（弹性盒布局模型）以及适用场景？</strong></p><ul><li>Flexbox 用于不同尺寸屏幕中创建可自动扩展和收缩布局</li></ul><p><strong>经常遇到的浏览器的JS兼容性有哪些？解决方法是什么？</strong></p><ul><li>当前样式：getComputedStyle(el, null) VS el.currentStyle</li><li>事件对象：e VS window.event</li><li>鼠标坐标：e.pageX, e.pageY VS window.event.x, window.event.y</li><li>按键码：e.which VS event.keyCode</li><li>文本节点：el.textContent VS el.innerText</li></ul><p><strong>li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？</strong></p><ul><li>li排列受到中间空白(回车/空格)等的影响，因为空白也属于字符，会被应用样式占据空间，产生间隔</li><li>解决办法：在ul设置设置font-size=0,在li上设置需要的文字大小</li></ul><p><strong>什么是外边距重叠？ 重叠的结果是什么？</strong></p><ul><li>外边距重叠就是 margin-collapse</li><li>相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。<br>这种合并外边距的方式被称为折叠，结合而成的外边距称为折叠外边距</li><li>折叠结果遵循下列计算规则：<ul><li>两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值</li><li>两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值</li><li>两个外边距一正一负时，折叠结果是两者的相加的和</li></ul></li></ul><p><strong>请写出多种等高布局</strong></p><ul><li>在列的父元素上使用这个背景图进行Y轴的铺放，从而实现一种等高列的假像</li><li>模仿表格布局等高列效果：兼容性不好，在ie6-7无法正常运行</li><li>css3 flexbox 布局： .container{display: flex; align-items: stretch;}</li></ul><p><strong>css垂直居中的方法有哪些？</strong></p><ul><li>如果是单行文本, line-height 设置成和 height 值</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.vertical &#123;</span><br><span class="line">      height: 100px;</span><br><span class="line">      line-height: 100px;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>已知高度的块级子元素，采用绝对定位和负边距</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.vertical &#123;</span><br><span class="line">  height: 300px;  &#x2F;*子元素高度*&#x2F;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top:50%;  &#x2F;*父元素高度50%*&#x2F;</span><br><span class="line">  margin-top: -150px; &#x2F;*自身高度一半*&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>未知高度的块级父子元素居中，模拟表格布局</li><li>缺点：IE67不兼容，父级 overflow：hidden 失效</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">      display: table;</span><br><span class="line">    &#125;</span><br><span class="line">    .content &#123;</span><br><span class="line">      display: table-cell;</span><br><span class="line">      vertical-align: middle;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>新增 inline-block 兄弟元素，设置 vertical-align<ul><li>缺点：需要增加额外标签，IE67不兼容</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  height: 100%;&#x2F;*定义父级高度，作为参考*&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">.extra .vertical&#123;</span><br><span class="line">  display: inline-block;  &#x2F;*行内块显示*&#x2F;</span><br><span class="line">  vertical-align: middle; &#x2F;*垂直居中*&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">.extra &#123;</span><br><span class="line">  height: 100%; &#x2F;*设置新增元素高度为100%*&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>绝对定位配合 CSS3 位移</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.vertical &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top:50%;  &#x2F;*父元素高度50%*&#x2F;</span><br><span class="line">  transform:translateY(-50%, -50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>CSS3弹性盒模型</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  display:flex;</span><br><span class="line">  justify-content: center; &#x2F;*子元素水平居中*&#x2F;</span><br><span class="line">  align-items: center; &#x2F;*子元素垂直居中*&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>圣杯布局的实现原理？</strong></p><ul><li>要求：三列布局；中间主体内容前置，且宽度自适应；两边内容定宽<ul><li>好处：重要的内容放在文档流前面可以优先渲染</li><li>原理：利用相对定位、浮动、负边距布局，而不添加额外标签</li></ul></li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">padding-right</span>: <span class="number">190px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">190px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">left</span>: -<span class="number">150px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">190px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">190px</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">right</span>: -<span class="number">190px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>什么是双飞翼布局？实现原理？</strong></p><ul><li>双飞翼布局：对圣杯布局（使用相对定位，对以后布局有局限性）的改进，消除相对定位布局</li><li>原理：主体元素上设置左右边距，预留两翼位置。左右两栏使用浮动和负边距归位，消除相对定位。</li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="comment">/*padding-left:150px;*/</span></span><br><span class="line">    <span class="comment">/*padding-right:190px;*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.main-wrap</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">190px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line">    <span class="comment">/*position: relative;*/</span></span><br><span class="line">    <span class="comment">/*left:-150px;*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">190px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">190px</span>;</span><br><span class="line">    <span class="comment">/*position:relative;*/</span></span><br><span class="line">    <span class="comment">/*right:-190px;*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在CSS样式中常使用 px、em 在表现上有什么区别？</strong></p><ul><li>px 相对于显示器屏幕分辨率，无法用浏览器字体放大功能</li><li>em 值并不是固定的，会继承父级的字体大小： em = 像素值 / 父级font-size</li></ul><p><strong>为什么要初始化CSS样式？</strong></p><ul><li>不同浏览器对有些标签样式的默认值解析不同</li><li>不初始化CSS会造成各现浏览器之间的页面显示差异</li><li>可以使用 reset.css 或 Normalize.css 做 CSS 初始化</li></ul><p><strong>解释下什么是浮动和它的工作原理？</strong></p><ul><li>非IE浏览器下，容器不设高度且子元素浮动时，容器高度不能被内容撑开。<br>此时，内容会溢出到容器外面而影响布局。这种现象被称为浮动（溢出）。</li><li>工作原理：<ul><li>浮动元素脱离文档流，不占据空间（引起“高度塌陷”现象）</li><li>浮动元素碰到包含它的边框或者其他浮动元素的边框停留</li></ul></li></ul><p><strong>浮动元素引起的问题？</strong></p><ul><li>父元素的高度无法被撑开，影响与父元素同级的元素</li><li>与浮动元素同级的非浮动元素会跟随其后</li></ul><p><strong>列举几种清除浮动的方式？</strong></p><ul><li>添加额外标签，例如 <code>&lt;div style=&quot;clear:both&quot;&gt;&lt;/div&gt;</code></li><li>使用 br 标签和其自身的 clear 属性，例如 <code>&lt;br clear=&quot;all&quot; /&gt;</code></li><li>父元素设置 overflow：hidden; 在IE6中还需要触发 hasLayout，例如zoom：1;</li><li>父元素也设置浮动</li><li>使用 :after 伪元素。由于IE6-7不支持 :after，使用 zoom:1 触发 hasLayout</li></ul><p><strong>清除浮动最佳实践（after伪元素闭合浮动）：</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.clearfix:after&#123;</span><br><span class="line">    content: &quot;\200B&quot;;</span><br><span class="line">    display: table; </span><br><span class="line">    height: 0;</span><br><span class="line">    clear: both;</span><br><span class="line">  &#125;</span><br><span class="line">  .clearfix&#123;</span><br><span class="line">    *zoom: 1;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>  <strong>什么是 FOUC(Flash of Unstyled Content)？ 如何来避免 FOUC？</strong></p><ul><li>当使用 @import 导入 CSS 时，会导致某些页面在 IE 出现奇怪的现象：<br>没有样式的页面内容显示瞬间闪烁，这种现象称为“文档样式短暂失效”，简称为FOUC</li><li>产生原因：当样式表晚于结构性html加载时，加载到此样式表时，页面将停止之前的渲染。</li><li>等待此样式表被下载和解析后，再重新渲染页面，期间导致短暂的花屏现象。</li><li>解决方法：使用 link 标签将样式表放在文档 head</li></ul><p><strong>介绍使用过的 CSS 预处理器？</strong></p><ul><li>CSS 预处理器基本思想：为 CSS 增加了一些编程的特性（变量、逻辑判断、函数等）</li><li>开发者使用这种语言进行进行 Web 页面样式设计，再编译成正常的 CSS 文件使用</li><li>使用 CSS 预处理器，可以使 CSS 更加简洁、适应性更强、可读性更佳，无需考虑兼容性</li><li>最常用的 CSS 预处理器语言包括：Sass（SCSS）和 LESS</li></ul><p><strong>CSS优化、提高性能的方法有哪些？</strong></p><ul><li>多个css合并，尽量减少HTTP请求</li><li>将css文件放在页面最上面</li><li>移除空的css规则</li><li>避免使用CSS表达式</li><li>选择器优化嵌套，尽量避免层级过深</li><li>充分利用css继承属性，减少代码量</li><li>抽象提取公共样式，减少代码量</li><li>属性值为0时，不加单位</li><li>属性值为小于1的小数时，省略小数点前面的0</li><li>css雪碧图</li></ul><p><strong>浏览器是怎样解析CSS选择器的？</strong></p><ul><li>浏览器解析 CSS 选择器的方式是从右到左</li></ul><p><strong>在网页中的应该使用奇数还是偶数的字体？</strong></p><ul><li>在网页中的应该使用“偶数”字体：<ul><li>偶数字号相对更容易和 web 设计的其他部分构成比例关系</li><li>使用奇数号字体时文本段落无法对齐</li><li>宋体的中文网页排布中使用最多的就是 12 和 14</li></ul></li></ul><p><strong>margin和padding分别适合什么场景使用？</strong></p><ul><li>需要在border外侧添加空白，且空白处不需要背景（色）时，使用 margin</li><li>需要在border内测添加空白，且空白处需要背景（色）时，使用 padding</li></ul><p><strong>抽离样式模块怎么写，说出思路？</strong></p><ul><li>CSS可以拆分成2部分：公共CSS 和 业务CSS：<ul><li>网站的配色，字体，交互提取出为公共CSS。这部分CSS命名不应涉及具体的业务</li><li>对于业务CSS，需要有统一的命名，使用公用的前缀。可以参考面向对象的CSS</li></ul></li></ul><p><strong>元素竖向的百分比设定是相对于容器的高度吗？</strong></p><ul><li>元素竖向的百分比设定是相对于容器的宽度，而不是高度</li></ul><p><strong>全屏滚动的原理是什么？ 用到了CSS的那些属性？</strong></p><ul><li>原理类似图片轮播原理，超出隐藏部分，滚动时显示</li><li>可能用到的CSS属性：overflow:hidden; transform:translate(100%, 100%); display:none;</li></ul><p><strong>什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？</strong></p><ul><li>响应式设计就是网站能够兼容多个终端，而不是为每个终端做一个特定的版本</li><li>基本原理是利用CSS3媒体查询，为不同尺寸的设备适配不同样式</li><li>对于低版本的IE，可采用JS获取屏幕宽度，然后通过resize方法来实现兼容：</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="built_in">window</span>).resize(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  screenRespond();</span><br><span class="line">&#125;);</span><br><span class="line">screenRespond();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">screenRespond</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> screenWidth = $(<span class="built_in">window</span>).width();</span><br><span class="line"><span class="keyword">if</span>(screenWidth &lt;= <span class="number">1800</span>)&#123;</span><br><span class="line">  $(<span class="string">"body"</span>).attr(<span class="string">"class"</span>, <span class="string">"w1800"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(screenWidth &lt;= <span class="number">1400</span>)&#123;</span><br><span class="line">  $(<span class="string">"body"</span>).attr(<span class="string">"class"</span>, <span class="string">"w1400"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(screenWidth &gt; <span class="number">1800</span>)&#123;</span><br><span class="line">  $(<span class="string">"body"</span>).attr(<span class="string">"class"</span>, <span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>什么是视差滚动效果，如何给每页做不同的动画？</strong></p><ul><li>视差滚动是指多层背景以不同的速度移动，形成立体的运动效果，具有非常出色的视觉体验</li><li>一般把网页解剖为：背景层、内容层和悬浮层。当滚动鼠标滚轮时，各图层以不同速度移动，形成视差的</li><li>实现原理<ul><li>以 “页面滚动条” 作为 “视差动画进度条”</li><li>以 “滚轮刻度” 当作 “动画帧度” 去播放动画的</li><li>监听 mousewheel 事件，事件被触发即播放动画，实现“翻页”效果</li></ul></li></ul><p><strong>a标签上四个伪类的执行顺序是怎么样的？</strong></p><figure class="highlight plain"><figcaption><span>> visited > hover > active```</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- L-V-H-A love hate 用喜欢和讨厌两个词来方便记忆</span><br><span class="line"></span><br><span class="line">**伪元素和伪类的区别和作用？**</span><br><span class="line"></span><br><span class="line">- 伪元素 -- 在内容元素的前后插入额外的元素或样式，但是这些元素实际上并不在文档中生成。</span><br><span class="line">- 它们只在外部显示可见，但不会在文档的源代码中找到它们，因此，称为“伪”元素。例如：</span><br></pre></td></tr></table></figure><p>p::before {content:”第一章：”;}<br>p::after {content:”Hot!”;}<br>p::first-line {background:red;}<br>p::first-letter {font-size:30px;}</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 伪类 -- 将特殊的效果添加到特定选择器上。它是已有元素上添加类别的，不会产生新的元素。例如：</span><br></pre></td></tr></table></figure><p>a:hover {color: #FF00FF}<br>p:first-child {color: red}</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">**::before 和 :after 中双冒号和单冒号有什么区别？**</span><br><span class="line"></span><br><span class="line">- 在 CSS 中伪类一直用 : 表示，如 :hover, :active 等</span><br><span class="line">- 伪元素在CSS1中已存在，当时语法是用 : 表示，如 :before 和 :after</span><br><span class="line">- 后来在CSS3中修订，伪元素用 :: 表示，如 ::before 和 ::after，以此区分伪元素和伪类</span><br><span class="line">- 由于低版本IE对双冒号不兼容，开发者为了兼容性各浏览器，继续使使用 :after 这种老语法表示伪元素</span><br><span class="line">- 综上所述：::before 是 CSS3 中写伪元素的新语法； :after 是 CSS1 中存在的、兼容IE的老语法</span><br><span class="line"></span><br><span class="line">**如何修改Chrome记住密码后自动填充表单的黄色背景？**</span><br><span class="line"></span><br><span class="line">- 产生原因：由于Chrome默认会给自动填充的input表单加上 input:-webkit-autofill 私有属性造成的</span><br><span class="line">- 解决方案1：在form标签上直接关闭了表单的自动填充：autocomplete&#x3D;&quot;off&quot;</span><br><span class="line">- 解决方案2：input:-webkit-autofill &#123; background-color: transparent; &#125;</span><br><span class="line"></span><br><span class="line">**input [type&#x3D;search] 搜索框右侧小图标如何美化？**</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;css</span><br><span class="line">input[type&#x3D;&quot;search&quot;]::-webkit-search-cancel-button&#123;</span><br><span class="line">  -webkit-appearance: none;</span><br><span class="line">  height: 15px;</span><br><span class="line">  width: 15px;</span><br><span class="line">  border-radius: 8px;</span><br><span class="line">  background:url(&quot;images&#x2F;searchicon.png&quot;) no-repeat 0 0;</span><br><span class="line">  background-size: 15px 15px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>网站图片文件，如何点击下载？而非点击预览？</strong></p><p><code>&lt;a href=&quot;logo.jpg&quot; download&gt;下载&lt;/a&gt;</code><br><code>&lt;a href=&quot;logo.jpg&quot; download=&quot;网站LOGO&quot; &gt;下载&lt;/a&gt;</code></p><p><strong>iOS safari 如何阻止“橡皮筋效果”？</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> stopScrolling = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">        event.preventDefault();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">'touchstart'</span>, stopScrolling, <span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">'touchmove'</span>, stopScrolling, <span class="literal">false</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>你对 line-height 是如何理解的？</strong></p><ul><li>line-height 指一行字的高度，包含了字间距，实际上是下一行基线到上一行基线距离</li><li>如果一个标签没有定义 height 属性，那么其最终表现的高度是由 line-height 决定的</li><li>一个容器没有设置高度，那么撑开容器高度的是 line-height 而不是容器内的文字内容</li><li>把 line-height 值设置为 height 一样大小的值可以实现单行文字的垂直居中</li><li>line-height 和 height 都能撑开一个高度，height 会触发 haslayout，而 line-height 不会</li></ul><p><strong>line-height 三种赋值方式有何区别？（带单位、纯数字、百分比）</strong></p><ul><li>带单位：px 是固定值，而 em 会参考父元素 font-size 值计算自身的行高</li><li>纯数字：会把比例传递给后代。例如，父级行高为 1.5，子元素字体为 18px，则子元素行高为 1.5 * 18 = 27px</li><li>百分比：将计算后的值传递给后代</li></ul><p><strong>设置元素浮动后，该元素的 display 值会如何变化？</strong></p><ul><li>设置元素浮动后，该元素的 display 值自动变成 block</li></ul><p><strong>怎么让Chrome支持小于12px 的文字？</strong></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.shrink</span>&#123;</span><br><span class="line">  <span class="attribute">-webkit-transform</span>:<span class="built_in">scale</span>(<span class="number">0.8</span>);</span><br><span class="line">  <span class="attribute">-o-transform</span>:<span class="built_in">scale</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="attribute">display</span>:inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>让页面里的字体变清晰，变细用CSS怎么做？（IOS手机浏览器字体齿轮设置）</strong></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">-webkit-font-smoothing</span>: <span class="selector-tag">antialiased</span>;</span><br></pre></td></tr></table></figure><p><strong>font-style 属性 oblique 是什么意思？</strong></p><ul><li>font-style: oblique; 使没有 italic 属性的文字实现倾斜</li></ul><p><strong>如果需要手动写动画，你认为最小时间间隔是多久？</strong></p><ul><li>16.7ms 多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔: 1s / 60 * 1000 ＝ 16.7ms</li></ul><p><strong>display:inline-block 什么时候会显示间隙？</strong></p><ul><li>相邻的 inline-block 元素之间有换行或空格分隔的情况下会产生间距</li><li>非 inline-block 水平元素设置为 inline-block 也会有水平间距</li><li>可以借助 vertical-align:top; 消除垂直间隙</li><li>可以在父级加 font-size：0; 在子元素里设置需要的字体大小，消除垂直间隙</li><li>把 li 标签写到同一行可以消除垂直间隙，但代码可读性差</li></ul><p><strong>overflow: scroll 时不能平滑滚动的问题怎么处理？</strong></p><ul><li>监听滚轮事件，然后滚动到一定距离时用 jquery 的 animate 实现平滑效果。</li></ul><p><strong>一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度</strong></p><ul><li>方案1：<br><code>.sub { height: calc(100%-100px); }</code></li><li>方案2：<br><code>.container { position:relative; }</code><br><code>.sub { position: absolute; top: 100px; bottom: 0; }</code></li><li>方案3：<br><code>.container { display:flex; flex-direction:column; }</code><br><code>.sub { flex:1; }</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 小知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Node基础</title>
      <link href="/2017/07/12/Node%E5%9F%BA%E7%A1%80/"/>
      <url>/2017/07/12/Node%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h5 id="Node基础"><a href="#Node基础" class="headerlink" title="Node基础"></a>Node基础</h5><p>资料整理</p><a id="more"></a><h2 id="Node-js面试题列表"><a href="#Node-js面试题列表" class="headerlink" title="Node.js面试题列表"></a>Node.js面试题列表</h2><ul><li>什么是错误优先的回调函数？</li><li>如何避免回调地狱？</li><li>如何用Node来监听80端口？</li><li>什么是事件循环？</li><li>哪些工具可以用来保证一致的编程风格？</li><li>运算错误与程序员错误的区别？</li><li>使用NPM有哪些好处？</li><li>什么是stub？举个使用场景？</li><li>什么是测试金字塔？对于HTTP API，如何利用测试金字塔？</li><li>你最喜欢的HTTP框架，并说明原因？</li></ul><p>现在，我们依次来解答这些问题吧。</p><h3 id="什么是错误优先的回调函数？"><a href="#什么是错误优先的回调函数？" class="headerlink" title="什么是错误优先的回调函数？"></a>什么是错误优先的回调函数？</h3><p>错误优先的回调函数用于传递错误和数据。第一个参数始终应该是一个错误对象，<br>用于检查程序是否发生了错误。其余的参数用于传递数据。例如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fs.readFile(filePath, function(err, data) &#123;  </span><br><span class="line">if (err) &#123;</span><br><span class="line">&#x2F;&#x2F;handle the error</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; use the data object</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>解析：</strong>这个题目的主要作用在于检查被面试者对于Node中异步操作的一些基本知识的掌握。</p><h3 id="如何避免回调地狱"><a href="#如何避免回调地狱" class="headerlink" title="如何避免回调地狱"></a>如何避免回调地狱</h3><p>你可以有如下几个方法：</p><ul><li>模块化：将回调函数分割为独立的函数</li><li>使用Promises</li><li>使用<code>yield</code>来计算生成器或Promise</li></ul><p><strong>解析：</strong>这个问题有很多种答案，取决你使用的场景，例如ES6, ES7，或者一些控制流库。</p><h3 id="如何用Node监听80端口"><a href="#如何用Node监听80端口" class="headerlink" title="如何用Node监听80端口"></a>如何用Node监听80端口</h3><p>这题有陷阱！在类Unix系统中你不应该尝试去监听80端口，因为这需要超级用户权限。<br>因此不推荐让你的应用直接监听这个端口。</p><p>目前，如果你一定要让你的应用监听80端口的话，你可以有通过在Node应用的前方再增加一层反向代理<br>（例如<a href="http://nginx.org/" target="_blank" rel="noopener">nginx</a>）来实现，如下图所示。否则，建议你直接监听大于1024的端口。</p><blockquote><p>方向代理指的是以代理服务器来接收Internet上的连接请求，然后将请求转发给内部网络上的服务器，<br>并且将服务器返回的结果发送给客户端。</p></blockquote><p>关于反向代理的更多内容，建议你阅读<a href="http://www.cnblogs.com/edisonchou/p/4126742.html" target="_blank" rel="noopener">这篇文章</a>。<br>关于如何利用nginx来为node配置方向代理的实践，可以参考<a href="https://www.digitalocean.com/community/tutorials/how-to-set-up-a-node-js-application-for-production-on-ubuntu-14-04" target="_blank" rel="noopener">这篇博文</a>。</p><p><strong>解释：</strong>这个问题用于检查被面试者是否有实际运行Node应用的经验。</p><h3 id="什么是事件循环"><a href="#什么是事件循环" class="headerlink" title="什么是事件循环"></a>什么是事件循环</h3><p>Node采用的是单线程的处理机制（所有的I/O请求都采用非阻塞的工作方式），至少从Node.js开发者的角度是这样的。<br>而在底层，Node.js借助<a href="https://github.com/libuv/libuv" target="_blank" rel="noopener">libuv</a>来作为抽象封装层，<br>从而屏蔽不同操作系统的差异，Node可以借助livuv来来实现多线程。下图表示了Node和libuv的关系。</p><p>!</p><p>Libuv库负责Node API的执行。它将不同的任务分配给不同的线程，形成一个事件循环，<br>以异步的方式将任务的执行结果返回给V8引擎。</p><p>每一个I/O都需要一个回调函数——一旦执行完便推到事件循环上用于执行。<br>如果你需要更多详细的解释，可以参考<a href="https://www.youtube.com/embed/8aGhZQkoFbQ" target="_blank" rel="noopener">这个视频</a>。<br>你也可以参考<a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="noopener">这篇文章</a>。</p><p><strong>解释：</strong>这用于检查Node.js的底层知识，例如什么是libuv，它的作用是什么。</p><h3 id="哪些工具可以用来保证一致性的代码风格"><a href="#哪些工具可以用来保证一致性的代码风格" class="headerlink" title="哪些工具可以用来保证一致性的代码风格"></a>哪些工具可以用来保证一致性的代码风格</h3><p>你可以选择如下的工具：</p><ul><li><a href="http://jslint.com/" target="_blank" rel="noopener">JSLint</a></li><li><a href="http://jshint.com/" target="_blank" rel="noopener">JSHint</a></li><li><a href="http://eslint.org/" target="_blank" rel="noopener">ESLint</a></li><li><a href="http://jscs.info/" target="_blank" rel="noopener">JSCS</a> - 推荐</li></ul><p>在团队开发中，这些工具对于编写代码非常的有帮助，能够帮助团队开发者强制执行规定的风格指南，<br>还能够通过静态分析捕获常见的错误。</p><p><strong>解析：</strong>用于检查被面试者是否有大型项目开发经验。</p><h3 id="运算错误与程序员错误的区别"><a href="#运算错误与程序员错误的区别" class="headerlink" title="运算错误与程序员错误的区别"></a>运算错误与程序员错误的区别</h3><p>运算错误并不是bug，这是和系统相关的问题，例如请求超时或者硬件故障。而程序员错误就是所谓的bug。</p><p><strong>解析：</strong>这个题目和Node关系并不大，用于考察面试者的基础知识。</p><h3 id="使用NPM有哪些好处？"><a href="#使用NPM有哪些好处？" class="headerlink" title="使用NPM有哪些好处？"></a>使用NPM有哪些好处？</h3><p>通过NPM，你可以安装和管理项目的依赖，并且能够指明依赖项的具体版本号。<br>对于Node应用开发而言，你可以通过<code>package.json</code>文件来管理项目信息，配置脚本，<br>以及指明项目依赖的具体版本。</p><p>关于NPM的更多信息，你可以参考<a href="https://docs.npmjs.com/files/package.json" target="_blank" rel="noopener">官方文档</a>。</p><p><strong>解析：</strong>它能考察面试者使用npm命令的基础知识和Node.js开发的实际经验。</p><h3 id="什么是Stub？举个使用场景"><a href="#什么是Stub？举个使用场景" class="headerlink" title="什么是Stub？举个使用场景"></a>什么是Stub？举个使用场景</h3><p>Stub是用于<strong>模拟</strong>一个组件或模块的函数或程序。在测试用例中，<br>简单的说，你可以用Stub去模拟一个方法，从而避免调用真实的方法，<br>使用Stub你还可以返回虚构的结果。你可以配合断言使用Stub。</p><p>举个例子，在一个读取文件的场景中，当你不想读取一个真正的文件时：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var fs &#x3D; require(&#39;fs&#39;);</span><br><span class="line"></span><br><span class="line">var readFileStub &#x3D; sinon.stub(fs, &#39;readFile&#39;, function (path, cb) &#123;  </span><br><span class="line">return cb(null, &#39;filecontent&#39;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">expect(readFileStub).to.be.called;  </span><br><span class="line">readFileStub.restore();</span><br></pre></td></tr></table></figure><blockquote><p>在单元测试中：Stub是完全模拟一个外部依赖，而Mock常用来判断测试通过还是失败。</p></blockquote><p>有关Node.js的单元测试小结，你可以参考<a href="http://segmentfault.com/a/1190000002921481" target="_blank" rel="noopener">这个链接</a>。</p><p><strong>解析：</strong>用于测试被面试者是否有测试的经验。如果被面试者知道什么是Stub，<br>那么可以继续问他是如何做单元测试的。</p><h3 id="什么是测试金字塔？"><a href="#什么是测试金字塔？" class="headerlink" title="什么是测试金字塔？"></a>什么是测试金字塔？</h3><p><a href="http://zyzhang.github.io/blog/2013/04/28/test-pyramid/" target="_blank" rel="noopener">测试金字塔</a>指的是：<br>当我们在编写测试用例时，底层的单元测试应该远比上层的端到端测试要多。</p><p>当我们谈到HTTP API时，我们可能会涉及到：</p><ul><li>有很多针对模型的底层单元测试</li><li>但你需要测试模型间如何交互时，需要减少集成测试</li></ul><p><strong>解析：</strong>本文主要考察被面试者的在测试方面的经验。</p><h3 id="你最喜欢的HTTP框架以及原因"><a href="#你最喜欢的HTTP框架以及原因" class="headerlink" title="你最喜欢的HTTP框架以及原因"></a>你最喜欢的HTTP框架以及原因</h3><p>这题没有唯一的答案。本题主要考察被面试者对于他所使用的Node框架的理解程度，<br>考察他是否能够给出选择该框架的理由，优缺点等。常用的HTTP框架你可以参考<a href="http://nodeframework.com/index.html" target="_blank" rel="noopener">这个网站</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 资料整理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>前端知识 - CSS BFC</title>
      <link href="/2017/07/11/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%20-%20CSS%20BFC/"/>
      <url>/2017/07/11/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%20-%20CSS%20BFC/</url>
      
        <content type="html"><![CDATA[<h5 id="前端知识-CSS-BFC"><a href="#前端知识-CSS-BFC" class="headerlink" title="前端知识 - CSS BFC"></a>前端知识 - CSS BFC</h5><p>资料整理</p><a id="more"></a><h2 id="谈一谈你对CSS盒模型的认识"><a href="#谈一谈你对CSS盒模型的认识" class="headerlink" title="谈一谈你对CSS盒模型的认识"></a>谈一谈你对CSS盒模型的认识</h2><blockquote><p>专业的面试，一定会问 <code>CSS</code> 盒模型。对于这个题目，我们要回答一下几个方面：</p></blockquote><ol><li>基本概念：<code>content</code>、<code>padding</code>、<code>margin</code></li><li>标准盒模型、<code>IE</code>盒模型的区别。不要漏说了<code>IE</code>盒模型，通过这个问题，可以筛选一部分人</li><li><code>CSS</code>如何设置这两种模型（即：如何设置某个盒子为其中一个模型）？如果回答了上面的第二条，还会继续追问这一条。</li><li><code>JS</code>如何设置、获取盒模型对应的宽和高？这一步，已经有很多人答不上来了。</li><li>实例题：根据盒模型解释<strong>边距重叠</strong>。</li></ol><blockquote><p>前四个方面是逐渐递增，第五个方面，却鲜有人知。</p></blockquote><ol start="6"><li><code>BFC</code>（边距重叠解决方案）或<code>IFC</code>。</li></ol><blockquote><p>如果能回答第五条，就会引出第六条。<code>BFC</code>是面试频率较高的。</p></blockquote><p><strong>总结</strong>：以上几点，从上到下，知识点逐渐递增，知识面从理论、<code>CSS</code>、<code>JS</code>，又回到<code>CSS</code>理论</p><p>接下来，我们把上面的六条，依次讲解。</p><p><strong>标准盒模型和IE盒子模型</strong></p><p>标准盒子模型：</p><p><img src="http://img.smyhvae.com/2015-10-03-css-27.jpg" alt=""></p><p><code>IE</code>盒子模型：</p><p><img src="http://img.smyhvae.com/2015-10-03-css-30.jpg" alt=""></p><p>上图显示：</p><blockquote><p>在 <code>CSS</code> 盒子模型 (<code>Box Model</code>) 规定了元素处理元素的几种方式：</p></blockquote><ul><li><code>width</code>和<code>height</code>：<strong>内容</strong>的宽度、高度（不是盒子的宽度、高度）。</li><li><code>padding</code>：内边距。</li><li><code>border</code>：边框。</li><li><code>margin</code>：外边距。</li></ul><blockquote><p><code>CSS</code>盒模型和<code>IE</code>盒模型的区别：</p></blockquote><ul><li>在<strong>标准盒子模型</strong>中，<strong>width 和 height 指的是内容区域</strong>的宽度和高度。增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的总尺寸。</li><li><strong>IE盒子模型</strong>中，<strong>width 和 height 指的是内容区域+border+padding</strong>的宽度和高度。</li></ul><p><strong>CSS如何设置这两种模型</strong></p><p>代码如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 设置当前盒子为 标准盒模型（默认） */</span></span><br><span class="line">box-sizing: content-box;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置当前盒子为 IE盒模型 */</span></span><br><span class="line">box-sizing: border-box;</span><br></pre></td></tr></table></figure><blockquote><p>备注：盒子默认为标准盒模型。</p></blockquote><p><strong>JS如何设置、获取盒模型对应的宽和高</strong></p><blockquote><p>方式一：通过<code>DOM</code>节点的 <code>style</code> 样式获取</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">element.style.width/height;</span><br></pre></td></tr></table></figure><blockquote><p>缺点：通过这种方式，只能获取<strong>行内样式</strong>，不能获取<code>内嵌</code>的样式和<code>外链</code>的样式。</p></blockquote><p>这种方式有局限性，但应该了解。</p><blockquote><p>方式二（通用型）</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.getComputedStyle(element).width/height;</span><br></pre></td></tr></table></figure><blockquote><p>方式二能兼容 <code>Chrome</code>、火狐。是通用型方式。</p></blockquote><blockquote><p>方式三（IE独有的）</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">element.currentStyle.width/height;</span><br></pre></td></tr></table></figure><blockquote><p>和方式二相同，但这种方式只有IE独有。获取到的即时运行完之后的宽高（三种css样式都可以获取）。</p></blockquote><blockquote><p>方式四</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">element.getBoundingClientRect().width/height;</span><br></pre></td></tr></table></figure><blockquote><p>此 <code>api</code> 的作用是：获取一个元素的绝对位置。绝对位置是视窗 <code>viewport</code> 左上角的绝对位置。此 <code>api</code> 可以拿到四个属性：<code>left</code>、<code>top</code>、<code>width</code>、<code>height</code>。</p></blockquote><p><strong>总结：</strong></p><blockquote><p>上面的四种方式，要求能说出来区别，以及哪个的通用型更强。</p></blockquote><p><strong>margin塌陷/margin重叠</strong></p><p><strong>标准文档流中，竖直方向的margin不叠加，只取较大的值作为margin</strong>(水平方向的<code>margin</code>是可以叠加的，即水平方向没有塌陷现象)。</p><blockquote><p>PS：如果不在标准流，比如盒子都浮动了，那么两个盒子之间是没有<code>margin</code>重叠的现象的。</p></blockquote><blockquote><p>我们来看几个例子。</p></blockquote><p><strong>兄弟元素之间</strong></p><p>如下图所示：</p><p><img src="http://img.smyhvae.com/20170805_0904.png" alt=""></p><p><strong>子元素和父元素之间</strong></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        * &#123;</span><br><span class="line">            margin: 0;</span><br><span class="line">            padding: 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.father</span> &#123;</span></span><br><span class="line">            background: green;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="comment">/* 给儿子设置margin-top为10像素 */</span></span></span><br><span class="line"><span class="css">        <span class="selector-class">.son</span> &#123;</span></span><br><span class="line">            height: 100px;</span><br><span class="line">            margin-top: 10px;</span><br><span class="line">            background: red;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"father"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"son"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>上面的代码中，儿子的<code>height</code>是 <code>100p</code>x，<code>magin-top</code> 是<code>10px</code>。注意，此时父亲的 <code>height</code> 是<code>100</code>，而不是<code>110</code>。因为儿子和父亲在竖直方向上，共一个<code>margin</code>。</p></blockquote><p>儿子这个盒子：</p><p><img src="http://img.smyhvae.com/20180305_2216.png" alt=""></p><p>父亲这个盒子：</p><p><img src="http://img.smyhvae.com/20180305_2217.png" alt=""></p><blockquote><p>上方代码中，如果我们给父亲设置一个属性：<code>overflow: hidden</code>，就可以避免这个问题，此时父亲的高度是110px，这个用到的就是BFC（下一段讲解）。</p></blockquote><p><strong>善于使用父亲的padding，而不是儿子的margin</strong></p><blockquote><p>其实，这一小段讲的内容与上一小段相同，都是讲父子之间的margin重叠。</p></blockquote><p>我们来看一个奇怪的现象。现在有下面这样一个结构：（<code>div</code>中放一个<code>p</code>）</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>上面的结构中，我们尝试通过给儿子<code>p</code>一个<code>margin-top:50px;</code>的属性，让其与父亲保持50px的上边距。结果却看到了下面的奇怪的现象：</p></blockquote><p><img src="http://img.smyhvae.com/20170806_1537.png" alt=""></p><blockquote><p>此时我们给父亲<code>div</code>加一个<code>border</code>属性，就正常了：</p></blockquote><p><img src="http://img.smyhvae.com/20170806_1544.png" alt=""></p><blockquote><p>如果父亲没有<code>border</code>，那么儿子的<code>margin</code>实际上踹的是“流”，踹的是这“行”。所以，父亲整体也掉下来了。</p></blockquote><p><strong>margin这个属性，本质上描述的是兄弟和兄弟之间的距离； 最好不要用这个marign表达父子之间的距离。</strong></p><blockquote><p>所以，如果要表达父子之间的距离，我们一定要善于使用父亲的padding，而不是儿子的`margin。</p></blockquote><p><strong>BFC（边距重叠解决方案）</strong></p><blockquote><p><code>BFC（Block Formatting Context）</code>：块级格式化上下文。你可以把它理解成一个独立的区域。</p></blockquote><p>另外还有个概念叫<code>IFC</code>。不过，<code>BFC</code>问得更多。</p><p><strong>BFC 的原理/BFC的布局规则【非常重要】</strong></p><blockquote><p><code>BFC</code> 的原理，其实也就是 <code>BFC</code> 的渲染规则（能说出以下四点就够了）。包括：</p></blockquote><ol><li>BFC <strong>内部的</strong>子元素，在垂直方向，<strong>边距会发生重叠</strong>。</li><li>BFC在页面中是独立的容器，外面的元素不会影响里面的元素，反之亦然。（稍后看<code>举例1</code>）</li><li><strong>BFC区域不与旁边的<code>float box</code>区域重叠</strong>。（可以用来清除浮动带来的影响）。（稍后看<code>举例2</code>）</li><li>计算<code>BFC</code>的高度时，浮动的子元素也参与计算。（稍后看<code>举例3</code>）</li></ol><p><strong>如何生成BFC</strong></p><blockquote><p>有以下几种方法：</p></blockquote><ul><li>方法1：<code>overflow</code>: 不为<code>visible</code>，可以让属性是 <code>hidden</code>、<code>auto</code>。【最常用】</li><li>方法2：浮动中：<code>float</code>的属性值不为<code>none</code>。意思是，只要设置了浮动，当前元素就创建了<code>BFC</code>。</li><li>方法3：定位中：只要<code>posiiton</code>的值不是 s<code>tatic</code>或者是<code>relative</code>即可，可以是<code>absolute</code>或<code>fixed</code>，也就生成了一个<code>BFC</code>。</li><li>方法4：<code>display</code>为<code>inline-block</code>, <code>table-cell</code>, <code>table-caption</code>, <code>flex</code>, <code>inline-flex</code></li></ul><p><strong>BFC 的应用</strong></p><p><strong>举例1：</strong>解决 margin 重叠</p><blockquote><p>当父元素和子元素发生 <code>margin</code> 重叠时，解决办法：<strong>给子元素或父元素创建BFC</strong>。</p></blockquote><p>比如说，针对下面这样一个 <code>div</code> 结构：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"father"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"son"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>上面的<code>div</code>结构中，如果父元素和子元素发生<code>margin</code>重叠，我们可以给子元素创建一个 <code>BFC</code>，就解决了：</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"father"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"son"</span> <span class="attr">style</span>=<span class="string">"overflow: hidden"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>因为<strong>第二条：BFC区域是一个独立的区域，不会影响外面的元素</strong>。</p></blockquote><p><strong>举例2</strong>：BFC区域不与float区域重叠：</p><p>针对下面这样一个div结构；</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.father-layout</span> &#123;</span></span><br><span class="line">            background: pink;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.father-layout</span> <span class="selector-class">.left</span> &#123;</span></span><br><span class="line">            float: left;</span><br><span class="line">            width: 100px;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background: green;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.father-layout</span> <span class="selector-class">.right</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">height</span>: 150<span class="selector-tag">px</span>;  <span class="comment">/*右侧标准流里的元素，比左侧浮动的元素要高*/</span></span></span><br><span class="line">            background: red;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"father-layout"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span></span><br><span class="line">        左侧，生命壹号</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span></span><br><span class="line">        右侧，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="http://img.smyhvae.com/20180306_0825.png" alt=""></p><blockquote><p>上图中，由于右侧标准流里的元素，比左侧浮动的元素要高，导致右侧有一部分会跑到左边的下面去。</p></blockquote><p><strong>如果要解决这个问题，可以将右侧的元素创建BFC</strong>，因为<strong>第三条：BFC区域不与<code>float box</code>区域重叠</strong>。解决办法如下：（将right区域添加overflow属性）</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span> <span class="attr">style</span>=<span class="string">"overflow: hidden"</span>&gt;</span></span><br><span class="line">    右侧，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="http://img.smyhvae.com/20180306_0827.png" alt=""></p><p>上图表明，解决之后，<code>father-layout</code>的背景色显现出来了，说明问题解决了。</p><p><strong>举例3：</strong>清除浮动</p><p>现在有下面这样的结构：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.father</span> &#123;</span></span><br><span class="line">            background: pink;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-class">.son</span> &#123;</span></span><br><span class="line">            float: left;</span><br><span class="line">            background: green;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"father"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"son"</span>&gt;</span></span><br><span class="line">        生命壹号</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="http://img.smyhvae.com/20180306_0840.png" alt=""></p><p>上面的代码中，儿子浮动了，但由于父亲没有设置高度，导致看不到父亲的背景色（此时父亲的高度为0）。正所谓<strong>有高度的盒子，才能关住浮动</strong>。</p><blockquote><p>如果想要清除浮动带来的影响，方法一是给父亲设置高度，然后采用隔墙法。方法二是 BFC：给父亲增加 <code>overflow=hidden</code>属性即可， 增加之后，效果如下：</p></blockquote><p><img src="http://img.smyhvae.com/20180306_0845.png" alt=""></p><blockquote><p>为什么父元素成为BFC之后，就有了高度呢？这就回到了<strong>第四条：计算BFC的高度时，浮动元素也参与计算</strong>。意思是，<strong>在计算BFC的高度时，子元素的float box也会参与计算</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 小知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript知识 - 数据库区别</title>
      <link href="/2017/07/06/JavaScript%E7%9F%A5%E8%AF%86%20-%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8C%BA%E5%88%AB/"/>
      <url>/2017/07/06/JavaScript%E7%9F%A5%E8%AF%86%20-%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h5 id="JavaScript知识-数据库区别"><a href="#JavaScript知识-数据库区别" class="headerlink" title="JavaScript知识 - 数据库区别"></a>JavaScript知识 - 数据库区别</h5><p>JavaScript资料整理</p><a id="more"></a><p><strong>说说mongoDB和MySQL的区别</strong></p><ul><li><code>MySQL</code>是传统的关系型数据库，MongoDB则是非关系型数据库</li><li><code>mongodb</code>以BSON结构（二进制）进行存储，对海量数据存储有着很明显的优势。</li><li>对比传统关系型数据库,NoSQL有着非常显著的性能和扩展性优势，与关系型数据库相比，MongoDB的优点有： ①弱一致性（最终一致），更能保证用户的访问速度： ②文档结构的存储方式，能够更便捷的获取数据</li></ul>]]></content>
      
      
      <categories>
          
          <category> 小知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript知识 - 跨域</title>
      <link href="/2017/07/05/JavaScript%E7%9F%A5%E8%AF%86%20-%20%E8%B7%A8%E5%9F%9F/"/>
      <url>/2017/07/05/JavaScript%E7%9F%A5%E8%AF%86%20-%20%E8%B7%A8%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h5 id="JavaScript知识-跨域"><a href="#JavaScript知识-跨域" class="headerlink" title="JavaScript知识 - 跨域"></a>JavaScript知识 - 跨域</h5><p>JavaScript资料整理</p><a id="more"></a><h3 id="如何解决跨域问题"><a href="#如何解决跨域问题" class="headerlink" title="如何解决跨域问题"></a>如何解决跨域问题</h3><hr><p><strong>JSONP：</strong></p><ul><li>原理是：动态插入<code>script</code>标签，通过<code>script</code>标签引入一个<code>js</code>文件，这个<code>js</code>文件载入成功后会执行我们在<code>url</code>参数中指定的函数，并且会把我们需要的<code>json</code>数据作为参数传入</li><li>由于同源策略的限制，<code>XmlHttpRequest</code>只允许请求当前源（域名、协议、端口）的资源，为了实现跨域请求，可以通过<code>script</code>标签实现跨域请求，然后在服务端输出<code>JSON</code>数据并执行回调函数，从而解决了跨域的数据请求</li><li>优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请求</li><li><code>JSONP</code>：<code>json+padding</code>（内填充），顾名思义，就是把<code>JSON</code>填充到一个盒子里</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createJs</span>(<span class="params">sUrl</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> oScript = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">    oScript.type = <span class="string">'text/javascript'</span>;</span><br><span class="line">    oScript.src = sUrl;</span><br><span class="line">    <span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>].appendChild(oScript);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">createJs(<span class="string">'jsonp.js'</span>);</span><br><span class="line"></span><br><span class="line">box(&#123;</span><br><span class="line">   <span class="string">'name'</span>: <span class="string">'test'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">box</span>(<span class="params">json</span>)</span>&#123;</span><br><span class="line">    alert(json.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>CORS</strong></p><ul><li>服务器端对于<code>CORS</code>的支持，主要就是通过设置<code>Access-Control-Allow-Origin</code>来进行的。如果浏览器检测到相应的设置，就可以允许<code>Ajax</code>进行跨域的访问</li></ul><p><strong>通过修改document.domain来跨子域</strong></p><ul><li>将子域和主域的<code>document.domain</code>设为同一个主域.前提条件：这两个域名必须属于同一个基础域名!而且所用的协议，端口都要一致，否则无法利用<code>document.domain</code>进行跨域。主域相同的使用<code>document.domain</code></li></ul><p><strong>使用window.name来进行跨域</strong></p><ul><li><code>window</code>对象有个name属性，该属性有个特征：即在一个窗口(<code>window</code>)的生命周期内,窗口载入的所有的页面都是共享一个<code>window.name</code>的，每个页面对window.name都有读写的权限，<code>window.name</code>是持久存在一个窗口载入过的所有页面中的</li></ul><p><strong>使用HTML5中新引进的window.postMessage方法来跨域传送数据</strong></p><ul><li>还有<code>flash</code>、在服务器上设置代理页面等跨域方式。个人认为<code>window.name</code>的方法既不复杂，也能兼容到几乎所有浏览器，这真是极好的一种跨域方法</li></ul><p><strong>如何解决跨域问题?</strong></p><ul><li><code>jsonp</code>、 <code>iframe</code>、<code>window.name</code>、<code>window.postMessage</code>、服务器上设置代理页面</li><li>如何解决跨域问题?<ul><li><code>document.domain + iframe</code>：要求主域名相同 //只能跨子域</li><li><code>JSONP(JSON with Padding)``：</code>response: callback(data)`` //只支持 GET 请求</li><li>跨域资源共享<code>CORS(XHR2)``：</code>Access-Control-Allow` //兼容性 IE10+</li><li>跨文档消息传输(HTML5)：<code>postMessage + onmessage</code>  //兼容性 IE8+</li><li><code>WebSocket(HTML5)：new WebSocket(url) + onmessage</code> //兼容性 IE10+</li><li>服务器端设置代理请求：服务器端不受同源策略限制</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 小知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript知识 - Cookie</title>
      <link href="/2017/07/04/JavaScript%E7%9F%A5%E8%AF%86%20-%20Cookie/"/>
      <url>/2017/07/04/JavaScript%E7%9F%A5%E8%AF%86%20-%20Cookie/</url>
      
        <content type="html"><![CDATA[<h5 id="JavaScript知识-Cookie"><a href="#JavaScript知识-Cookie" class="headerlink" title="JavaScript知识 - Cookie"></a>JavaScript知识 - Cookie</h5><p>JavaScript资料整理</p><a id="more"></a><p><strong>请你谈谈Cookie的弊端</strong></p><ul><li>cookie虽然在持久保存客户端数据提供了方便，分担了服务器存储的负担，但还是有很多局限性的</li><li>第一：每个特定的域名下最多生成20个cookie</li><li>1.IE6或更低版本最多20个cookie</li><li>2.IE7和之后的版本最后可以有50个cookie。</li><li>3.Firefox最多50个cookie</li><li>4.chrome和Safari没有做硬性限制</li></ul><p><strong>请你谈谈Cookie的弊端？</strong></p><ul><li>每个特定的域名下最多生成的 cookie 个数有限制</li><li>IE 和 Opera 会清理近期最少使用的 cookie，Firefox 会随机清理 cookie</li><li>cookie 的最大大约为 4096 字节，为了兼容性，一般设置不超过 4095 字节</li><li>如果 cookie 被人拦截了，就可以取得所有的 session 信息</li></ul>]]></content>
      
      
      <categories>
          
          <category> 小知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript知识 - 线程与进程</title>
      <link href="/2017/07/03/JavaScript%E7%9F%A5%E8%AF%86%20-%20%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B/"/>
      <url>/2017/07/03/JavaScript%E7%9F%A5%E8%AF%86%20-%20%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h5 id="JavaScript知识-线程与进程"><a href="#JavaScript知识-线程与进程" class="headerlink" title="JavaScript知识- 线程与进程"></a>JavaScript知识- 线程与进程</h5><p>JavaScript资料整理</p><a id="more"></a><p><strong>线程与进程的区别</strong></p><ul><li>一个程序至少有一个进程，一个进程至少有一个线程</li><li>线程的划分尺度小于进程，使得多线程程序的并发性高</li><li>进程在执行过程中拥有独立的内存单元，而多个线程共享内存</li><li>线程不能够独立执行，必须应用程序提供多个线程执行控制</li></ul>]]></content>
      
      
      <categories>
          
          <category> 小知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript知识 - 典型开放题目</title>
      <link href="/2017/07/02/JavaScript%E7%9F%A5%E8%AF%86%20-%20%E5%85%B8%E5%9E%8B%E5%BC%80%E6%94%BE%E9%A2%98%E7%9B%AE/"/>
      <url>/2017/07/02/JavaScript%E7%9F%A5%E8%AF%86%20-%20%E5%85%B8%E5%9E%8B%E5%BC%80%E6%94%BE%E9%A2%98%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h5 id="JavaScript知识-典型开放题目"><a href="#JavaScript知识-典型开放题目" class="headerlink" title="JavaScript知识 - 典型开放题目"></a>JavaScript知识 - 典型开放题目</h5><p>JavaScript资料整理</p><a id="more"></a><p><strong>对前端工程师这个职位是怎么样理解的？它的前景会怎么样？</strong></p><ul><li>前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近<ul><li>实现界面交互</li><li>提升用户体验</li><li>有了<code>Node.js</code>，前端可以实现服务端的一些事情</li></ul></li><li>前端是最贴近用户的程序员，前端的能力就是能让产品从 <code>90</code>分进化到 <code>100</code> 分，甚至更好，</li><li>参与项目，快速高质量完成实现效果图，精确到<code>1px</code></li><li>与团队成员，<code>UI</code>设计，产品经理的沟通；</li><li>做好的页面结构，页面重构和用户体验；</li><li>处理<code>hack</code>，兼容、写出优美的代码格式；</li><li>针对服务器的优化、拥抱最新前端技术。</li></ul><p><strong>平时如何管理你的项目？</strong></p><ul><li>先期团队必须确定好全局样式（<code>globe.css</code>），编码模式(<code>utf-8</code>) 等；</li><li>编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）；</li><li>标注样式编写人，各模块都及时标注（标注关键样式调用的地方）；</li><li>页面进行标注（例如 页面 模块 开始和结束）；</li><li><code>CSS</code>跟<code>HTML</code> 分文件夹并行存放，命名都得统一（例如<code>style.css</code>）；</li><li><code>JS</code> 分文件夹存放 命名以该JS功能为准的英文翻译</li><li>图片采用整合的 <code>images.png</code> <code>png8</code> 格式文件使用</li><li>尽量整合在一起使用方便将来的管理</li></ul><h3 id="一些开放性题目"><a href="#一些开放性题目" class="headerlink" title="一些开放性题目"></a>一些开放性题目</h3><ul><li>自我介绍：除了基本个人信息以外，面试官更想听的是你与众不同的地方和你的优势</li><li>项目介绍</li><li>如何看待前端开发？</li><li>平时是如何学习前端开发的？</li><li>未来三到五年的规划是怎样的？</li></ul><p><strong>你觉得前端工程的价值体现在哪</strong></p><ul><li>为简化用户使用提供技术支持（交互部分）</li><li>为多个浏览器兼容性提供支持</li><li>为提高用户浏览速度（浏览器性能）提供支持</li><li>为跨平台或者其他基于<code>webkit</code>或其他渲染引擎的应用提供支持</li><li>为展示数据提供支持（数据接口）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 小知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript知识 - ajax</title>
      <link href="/2017/07/01/JavaScript%E7%9F%A5%E8%AF%86%20-%20ajax/"/>
      <url>/2017/07/01/JavaScript%E7%9F%A5%E8%AF%86%20-%20ajax/</url>
      
        <content type="html"><![CDATA[<h5 id="JavaScript知识-ajax"><a href="#JavaScript知识-ajax" class="headerlink" title="JavaScript知识 - ajax"></a>JavaScript知识 - ajax</h5><p>JavaScript资料整理</p><a id="more"></a><h2 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h2><ul><li><p>什么是<code>Ajax</code>? 如何创建一个<code>Ajax</code>？</p></li><li><p><code>AJAX(Asynchronous Javascript And XML)</code>= 异步 <code>JavaScript</code> + <code>XML</code> 在后台与服务器进行异步数据交换，不用重载整个网页，实现局部刷新。</p></li><li><p>创建 <code>ajax</code> 步骤：</p><ul><li>1.创建 <code>XMLHttpRequest</code> 对象</li><li>2.创建一个新的 <code>HTTP</code> 请求，并指定该 <code>HTTP</code> 请求的类型、验证信息</li><li>3.设置响应 <code>HTTP</code> 请求状态变化的回调函数</li><li>4.发送 <code>HTTP</code> 请求</li><li>5.获取异步调用返回的数据</li><li>6.使用 <code>JavaScript</code> 和 <code>DOM</code> 实现局部刷新</li></ul></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">"POST"</span>, url, <span class="literal">true</span>);</span><br><span class="line">xhr.setRequestHeader(<span class="string">"Content-type"</span>, <span class="string">"application/x-www-form-urlencoded"</span>);</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span> &amp;&amp; (xhr.status == <span class="number">200</span> || xhr.status == <span class="number">304</span>)) &#123;</span><br><span class="line">        fn.call(<span class="keyword">this</span>, xhr.responseText);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">xhr.send(data);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 小知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>前端基础 - 计算机基础</title>
      <link href="/2017/06/28/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%20-%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
      <url>/2017/06/28/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%20-%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h5 id="前端基础-计算机基础"><a href="#前端基础-计算机基础" class="headerlink" title="前端基础 - 计算机基础"></a>前端基础 - 计算机基础</h5><p>资料整理</p><a id="more"></a><h1 id="第四部分：计算机基础"><a href="#第四部分：计算机基础" class="headerlink" title="第四部分：计算机基础"></a>第四部分：计算机基础</h1><h2 id="一、网络"><a href="#一、网络" class="headerlink" title="一、网络"></a>一、网络</h2><h3 id="1-UDP"><a href="#1-UDP" class="headerlink" title="1 UDP"></a>1 UDP</h3><p><strong>1.1 面向报文</strong></p><blockquote><p><code>UDP</code> 是一个面向报文（报文可以理解为一段段的数据）的协议。意思就是 <code>UDP</code> 只是报文的搬运工，不会对报文进行任何拆分和拼接操作</p></blockquote><p>具体来说</p><ul><li>在发送端，应用层将数据传递给传输层的 <code>UDP</code> 协议，<code>UDP</code> 只会给数据增加一个 <code>UDP</code> 头标识下是 <code>UDP</code> 协议，然后就传递给网络层了</li><li>在接收端，网络层将数据传递给传输层，<code>UDP</code> 只去除 <code>IP</code> 报文头就传递给应用层，不会任何拼接操作</li></ul><p><strong>1.2 不可靠性</strong></p><ul><li><code>UDP</code> 是无连接的，也就是说通信不需要建立和断开连接。</li><li><code>UDP</code> 也是不可靠的。协议收到什么数据就传递什么数据，并且也不会备份数据，对方能不能收到是不关心的</li><li><code>UDP</code> 没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 <code>TCP</code></li></ul><p><strong>1.3 高效</strong></p><ul><li>因为 <code>UDP</code> 没有 <code>TCP</code> 那么复杂，需要保证数据不丢失且有序到达。所以 <code>UDP</code> 的头部开销小，只有八字节，相比 <code>TCP</code> 的至少二十字节要少得多，在传输数据报文时是很高效的</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/5/1/163195b245ceb89c?w=831&h=170&f=png&s=22793" alt=""></p><p><strong>头部包含了以下几个数据</strong></p><ul><li>两个十六位的端口号，分别为源端口（可选字段）和目标端口<br>整个数据报文的长度</li><li>整个数据报文的检验和（<code>IPv4</code> 可选 字段），该字段用于发现头部信息和数据中的错误</li></ul><p><strong>1.4 传输方式</strong></p><blockquote><p><code>UDP</code> 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能</p></blockquote><h3 id="2-TCP"><a href="#2-TCP" class="headerlink" title="2 TCP"></a>2 TCP</h3><p><strong>2.1 头部</strong></p><blockquote><p><code>TCP</code> 头部比 <code>UDP</code> 头部复杂的多</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/5/1/1631be45b084e4bc?w=858&h=305&f=png&s=62112" alt=""></p><blockquote><p>对于 <code>TCP</code> 头部来说，以下几个字段是很重要的</p></blockquote><ul><li><code>Sequence number</code>，这个序号保证了 <code>TCP</code> 传输的报文都是有序的，对端可以通过序号顺序的拼接报文</li><li><code>Acknowledgement Number</code>，这个序号表示数据接收端期望接收的下一个字节的编号是多少，同时也表示上一个序号的数据已经收到</li><li><code>Window Size</code>，窗口大小，表示还能接收多少字节的数据，用于流量控制</li></ul><p><strong>标识符</strong></p><ul><li><code>URG=1</code>：该字段为一表示本数据报的数据部分包含紧急信息，是一个高优先级数据报文，此时紧急指针有效。紧急数据一定位于当前数据包数据部分的最前面，紧急指针标明了紧急数据的尾部。</li><li><code>ACK=1</code>：该字段为一表示确认号字段有效。此外，<code>TCP</code> 还规定在连接建立后传送的所有报文段都必须把 <code>ACK</code> 置为一<br><code>PSH=1</code>：该字段为一表示接收端应该立即将数据 push 给应用层，而不是等到缓冲区满后再提交。</li><li><code>RST=1</code>：该字段为一表示当前 <code>TCP</code> 连接出现严重问题，可能需要重新建立 <code>TCP</code> 连接，也可以用于拒绝非法的报文段和拒绝连接请求。</li><li><code>SYN=1</code>：当<code>SYN=1</code>，<code>ACK=0</code>时，表示当前报文段是一个连接请求报文。当<code>SYN=1</code>，<code>ACK=1</code>时，表示当前报文段是一个同意建立连接的应答报文。</li><li><code>FIN=1</code>：该字段为一表示此报文段是一个释放连接的请求报文</li></ul><p><strong>2.2 状态机</strong></p><blockquote><p><code>HTTP</code> 是无连接的，所以作为下层的 <code>TCP</code> 协议也是无连接的，虽然看似 <code>TCP</code> 将两端连接了起来，但是其实只是两端共同维护了一个状态</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/5/1/1631bef9e3c60035?w=1280&h=965&f=png&s=101432" alt=""></p><ul><li><code>TCP</code> 的状态机是很复杂的，并且与建立断开连接时的握手息息相关，接下来就来详细描述下两种握手。</li><li>在这之前需要了解一个重要的性能指标 RTT。该指标表示发送端发送数据到接收到对端数据所需的往返时间</li></ul><p><strong>建立连接三次握手</strong></p><p><img src="https://user-gold-cdn.xitu.io/2018/5/1/1631bf1e79b3cd42?w=666&h=426&f=png&s=32121" alt=""></p><ul><li>在 <code>TCP</code> 协议中，主动发起请求的一端为客户端，被动连接的一端称为服务端。不管是客户端还是服务端，<code>TCP</code>连接建立完后都能发送和接收数据，所以 <code>TCP</code> 也是一个全双工的协议。</li><li>起初，两端都为 <code>CLOSED</code> 状态。在通信开始前，双方都会创建 <code>TCB</code>。 服务器创建完 <code>TCB</code> 后遍进入 <code>LISTEN</code> 状态，此时开始等待客户端发送数据</li></ul><p><strong>第一次握手</strong></p><blockquote><p>客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态，x 表示客户端的数据通信初始序号。</p></blockquote><p><strong>第二次握手</strong></p><blockquote><p>服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 <code>SYN-RECEIVED</code> 状态。</p></blockquote><p><strong>第三次握手</strong></p><blockquote><p>当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入<code>ESTABLISHED</code> 状态，服务端收到这个应答后也进入 <code>ESTABLISHED</code>状态，此时连接建立成功。</p></blockquote><ul><li>PS：第三次握手可以包含数据，通过 <code>TCP</code> 快速打开（<code>TFO</code>）技术。其实只要涉及到握手的协议，都可以使用类似 <code>TFO</code> 的方式，客户端和服务端存储相同 <code>cookie</code>，下次握手时发出 <code>cookie</code>达到减少 <code>RTT</code> 的目的</li></ul><p><strong>你是否有疑惑明明两次握手就可以建立起连接，为什么还需要第三次应答？</strong></p><ul><li>因为这是为了防止失效的连接请求报文段被服务端接收，从而产生错误</li></ul><blockquote><p>可以想象如下场景。客户端发送了一个连接请求 A，但是因为网络原因造成了超时，这时 TCP 会启动超时重传的机制再次发送一个连接请求 B。此时请求顺利到达服务端，服务端应答完就建立了请求。如果连接请求 A 在两端关闭后终于抵达了服务端，那么这时服务端会认为客户端又需要建立 TCP 连接，从而应答了该请求并进入 <code>ESTABLISHED</code> 状态。此时客户端其实是 CLOSED 状态，那么就会导致服务端一直等待，造成资源的浪费</p></blockquote><blockquote><p>PS：在建立连接中，任意一端掉线，TCP 都会重发 SYN 包，一般会重试五次，在建立连接中可能会遇到 SYN FLOOD 攻击。遇到这种情况你可以选择调低重试次数或者干脆在不能处理的情况下拒绝请求</p></blockquote><p><strong>断开链接四次握手</strong></p><p><img src="https://user-gold-cdn.xitu.io/2018/5/2/1631fb807f2c6c1b?w=640&h=512&f=png&s=31059" alt=""></p><blockquote><p><code>TCP</code> 是全双工的，在断开连接时两端都需要发送 <code>FIN</code> 和 <code>ACK</code>。</p></blockquote><p><strong>第一次握手</strong></p><blockquote><p>若客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求。</p></blockquote><p><strong>第二次握手</strong></p><blockquote><p>B 收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，表示 A 到 B 的连接已经释放，不接收 A 发的数据了。但是因为 TCP 连接时双向的，所以 B 仍旧可以发送数据给 A。</p></blockquote><p><strong>第三次握手</strong></p><blockquote><p>B 如果此时还有没发完的数据会继续发送，完毕后会向 A 发送连接释放请求，然后 B 便进入 LAST-ACK 状态。</p></blockquote><blockquote><p>PS：通过延迟确认的技术（通常有时间限制，否则对方会误认为需要重传），可以将第二次和第三次握手合并，延迟 ACK 包的发送。</p></blockquote><p><strong>第四次握手</strong></p><ul><li>A 收到释放请求后，向 B 发送确认应答，此时 A 进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有 B 的重发请求的话，就进入 CLOSED 状态。当 B 收到确认应答后，也便进入 CLOSED 状态。</li></ul><blockquote><p>为什么 A 要进入 TIME-WAIT 状态，等待 2MSL 时间后才进入 CLOSED 状态？</p></blockquote><ul><li>为了保证 B 能收到 A 的确认应答。若 A 发完确认应答后直接进入 CLOSED 状态，如果确认应答因为网络问题一直没有到达，那么会造成 B 不能正常关闭</li></ul><h3 id="3-HTTP"><a href="#3-HTTP" class="headerlink" title="3 HTTP"></a>3 HTTP</h3><blockquote><p><code>HTTP</code> 协议是个无状态协议，不会保存状态</p></blockquote><p><strong>3.1 Post 和 Get 的区别</strong></p><ul><li><code>Get</code>请求能缓存，<code>Post</code> 不能</li><li><code>Post</code> 相对 <code>Get</code>安全一点点，因为<code>Get</code> 请求都包含在 <code>URL</code> 里，且会被浏览器保存历史纪录，<code>Post</code> 不会，但是在抓包的情况下都是一样的。</li><li><code>Post</code> 可以通过 <code>request body</code>来传输比 <code>Get</code> 更多的数据，<code>Get</code>没有这个技术</li><li><code>URL</code>有长度限制，会影响 <code>Get</code>请求，但是这个长度限制是浏览器规定的，不是 <code>RFC</code> 规定的</li><li><code>Post</code> 支持更多的编码类型且不对数据类型限制</li></ul><p><strong>3.2 常见状态码</strong></p><p><strong>2XX 成功</strong></p><ul><li><code>200 OK</code>，表示从客户端发来的请求在服务器端被正确处理</li><li><code>204 No content</code>，表示请求成功，但响应报文不含实体的主体部分</li><li><code>205 Reset Content</code>，表示请求成功，但响应报文不含实体的主体部分，但是与 <code>204</code> 响应不同在于要求请求方重置内容</li><li><code>206 Partial Content</code>，进行范围请求</li></ul><p><strong>3XX 重定向</strong></p><ul><li><code>301 moved permanently</code>，永久性重定向，表示资源已被分配了新的 URL</li><li><code>302 found</code>，临时性重定向，表示资源临时被分配了新的 URL</li><li><code>303 see other</code>，表示资源存在着另一个 URL，应使用 GET 方法丁香获取资源</li><li><code>304 not modified</code>，表示服务器允许访问资源，但因发生请求未满足条件的情况</li><li><code>307 temporary redirect</code>，临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求</li></ul><p><strong>4XX 客户端错误</strong></p><ul><li><code>400 bad request</code>，请求报文存在语法错误</li><li><code>401 unauthorized</code>，表示发送的请求需要有通过 <code>HTTP</code>认证的认证信息</li><li><code>403 forbidden</code>，表示对请求资源的访问被服务器拒绝</li><li><code>404 not found</code>，表示在服务器上没有找到请求的资源</li></ul><p><strong>5XX 服务器错误</strong></p><ul><li><code>500 internal sever error</code>，表示服务器端在执行请求时发生了错误</li><li><code>501 Not Implemented</code>，表示服务器不支持当前请求所需要的某个功能</li><li><code>503 service unavailable</code>，表明服务器暂时处于超负载或正在停机维护，无法处理请求</li></ul><p><strong>3.3 HTTP 首部</strong></p><table><thead><tr><th>通用字段</th><th>作用</th></tr></thead><tbody><tr><td><code>Cache-Control</code></td><td>控制缓存的行为</td></tr><tr><td><code>Connection</code></td><td>浏览器想要优先使用的连接类型，比如 <code>keep-alive</code></td></tr><tr><td><code>Date</code></td><td>创建报文时间</td></tr><tr><td><code>Pragma</code></td><td>报文指令</td></tr><tr><td><code>Via</code></td><td>代理服务器相关信息</td></tr></tbody></table><p>|<code>Transfer-Encoding</code>|传输编码方式<br>|<code>Upgrade</code>|要求客户端升级协议|<br>|<code>Warning</code>|在内容中可能存在错误|</p><table><thead><tr><th>请求字段</th><th>作用</th></tr></thead><tbody><tr><td><code>Accept</code></td><td>能正确接收的媒体类型</td></tr><tr><td><code>Accept-Charset</code></td><td>能正确接收的字符集</td></tr><tr><td><code>Accept-Encoding</code></td><td>能正确接收的编码格式列表</td></tr><tr><td><code>Accept-Language</code></td><td>能正确接收的语言列表</td></tr><tr><td><code>Expect</code></td><td>期待服务端的指定行为</td></tr><tr><td><code>From</code></td><td>请求方邮箱地址</td></tr><tr><td><code>Host</code></td><td>服务器的域名</td></tr><tr><td><code>If-Match</code></td><td>两端资源标记比较</td></tr><tr><td><code>If-Modified-Since</code></td><td>本地资源未修改返回 304（比较时间）</td></tr><tr><td><code>If-None-Match</code></td><td>本地资源未修改返回 304（比较标记）</td></tr><tr><td><code>User-Agent</code></td><td>客户端信息</td></tr><tr><td><code>Max-Forwards</code></td><td>限制可被代理及网关转发的次数</td></tr><tr><td><code>Proxy-Authorization</code></td><td>向代理服务器发送验证信息</td></tr><tr><td><code>Range</code></td><td>请求某个内容的一部分</td></tr><tr><td><code>Referer</code></td><td>表示浏览器所访问的前一个页面</td></tr><tr><td><code>TE</code></td><td>传输编码方式</td></tr></tbody></table><table><thead><tr><th>响应字段</th><th>作用</th></tr></thead><tbody><tr><td><code>Accept-Ranges</code></td><td>是否支持某些种类的范围</td></tr><tr><td><code>Age</code></td><td>资源在代理缓存中存在的时间</td></tr><tr><td><code>ETag</code></td><td>资源标识</td></tr><tr><td><code>Location</code></td><td>客户端重定向到某个 <code>URL</code></td></tr><tr><td><code>Proxy-Authenticate</code></td><td>向代理服务器发送验证信息</td></tr><tr><td><code>Server</code></td><td>服务器名字</td></tr><tr><td><code>WWW-Authenticate</code></td><td>获取资源需要的验证信息</td></tr></tbody></table><table><thead><tr><th>实体字段</th><th>作用</th></tr></thead><tbody><tr><td><code>Allow</code></td><td>资源的正确请求方式</td></tr><tr><td><code>Content-Encoding</code></td><td>内容的编码格式</td></tr><tr><td><code>Content-Language</code></td><td>内容使用的语言</td></tr><tr><td><code>Content-Length</code></td><td><code>request body</code> 长度</td></tr><tr><td><code>Content-Location</code></td><td>返回数据的备用地址</td></tr><tr><td><code>Content-MD5</code></td><td><code>Base64</code>加密格式的内容<code>MD5</code>检验值</td></tr><tr><td><code>Content-Range</code></td><td>内容的位置范围</td></tr><tr><td><code>Content-Type</code></td><td>内容的媒体类型</td></tr><tr><td><code>Expires</code></td><td>内容的过期时间</td></tr><tr><td><code>Last_modified</code></td><td>内容的最后修改时间</td></tr></tbody></table><h3 id="4-DNS"><a href="#4-DNS" class="headerlink" title="4 DNS"></a>4 DNS</h3><blockquote><p>DNS 的作用就是通过域名查询到具体的 IP。</p></blockquote><ul><li>因为 IP 存在数字和英文的组合（IPv6），很不利于人类记忆，所以就出现了域名。你可以把域名看成是某个 IP 的别名，DNS 就是去查询这个别名的真正名称是什么</li></ul><blockquote><p>在 <code>TCP</code> 握手之前就已经进行了 <code>DNS</code> 查询，这个查询是操作系统自己做的。当你在浏览器中想访问 <code>www.google.com</code> 时，会进行一下操作</p></blockquote><ul><li>操作系统会首先在本地缓存中查询</li><li>没有的话会去系统配置的 DNS 服务器中查询</li><li>如果这时候还没得话，会直接去 DNS 根服务器查询，这一步查询会找出负责 com 这个一级域名的服务器</li><li>然后去该服务器查询 google 这个二级域名</li><li>接下来三级域名的查询其实是我们配置的，你可以给 www 这个域名配置一个 IP，然后还可以给别的三级域名配置一个 IP</li></ul><blockquote><p>以上介绍的是 DNS 迭代查询，还有种是递归查询，区别就是前者是由客户端去做请求，后者是由系统配置的 DNS 服务器做请求，得到结果后将数据返回给客户端。</p></blockquote><h2 id="二、数据结构"><a href="#二、数据结构" class="headerlink" title="二、数据结构"></a>二、数据结构</h2><h3 id="2-1-栈"><a href="#2-1-栈" class="headerlink" title="2.1 栈"></a>2.1 栈</h3><p><strong>概念</strong></p><ul><li>栈是一个线性结构，在计算机中是一个相当常见的数据结构。</li><li>栈的特点是只能在某一端添加或删除数据，遵循先进后出的原则</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/5/20/1637b785d2d68735?w=640&h=460&f=png&s=6932" alt=""></p><p><strong>实现</strong></p><blockquote><p>每种数据结构都可以用很多种方式来实现，其实可以把栈看成是数组的一个子集，所以这里使用数组来实现</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.stack = []</span><br><span class="line">  &#125;</span><br><span class="line">  push(item) &#123;</span><br><span class="line">    <span class="keyword">this</span>.stack.push(item)</span><br><span class="line">  &#125;</span><br><span class="line">  pop() &#123;</span><br><span class="line">    <span class="keyword">this</span>.stack.pop()</span><br><span class="line">  &#125;</span><br><span class="line">  peek() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.stack[<span class="keyword">this</span>.getCount() - <span class="number">1</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  getCount() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.stack.length</span><br><span class="line">  &#125;</span><br><span class="line">  isEmpty() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.getCount() === <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>应用</strong></p><blockquote><p>匹配括号，可以通过栈的特性来完成</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isValid = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> map = &#123;</span><br><span class="line">    <span class="string">'('</span>: <span class="number">-1</span>,</span><br><span class="line">    <span class="string">')'</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">'['</span>: <span class="number">-2</span>,</span><br><span class="line">    <span class="string">']'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'&#123;'</span>: <span class="number">-3</span>,</span><br><span class="line">    <span class="string">'&#125;'</span>: <span class="number">3</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> stack = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (map[s[i]] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      stack.push(s[i])</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> last = stack.pop()</span><br><span class="line">      <span class="keyword">if</span> (map[last] + map[s[i]] != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (stack.length &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-2-队列"><a href="#2-2-队列" class="headerlink" title="2.2 队列"></a>2.2 队列</h3><p><strong>概念</strong></p><blockquote><p>队列一个线性结构，特点是在某一端添加数据，在另一端删除数据，遵循先进先出的原则</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/5/20/1637cba2a6155793?w=640&h=419&f=png&s=15737" alt=""></p><p><strong>实现</strong></p><blockquote><p>这里会讲解两种实现队列的方式，分别是单链队列和循环队列</p></blockquote><ul><li><strong>单链队列</strong></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.queue = []</span><br><span class="line">  &#125;</span><br><span class="line">  enQueue(item) &#123;</span><br><span class="line">    <span class="keyword">this</span>.queue.push(item)</span><br><span class="line">  &#125;</span><br><span class="line">  deQueue() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.queue.shift()</span><br><span class="line">  &#125;</span><br><span class="line">  getHeader() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.queue[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  getLength() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.queue.length</span><br><span class="line">  &#125;</span><br><span class="line">  isEmpty() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.getLength() === <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>因为单链队列在出队操作的时候需要 <code>O(n)</code> 的时间复杂度，所以引入了循环队列。循环队列的出队操作平均是 <code>O(1)</code> 的时间复杂度</p></blockquote><ul><li><strong>循环队列</strong></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SqQueue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">    <span class="keyword">this</span>.queue = <span class="keyword">new</span> <span class="built_in">Array</span>(length + <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 队头</span></span><br><span class="line">    <span class="keyword">this</span>.first = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 队尾</span></span><br><span class="line">    <span class="keyword">this</span>.last = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 当前队列大小</span></span><br><span class="line">    <span class="keyword">this</span>.size = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  enQueue(item) &#123;</span><br><span class="line">    <span class="comment">// 判断队尾 + 1 是否为队头</span></span><br><span class="line">    <span class="comment">// 如果是就代表需要扩容数组</span></span><br><span class="line">    <span class="comment">// % this.queue.length 是为了防止数组越界</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.first === (<span class="keyword">this</span>.last + <span class="number">1</span>) % <span class="keyword">this</span>.queue.length) &#123;</span><br><span class="line">      <span class="keyword">this</span>.resize(<span class="keyword">this</span>.getLength() * <span class="number">2</span> + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.queue[<span class="keyword">this</span>.last] = item</span><br><span class="line">    <span class="keyword">this</span>.size++</span><br><span class="line">    <span class="keyword">this</span>.last = (<span class="keyword">this</span>.last + <span class="number">1</span>) % <span class="keyword">this</span>.queue.length</span><br><span class="line">  &#125;</span><br><span class="line">  deQueue() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'Queue is empty'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> r = <span class="keyword">this</span>.queue[<span class="keyword">this</span>.first]</span><br><span class="line">    <span class="keyword">this</span>.queue[<span class="keyword">this</span>.first] = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">this</span>.first = (<span class="keyword">this</span>.first + <span class="number">1</span>) % <span class="keyword">this</span>.queue.length</span><br><span class="line">    <span class="keyword">this</span>.size--</span><br><span class="line">    <span class="comment">// 判断当前队列大小是否过小</span></span><br><span class="line">    <span class="comment">// 为了保证不浪费空间，在队列空间等于总长度四分之一时</span></span><br><span class="line">    <span class="comment">// 且不为 2 时缩小总长度为当前的一半</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.size === <span class="keyword">this</span>.getLength() / <span class="number">4</span> &amp;&amp; <span class="keyword">this</span>.getLength() / <span class="number">2</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.resize(<span class="keyword">this</span>.getLength() / <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">  &#125;</span><br><span class="line">  getHeader() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'Queue is empty'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.queue[<span class="keyword">this</span>.first]</span><br><span class="line">  &#125;</span><br><span class="line">  getLength() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.queue.length - <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  isEmpty() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.first === <span class="keyword">this</span>.last</span><br><span class="line">  &#125;</span><br><span class="line">  resize(length) &#123;</span><br><span class="line">    <span class="keyword">let</span> q = <span class="keyword">new</span> <span class="built_in">Array</span>(length)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">      q[i] = <span class="keyword">this</span>.queue[(i + <span class="keyword">this</span>.first) % <span class="keyword">this</span>.queue.length]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.queue = q</span><br><span class="line">    <span class="keyword">this</span>.first = <span class="number">0</span></span><br><span class="line">    <span class="keyword">this</span>.last = <span class="keyword">this</span>.size</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-链表"><a href="#2-3-链表" class="headerlink" title="2.3 链表"></a>2.3 链表</h3><p><strong>概念</strong></p><blockquote><p>链表是一个线性结构，同时也是一个天然的递归结构。链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/5/22/16388487759b1152?w=1060&h=178&f=png&s=20820" alt=""></p><p><strong>实现</strong></p><ul><li><strong>单向链表</strong></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(v, next) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = v</span><br><span class="line">    <span class="keyword">this</span>.next = next</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkList</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// 链表长度</span></span><br><span class="line">    <span class="keyword">this</span>.size = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 虚拟头部</span></span><br><span class="line">    <span class="keyword">this</span>.dummyNode = <span class="keyword">new</span> Node(<span class="literal">null</span>, <span class="literal">null</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  find(header, index, currentIndex) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index === currentIndex) <span class="keyword">return</span> header</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.find(header.next, index, currentIndex + <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  addNode(v, index) &#123;</span><br><span class="line">    <span class="keyword">this</span>.checkIndex(index)</span><br><span class="line">    <span class="comment">// 当往链表末尾插入时，prev.next 为空</span></span><br><span class="line">    <span class="comment">// 其他情况时，因为要插入节点，所以插入的节点</span></span><br><span class="line">    <span class="comment">// 的 next 应该是 prev.next</span></span><br><span class="line">    <span class="comment">// 然后设置 prev.next 为插入的节点</span></span><br><span class="line">    <span class="keyword">let</span> prev = <span class="keyword">this</span>.find(<span class="keyword">this</span>.dummyNode, index, <span class="number">0</span>)</span><br><span class="line">    prev.next = <span class="keyword">new</span> Node(v, prev.next)</span><br><span class="line">    <span class="keyword">this</span>.size++</span><br><span class="line">    <span class="keyword">return</span> prev.next</span><br><span class="line">  &#125;</span><br><span class="line">  insertNode(v, index) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.addNode(v, index)</span><br><span class="line">  &#125;</span><br><span class="line">  addToFirst(v) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.addNode(v, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  addToLast(v) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.addNode(v, <span class="keyword">this</span>.size)</span><br><span class="line">  &#125;</span><br><span class="line">  removeNode(index, isLast) &#123;</span><br><span class="line">    <span class="keyword">this</span>.checkIndex(index)</span><br><span class="line">    index = isLast ? index - <span class="number">1</span> : index</span><br><span class="line">    <span class="keyword">let</span> prev = <span class="keyword">this</span>.find(<span class="keyword">this</span>.dummyNode, index, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">let</span> node = prev.next</span><br><span class="line">    prev.next = node.next</span><br><span class="line">    node.next = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">this</span>.size--</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">  &#125;</span><br><span class="line">  removeFirstNode() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.removeNode(<span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  removeLastNode() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.removeNode(<span class="keyword">this</span>.size, <span class="literal">true</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  checkIndex(index) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; <span class="keyword">this</span>.size) <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'Index error'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  getNode(index) &#123;</span><br><span class="line">    <span class="keyword">this</span>.checkIndex(index)</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.find(<span class="keyword">this</span>.dummyNode, index, <span class="number">0</span>).next</span><br><span class="line">  &#125;</span><br><span class="line">  isEmpty() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size === <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  getSize() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-树"><a href="#2-4-树" class="headerlink" title="2.4 树"></a>2.4 树</h3><p><strong>二叉树</strong></p><ul><li>树拥有很多种结构，二叉树是树中最常用的结构，同时也是一个天然的递归结构。</li><li>二叉树拥有一个根节点，每个节点至多拥有两个子节点，分别为：左节点和右节点。树的最底部节点称之为叶节点，当一颗树的叶数量数量为满时，该树可以称之为满二叉树</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/5/22/163884f74c9f4e4d?w=320&h=267&f=png&s=11622" alt=""></p><p><strong>二分搜索树</strong></p><ul><li>二分搜索树也是二叉树，拥有二叉树的特性。但是区别在于二分搜索树每个节点的值都比他的左子树的值大，比右子树的值小</li><li>这种存储方式很适合于数据搜索。如下图所示，当需要查找 6 的时候，因为需要查找的值比根节点的值大，所以只需要在根节点的右子树上寻找，大大提高了搜索效率</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/5/22/1638850ba7458208?w=596&h=485&f=png&s=36796" alt=""></p><ul><li><strong>实现</strong></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Node &#123;</span><br><span class="line">  constructor(value) &#123;</span><br><span class="line">    this.value &#x3D; value</span><br><span class="line">    this.left &#x3D; null</span><br><span class="line">    this.right &#x3D; null</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class BST &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.root &#x3D; null</span><br><span class="line">    this.size &#x3D; 0</span><br><span class="line">  &#125;</span><br><span class="line">  getSize() &#123;</span><br><span class="line">    return this.size</span><br><span class="line">  &#125;</span><br><span class="line">  isEmpty() &#123;</span><br><span class="line">    return this.size &#x3D;&#x3D;&#x3D; 0</span><br><span class="line">  &#125;</span><br><span class="line">  addNode(v) &#123;</span><br><span class="line">    this.root &#x3D; this._addChild(this.root, v)</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 添加节点时，需要比较添加的节点值和当前</span><br><span class="line">  &#x2F;&#x2F; 节点值的大小</span><br><span class="line">  _addChild(node, v) &#123;</span><br><span class="line">    if (!node) &#123;</span><br><span class="line">      this.size++</span><br><span class="line">      return new Node(v)</span><br><span class="line">    &#125;</span><br><span class="line">    if (node.value &gt; v) &#123;</span><br><span class="line">      node.left &#x3D; this._addChild(node.left, v)</span><br><span class="line">    &#125; else if (node.value &lt; v) &#123;</span><br><span class="line">      node.right &#x3D; this._addChild(node.right, v)</span><br><span class="line">    &#125;</span><br><span class="line">    return node</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>以上是最基本的二分搜索树实现，接下来实现树的遍历。</li></ul><blockquote><p>对于树的遍历来说，有三种遍历方法，分别是先序遍历、中序遍历、后序遍历。三种遍历的区别在于何时访问节点。在遍历树的过程中，每个节点都会遍历三次，分别是遍历到自己，遍历左子树和遍历右子树。如果需要实现先序遍历，那么只需要第一次遍历到节点时进行操作即可</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先序遍历可用于打印树的结构</span></span><br><span class="line"><span class="comment">// 先序遍历先访问根节点，然后访问左节点，最后访问右节点。</span></span><br><span class="line">preTraversal() &#123;</span><br><span class="line">  <span class="keyword">this</span>._pre(<span class="keyword">this</span>.root)</span><br><span class="line">&#125;</span><br><span class="line">_pre(node) &#123;</span><br><span class="line">  <span class="keyword">if</span> (node) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(node.value)</span><br><span class="line">    <span class="keyword">this</span>._pre(node.left)</span><br><span class="line">    <span class="keyword">this</span>._pre(node.right)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中序遍历可用于排序</span></span><br><span class="line"><span class="comment">// 对于 BST 来说，中序遍历可以实现一次遍历就</span></span><br><span class="line"><span class="comment">// 得到有序的值</span></span><br><span class="line"><span class="comment">// 中序遍历表示先访问左节点，然后访问根节点，最后访问右节点。</span></span><br><span class="line">midTraversal() &#123;</span><br><span class="line">  <span class="keyword">this</span>._mid(<span class="keyword">this</span>.root)</span><br><span class="line">&#125;</span><br><span class="line">_mid(node) &#123;</span><br><span class="line">  <span class="keyword">if</span> (node) &#123;</span><br><span class="line">    <span class="keyword">this</span>._mid(node.left)</span><br><span class="line">    <span class="built_in">console</span>.log(node.value)</span><br><span class="line">    <span class="keyword">this</span>._mid(node.right)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 后序遍历可用于先操作子节点</span></span><br><span class="line"><span class="comment">// 再操作父节点的场景</span></span><br><span class="line"><span class="comment">// 后序遍历表示先访问左节点，然后访问右节点，最后访问根节点。</span></span><br><span class="line">backTraversal() &#123;</span><br><span class="line">  <span class="keyword">this</span>._back(<span class="keyword">this</span>.root)</span><br><span class="line">&#125;</span><br><span class="line">_back(node) &#123;</span><br><span class="line">  <span class="keyword">if</span> (node) &#123;</span><br><span class="line">    <span class="keyword">this</span>._back(node.left)</span><br><span class="line">    <span class="keyword">this</span>._back(node.right)</span><br><span class="line">    <span class="built_in">console</span>.log(node.value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以上的这几种遍历都可以称之为深度遍历，对应的还有种遍历叫做广度遍历，也就是一层层地遍历树。对于广度遍历来说，我们需要利用之前讲过的队列结构来完成</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">breadthTraversal() &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.root) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  <span class="keyword">let</span> q = <span class="keyword">new</span> Queue()</span><br><span class="line">  <span class="comment">// 将根节点入队</span></span><br><span class="line">  q.enQueue(<span class="keyword">this</span>.root)</span><br><span class="line">  <span class="comment">// 循环判断队列是否为空，为空</span></span><br><span class="line">  <span class="comment">// 代表树遍历完毕</span></span><br><span class="line">  <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">    <span class="comment">// 将队首出队，判断是否有左右子树</span></span><br><span class="line">    <span class="comment">// 有的话，就先左后右入队</span></span><br><span class="line">    <span class="keyword">let</span> n = q.deQueue()</span><br><span class="line">    <span class="built_in">console</span>.log(n.value)</span><br><span class="line">    <span class="keyword">if</span> (n.left) q.enQueue(n.left)</span><br><span class="line">    <span class="keyword">if</span> (n.right) q.enQueue(n.right)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>接下来先介绍如何在树中寻找最小值或最大数。因为二分搜索树的特性，所以最小值一定在根节点的最左边，最大值相反</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getMin() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>._getMin(<span class="keyword">this</span>.root).value</span><br><span class="line">&#125;</span><br><span class="line">_getMin(node) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!node.left) <span class="keyword">return</span> node</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>._getMin(node.left)</span><br><span class="line">&#125;</span><br><span class="line">getMax() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>._getMax(<span class="keyword">this</span>.root).value</span><br><span class="line">&#125;</span><br><span class="line">_getMax(node) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!node.right) <span class="keyword">return</span> node</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>._getMin(node.right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>向上取整和向下取整，这两个操作是相反的，所以代码也是类似的，这里只介绍如何向下取整。既然是向下取整，那么根据二分搜索树的特性，值一定在根节点的左侧。只需要一直遍历左子树直到当前节点的值不再大于等于需要的值，然后判断节点是否还拥有右子树。如果有的话，继续上面的递归判断</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">floor(v) &#123;</span><br><span class="line">  <span class="keyword">let</span> node = <span class="keyword">this</span>._floor(<span class="keyword">this</span>.root, v)</span><br><span class="line">  <span class="keyword">return</span> node ? node.value : <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line">_floor(node, v) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  <span class="keyword">if</span> (node.value === v) <span class="keyword">return</span> v</span><br><span class="line">  <span class="comment">// 如果当前节点值还比需要的值大，就继续递归</span></span><br><span class="line">  <span class="keyword">if</span> (node.value &gt; v) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._floor(node.left, v)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断当前节点是否拥有右子树</span></span><br><span class="line">  <span class="keyword">let</span> right = <span class="keyword">this</span>._floor(node.right, v)</span><br><span class="line">  <span class="keyword">if</span> (right) <span class="keyword">return</span> right</span><br><span class="line">  <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>排名，这是用于获取给定值的排名或者排名第几的节点的值，这两个操作也是相反的，所以这个只介绍如何获取排名第几的节点的值。对于这个操作而言，我们需要略微的改造点代码，让每个节点拥有一个 size 属性。该属性表示该节点下有多少子节点（包含自身）</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value</span><br><span class="line">    <span class="keyword">this</span>.left = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">this</span>.right = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// 修改代码</span></span><br><span class="line">    <span class="keyword">this</span>.size = <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 新增代码</span></span><br><span class="line">_getSize(node) &#123;</span><br><span class="line">  <span class="keyword">return</span> node ? node.size : <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">_addChild(node, v) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Node(v)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (node.value &gt; v) &#123;</span><br><span class="line">    <span class="comment">// 修改代码</span></span><br><span class="line">    node.size++</span><br><span class="line">    node.left = <span class="keyword">this</span>._addChild(node.left, v)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.value &lt; v) &#123;</span><br><span class="line">    <span class="comment">// 修改代码</span></span><br><span class="line">    node.size++</span><br><span class="line">    node.right = <span class="keyword">this</span>._addChild(node.right, v)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line">select(k) &#123;</span><br><span class="line">  <span class="keyword">let</span> node = <span class="keyword">this</span>._select(<span class="keyword">this</span>.root, k)</span><br><span class="line">  <span class="keyword">return</span> node ? node.value : <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line">_select(node, k) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  <span class="comment">// 先获取左子树下有几个节点</span></span><br><span class="line">  <span class="keyword">let</span> size = node.left ? node.left.size : <span class="number">0</span></span><br><span class="line">  <span class="comment">// 判断 size 是否大于 k</span></span><br><span class="line">  <span class="comment">// 如果大于 k，代表所需要的节点在左节点</span></span><br><span class="line">  <span class="keyword">if</span> (size &gt; k) <span class="keyword">return</span> <span class="keyword">this</span>._select(node.left, k)</span><br><span class="line">  <span class="comment">// 如果小于 k，代表所需要的节点在右节点</span></span><br><span class="line">  <span class="comment">// 注意这里需要重新计算 k，减去根节点除了右子树的节点数量</span></span><br><span class="line">  <span class="keyword">if</span> (size &lt; k) <span class="keyword">return</span> <span class="keyword">this</span>._select(node.right, k - size - <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>接下来讲解的是二分搜索树中最难实现的部分：删除节点。因为对于删除节点来说，会存在以下几种情况</p></blockquote><ul><li>需要删除的节点没有子树</li><li>需要删除的节点只有一条子树</li><li>需要删除的节点有左右两条树</li><li>对于前两种情况很好解决，但是第三种情况就有难度了，所以先来实现相对简单的操作：删除最小节点，对于删除最小节点来说，是不存在第三种情况的，删除最大节点操作是和删除最小节点相反的，所以这里也就不再赘述</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">delectMin() &#123;</span><br><span class="line">  <span class="keyword">this</span>.root = <span class="keyword">this</span>._delectMin(<span class="keyword">this</span>.root)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.root)</span><br><span class="line">&#125;</span><br><span class="line">_delectMin(node) &#123;</span><br><span class="line">  <span class="comment">// 一直递归左子树</span></span><br><span class="line">  <span class="comment">// 如果左子树为空，就判断节点是否拥有右子树</span></span><br><span class="line">  <span class="comment">// 有右子树的话就把需要删除的节点替换为右子树</span></span><br><span class="line">  <span class="keyword">if</span> ((node != <span class="literal">null</span>) &amp; !node.left) <span class="keyword">return</span> node.right</span><br><span class="line">  node.left = <span class="keyword">this</span>._delectMin(node.left)</span><br><span class="line">  <span class="comment">// 最后需要重新维护下节点的 `size`</span></span><br><span class="line">  node.size = <span class="keyword">this</span>._getSize(node.left) + <span class="keyword">this</span>._getSize(node.right) + <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>最后讲解的就是如何删除任意节点了。对于这个操作，<code>T.Hibbard</code> 在 <code>1962</code>年提出了解决这个难题的办法，也就是如何解决第三种情况。</li><li>当遇到这种情况时，需要取出当前节点的后继节点（也就是当前节点右子树的最小节点）来替换需要删除的节点。然后将需要删除节点的左子树赋值给后继结点，右子树删除后继结点后赋值给他。</li><li>你如果对于这个解决办法有疑问的话，可以这样考虑。因为二分搜索树的特性，父节点一定比所有左子节点大，比所有右子节点小。那么当需要删除父节点时，势必需要拿出一个比父节点大的节点来替换父节点。这个节点肯定不存在于左子树，必然存在于右子树。然后又需要保持父节点都是比右子节点小的，那么就可以取出右子树中最小的那个节点来替换父节点</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">delect(v) &#123;</span><br><span class="line">  <span class="keyword">this</span>.root = <span class="keyword">this</span>._delect(<span class="keyword">this</span>.root, v)</span><br><span class="line">&#125;</span><br><span class="line">_delect(node, v) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  <span class="comment">// 寻找的节点比当前节点小，去左子树找</span></span><br><span class="line">  <span class="keyword">if</span> (node.value &lt; v) &#123;</span><br><span class="line">    node.right = <span class="keyword">this</span>._delect(node.right, v)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.value &gt; v) &#123;</span><br><span class="line">    <span class="comment">// 寻找的节点比当前节点大，去右子树找</span></span><br><span class="line">    node.left = <span class="keyword">this</span>._delect(node.left, v)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 进入这个条件说明已经找到节点</span></span><br><span class="line">    <span class="comment">// 先判断节点是否拥有拥有左右子树中的一个</span></span><br><span class="line">    <span class="comment">// 是的话，将子树返回出去，这里和 `_delectMin` 的操作一样</span></span><br><span class="line">    <span class="keyword">if</span> (!node.left) <span class="keyword">return</span> node.right</span><br><span class="line">    <span class="keyword">if</span> (!node.right) <span class="keyword">return</span> node.left</span><br><span class="line">    <span class="comment">// 进入这里，代表节点拥有左右子树</span></span><br><span class="line">    <span class="comment">// 先取出当前节点的后继结点，也就是取当前节点右子树的最小值</span></span><br><span class="line">    <span class="keyword">let</span> min = <span class="keyword">this</span>._getMin(node.right)</span><br><span class="line">    <span class="comment">// 取出最小值后，删除最小值</span></span><br><span class="line">    <span class="comment">// 然后把删除节点后的子树赋值给最小值节点</span></span><br><span class="line">    min.right = <span class="keyword">this</span>._delectMin(node.right)</span><br><span class="line">    <span class="comment">// 左子树不动</span></span><br><span class="line">    min.left = node.left</span><br><span class="line">    node = min</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 维护 size</span></span><br><span class="line">  node.size = <span class="keyword">this</span>._getSize(node.left) + <span class="keyword">this</span>._getSize(node.right) + <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-堆"><a href="#2-5-堆" class="headerlink" title="2.5 堆"></a>2.5 堆</h3><p><strong>概念</strong></p><ul><li>堆通常是一个可以被看做一棵树的数组对象。</li><li>堆的实现通过构造二叉堆，实为二叉树的一种。这种数据结构具有以下性质。</li><li>任意节点小于（或大于）它的所有子节点<br>堆总是一棵完全树。即除了最底层，其他层的节点都被元素填满，且最底层从左到右填入。</li><li>将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。</li><li>优先队列也完全可以用堆来实现，操作是一模一样的。</li></ul><p><strong>实现大根堆</strong></p><blockquote><p>堆的每个节点的左边子节点索引是 <code>i * 2 + 1</code>，右边是 <code>i * 2 + 2</code>，父节点是 <code>(i - 1) /2</code>。</p></blockquote><ul><li>堆有两个核心的操作，分别是 <code>shiftUp</code> 和 <code>shiftDown</code> 。前者用于添加元素，后者用于删除根节点。</li><li><code>shiftUp</code> 的核心思路是一路将节点与父节点对比大小，如果比父节点大，就和父节点交换位置。</li><li><code>shiftDown</code> 的核心思路是先将根节点和末尾交换位置，然后移除末尾元素。接下来循环判断父节点和两个子节点的大小，如果子节点大，就把最大的子节点和父节点交换</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/6/15/164009e58a5a21f8?w=537&h=394&f=png&s=77222" alt=""></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxHeap</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.heap = []</span><br><span class="line">  &#125;</span><br><span class="line">  size() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.heap.length</span><br><span class="line">  &#125;</span><br><span class="line">  empty() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size() == <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  add(item) &#123;</span><br><span class="line">    <span class="keyword">this</span>.heap.push(item)</span><br><span class="line">    <span class="keyword">this</span>._shiftUp(<span class="keyword">this</span>.size() - <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  removeMax() &#123;</span><br><span class="line">    <span class="keyword">this</span>._shiftDown(<span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  getParentIndex(k) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parseInt</span>((k - <span class="number">1</span>) / <span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  getLeftIndex(k) &#123;</span><br><span class="line">    <span class="keyword">return</span> k * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  _shiftUp(k) &#123;</span><br><span class="line">    <span class="comment">// 如果当前节点比父节点大，就交换</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>.heap[k] &gt; <span class="keyword">this</span>.heap[<span class="keyword">this</span>.getParentIndex(k)]) &#123;</span><br><span class="line">      <span class="keyword">this</span>._swap(k, <span class="keyword">this</span>.getParentIndex(k))</span><br><span class="line">      <span class="comment">// 将索引变成父节点</span></span><br><span class="line">      k = <span class="keyword">this</span>.getParentIndex(k)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  _shiftDown(k) &#123;</span><br><span class="line">    <span class="comment">// 交换首位并删除末尾</span></span><br><span class="line">    <span class="keyword">this</span>._swap(k, <span class="keyword">this</span>.size() - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">this</span>.heap.splice(<span class="keyword">this</span>.size() - <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 判断节点是否有左孩子，因为二叉堆的特性，有右必有左</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>.getLeftIndex(k) &lt; <span class="keyword">this</span>.size()) &#123;</span><br><span class="line">      <span class="keyword">let</span> j = <span class="keyword">this</span>.getLeftIndex(k)</span><br><span class="line">      <span class="comment">// 判断是否有右孩子，并且右孩子是否大于左孩子</span></span><br><span class="line">      <span class="keyword">if</span> (j + <span class="number">1</span> &lt; <span class="keyword">this</span>.size() &amp;&amp; <span class="keyword">this</span>.heap[j + <span class="number">1</span>] &gt; <span class="keyword">this</span>.heap[j]) j++</span><br><span class="line">      <span class="comment">// 判断父节点是否已经比子节点都大</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.heap[k] &gt;= <span class="keyword">this</span>.heap[j]) <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">this</span>._swap(k, j)</span><br><span class="line">      k = j</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  _swap(left, right) &#123;</span><br><span class="line">    <span class="keyword">let</span> rightValue = <span class="keyword">this</span>.heap[right]</span><br><span class="line">    <span class="keyword">this</span>.heap[right] = <span class="keyword">this</span>.heap[left]</span><br><span class="line">    <span class="keyword">this</span>.heap[left] = rightValue</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、算法"><a href="#三、算法" class="headerlink" title="三、算法"></a>三、算法</h2><h3 id="3-1-时间复杂度"><a href="#3-1-时间复杂度" class="headerlink" title="3.1 时间复杂度"></a>3.1 时间复杂度</h3><ul><li>通常使用最差的时间复杂度来衡量一个算法的好坏。</li><li>常数时间 <code>O(1)</code> 代表这个操作和数据量没关系，是一个固定时间的操作，比如说四则运算。</li><li>对于一个算法来说，可能会计算出如下操作次数 <code>aN +</code>1，<code>N</code> 代表数据量。那么该算法的时间复杂度就是 <code>O(N)</code>。因为我们在计算时间复杂度的时候，数据量通常是非常大的，这时候低阶项和常数项可以忽略不计。</li><li>当然可能会出现两个算法都是 <code>O(N)</code> 的时间复杂度，那么对比两个算法的好坏就要通过对比低阶项和常数项了</li></ul><h3 id="3-2-位运算"><a href="#3-2-位运算" class="headerlink" title="3.2 位运算"></a>3.2 位运算</h3><ul><li>位运算在算法中很有用，速度可以比四则运算快很多。</li><li>在学习位运算之前应该知道十进制如何转二进制，二进制如何转十进制。这里说明下简单的计算方式</li><li>十进制 <code>33</code> 可以看成是 <code>32 + 1</code> ，并且 <code>33</code> 应该是六位二进制的（因为 <code>33</code>近似 <code>32</code>，而 <code>32</code> 是 <code>2</code>的五次方，所以是六位），那么 十进制 <code>33</code> 就是 <code>100001</code> ，只要是 2 的次方，那么就是 <code>1</code>否则都为 <code>0</code><br>那么二进制 <code>100001</code> 同理，首位是 <code>2^5</code>，末位是 <code>2^0</code> ，相加得出 <code>33</code></li></ul><p><strong>左移 &lt;&lt;</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 &lt;&lt; 1 &#x2F;&#x2F; -&gt; 20</span><br></pre></td></tr></table></figure><blockquote><p>左移就是将二进制全部往左移动，<code>10</code>在二进制中表示为 <code>1010</code> ，左移一位后变成 <code>10100</code> ，转换为十进制也就是 <code>20</code>，所以基本可以把左移看成以下公式 <code>a * (2 ^ b)</code></p></blockquote><p><strong>算数右移 &gt;&gt;</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 &gt;&gt; 1 &#x2F;&#x2F; -&gt; 5</span><br></pre></td></tr></table></figure><ul><li>算数右移就是将二进制全部往右移动并去除多余的右边，10 在二进制中表示为 <code>1010</code> ，右移一位后变成 <code>101</code> ，转换为十进制也就是 <code>5</code>，所以基本可以把右移看成以下公式 <code>int v = a / (2 ^ b)</code></li><li>右移很好用，比如可以用在二分算法中取中间值</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">13 &gt;&gt; 1 &#x2F;&#x2F; -&gt; 6</span><br></pre></td></tr></table></figure><p><strong>按位操作</strong></p><ul><li><strong>按位与</strong></li></ul><blockquote><p>每一位都为 1，结果才为 1</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8 &amp; 7 &#x2F;&#x2F; -&gt; 0</span><br><span class="line">&#x2F;&#x2F; 1000 &amp; 0111 -&gt; 0000 -&gt; 0</span><br></pre></td></tr></table></figure><ul><li><strong>按位或</strong></li></ul><blockquote><p>其中一位为 1，结果就是 1</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8 | 7 &#x2F;&#x2F; -&gt; 15</span><br><span class="line">&#x2F;&#x2F; 1000 | 0111 -&gt; 1111 -&gt; 15</span><br></pre></td></tr></table></figure><ul><li><strong>按位异或</strong></li></ul><blockquote><p>每一位都不同，结果才为 1</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8 ^ 7 &#x2F;&#x2F; -&gt; 15</span><br><span class="line">8 ^ 8 &#x2F;&#x2F; -&gt; 0</span><br><span class="line">&#x2F;&#x2F; 1000 ^ 0111 -&gt; 1111 -&gt; 15</span><br><span class="line">&#x2F;&#x2F; 1000 ^ 1000 -&gt; 0000 -&gt; 0</span><br></pre></td></tr></table></figure><p><strong>面试题：两个数不使用四则运算得出和</strong></p><blockquote><p>这道题中可以按位异或，因为按位异或就是不进位加法，<code>8 ^ 8 = 0</code> 如果进位了，就是 <code>16</code> 了，所以我们只需要将两个数进行异或操作，然后进位。那么也就是说两个二进制都是 1 的位置，左边应该有一个进位 <code>1</code>，所以可以得出以下公式 <code>a + b = (a ^ b) + ((a &amp; b) &lt;&lt; 1)</code> ，然后通过迭代的方式模拟加法</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">return</span> b</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> a</span><br><span class="line">    <span class="keyword">let</span> newA = a ^ b</span><br><span class="line">    <span class="keyword">let</span> newB = (a &amp; b) &lt;&lt; <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> sum(newA, newB)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-排序"><a href="#3-3-排序" class="headerlink" title="3.3 排序"></a>3.3 排序</h3><p><strong>冒泡排序</strong></p><blockquote><p>冒泡排序的原理如下，从第一个元素开始，把当前元素和下一个索引元素进行比较。如果当前元素大，那么就交换位置，重复操作直到比较到最后一个元素，那么此时最后一个元素就是该数组中最大的数。下一轮重复以上操作，但是此时最后一个元素已经是最大数了，所以不需要再比较最后一个元素，只需要比较到 <code>length - 1</code> 的位置</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/4/12/162b895b452b306c?w=670&h=508&f=gif&s=282307" alt=""></p><blockquote><p>以下是实现该算法的代码</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubble</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  checkArray(array);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = array.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="comment">// 从 0 到 `length - 1` 遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) swap(array, j, j + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>该算法的操作次数是一个等差数列 <code>n + (n - 1) + (n - 2) + 1</code> ，去掉常数项以后得出时间复杂度是<code>O(n * n)</code></p></blockquote><p><strong>插入排序</strong></p><blockquote><p>入排序的原理如下。第一个元素默认是已排序元素，取出下一个元素和当前元素比较，如果当前元素大就交换位置。那么此时第一个元素就是当前的最小数，所以下次取出操作从第三个元素开始，向前对比，重复之前的操作</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/4/12/162b895c7e59dcd1?w=670&h=508&f=gif&s=609549" alt=""></p><p>以下是实现该算法的代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertion</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  checkArray(array);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; array[j] &gt; array[j + <span class="number">1</span>]; j--)</span><br><span class="line">      swap(array, j, j + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>该算法的操作次数是一个等差数列 <code>n + (n - 1) + (n - 2) + 1</code> ，去掉常数项以后得出时间复杂度是 <code>O(n * n)</code></p></blockquote><p><strong>选择排序</strong></p><blockquote><p>选择排序的原理如下。遍历数组，设置最小值的索引为 0，如果取出的值比当前最小值小，就替换最小值索引，遍历完成后，将第一个元素和最小值索引上的值交换。如上操作后，第一个元素就是数组中的最小值，下次遍历就可以从索引 1 开始重复上述操作</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/4/13/162bc8ea14567e2e?w=670&h=508&f=gif&s=965636" alt=""></p><p>以下是实现该算法的代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selection</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  checkArray(array);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> minIndex = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; array.length; j++) &#123;</span><br><span class="line">      minIndex = array[j] &lt; array[minIndex] ? j : minIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(array, i, minIndex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>该算法的操作次数是一个等差数列 <code>n + (n - 1) + (n - 2) + 1</code> ，去掉常数项以后得出时间复杂度是 <code>O(n * n)</code></p></blockquote><p><strong>归并排序</strong></p><blockquote><p>归并排序的原理如下。递归的将数组两两分开直到最多包含两个元素，然后将数组排序合并，最终合并为排序好的数组。假设我有一组数组 <code>[3, 1, 2, 8, 9, 7, 6]</code>，中间数索引是 3，先排序数组 <code>[3, 1, 2, 8]</code> 。在这个左边数组上，继续拆分直到变成数组包含两个元素（如果数组长度是奇数的话，会有一个拆分数组只包含一个元素）。然后排序数组 <code>[3, 1]</code> 和 <code>[2, 8]</code> ，然后再排序数组 <code>[1, 3, 2, 8]</code> ，这样左边数组就排序完成，然后按照以上思路排序右边数组，最后将数组 <code>[1, 2, 3, 8]</code> 和 <code>[6, 7, 9]</code> 排序</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/4/13/162be13c7e30bd86?w=896&h=1008&f=gif&s=937952" alt=""></p><p>以下是实现该算法的代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  checkArray(array);</span><br><span class="line">  mergeSort(array, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">array, left, right</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 左右索引相同说明已经只有一个数</span></span><br><span class="line">  <span class="keyword">if</span> (left === right) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 等同于 `left + (right - left) / 2`</span></span><br><span class="line">  <span class="comment">// 相比 `(left + right) / 2` 来说更加安全，不会溢出</span></span><br><span class="line">  <span class="comment">// 使用位运算是因为位运算比四则运算快</span></span><br><span class="line">  <span class="keyword">let</span> mid = <span class="built_in">parseInt</span>(left + ((right - left) &gt;&gt; <span class="number">1</span>));</span><br><span class="line">  mergeSort(array, left, mid);</span><br><span class="line">  mergeSort(array, mid + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> help = [];</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> p1 = left;</span><br><span class="line">  <span class="keyword">let</span> p2 = mid + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= right) &#123;</span><br><span class="line">    help[i++] = array[p1] &lt; array[p2] ? array[p1++] : array[p2++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (p1 &lt;= mid) &#123;</span><br><span class="line">    help[i++] = array[p1++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (p2 &lt;= right) &#123;</span><br><span class="line">    help[i++] = array[p2++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; help.length; i++) &#123;</span><br><span class="line">    array[left + i] = help[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以上算法使用了递归的思想。递归的本质就是压栈，每递归执行一次函数，就将该函数的信息（比如参数，内部的变量，执行到的行数）压栈，直到遇到终止条件，然后出栈并继续执行函数。对于以上递归函数的调用轨迹如下</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mergeSort(data, <span class="number">0</span>, <span class="number">6</span>) <span class="comment">// mid = 3</span></span><br><span class="line">  mergeSort(data, <span class="number">0</span>, <span class="number">3</span>) <span class="comment">// mid = 1</span></span><br><span class="line">    mergeSort(data, <span class="number">0</span>, <span class="number">1</span>) <span class="comment">// mid = 0</span></span><br><span class="line">      mergeSort(data, <span class="number">0</span>, <span class="number">0</span>) <span class="comment">// 遇到终止，回退到上一步</span></span><br><span class="line">    mergeSort(data, <span class="number">1</span>, <span class="number">1</span>) <span class="comment">// 遇到终止，回退到上一步</span></span><br><span class="line">    <span class="comment">// 排序 p1 = 0, p2 = mid + 1 = 1</span></span><br><span class="line">    <span class="comment">// 回退到 `mergeSort(data, 0, 3)` 执行下一个递归</span></span><br><span class="line">  mergeSort(<span class="number">2</span>, <span class="number">3</span>) <span class="comment">// mid = 2</span></span><br><span class="line">    mergeSort(<span class="number">3</span>, <span class="number">3</span>) <span class="comment">// 遇到终止，回退到上一步</span></span><br><span class="line">  <span class="comment">// 排序 p1 = 2, p2 = mid + 1 = 3</span></span><br><span class="line">  <span class="comment">// 回退到 `mergeSort(data, 0, 3)` 执行合并逻辑</span></span><br><span class="line">  <span class="comment">// 排序 p1 = 0, p2 = mid + 1 = 2</span></span><br><span class="line">  <span class="comment">// 执行完毕回退</span></span><br><span class="line">  <span class="comment">// 左边数组排序完毕，右边也是如上轨迹</span></span><br></pre></td></tr></table></figure><blockquote><p>该算法的操作次数是可以这样计算：递归了两次，每次数据量是数组的一半，并且最后把整个数组迭代了一次，所以得出表达式 <code>2T(N / 2) + T(N)</code> （<code>T</code> 代表时间，<code>N</code> 代表数据量）。根据该表达式可以套用 该公式 得出时间复杂度为 <code>O(N * logN)</code></p></blockquote><p><strong>快排</strong></p><blockquote><p>快排的原理如下。随机选取一个数组中的值作为基准值，从左至右取值与基准值对比大小。比基准值小的放数组左边，大的放右边，对比完成后将基准值和第一个比基准值大的值交换位置。然后将数组以基准值的位置分为两部分，继续递归以上操作。</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/4/16/162cd23e69ca9ea3?w=824&h=506&f=gif&s=867744" alt=""></p><p>以下是实现该算法的代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  checkArray(array);</span><br><span class="line">  quickSort(array, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">array, left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">    swap(array, , right)</span><br><span class="line">    <span class="comment">// 随机取值，然后和末尾交换，这样做比固定取一个位置的复杂度略低</span></span><br><span class="line">    <span class="keyword">let</span> indexs = part(array, <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * (right - left + <span class="number">1</span>)) + left, right);</span><br><span class="line">    quickSort(array, left, indexs[<span class="number">0</span>]);</span><br><span class="line">    quickSort(array, indexs[<span class="number">1</span>] + <span class="number">1</span>, right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">part</span>(<span class="params">array, left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> less = left - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> more = right;</span><br><span class="line">  <span class="keyword">while</span> (left &lt; more) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array[left] &lt; array[right]) &#123;</span><br><span class="line">      <span class="comment">// 当前值比基准值小，`less` 和 `left` 都加一</span></span><br><span class="line">   ++less;</span><br><span class="line">       ++left;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[left] &gt; array[right]) &#123;</span><br><span class="line">      <span class="comment">// 当前值比基准值大，将当前值和右边的值交换</span></span><br><span class="line">      <span class="comment">// 并且不改变 `left`，因为当前换过来的值还没有判断过大小</span></span><br><span class="line">      swap(array, --more, left);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 和基准值相同，只移动下标</span></span><br><span class="line">      left++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将基准值和比基准值大的第一个值交换位置</span></span><br><span class="line">  <span class="comment">// 这样数组就变成 `[比基准值小, 基准值, 比基准值大]`</span></span><br><span class="line">  swap(array, right, more);</span><br><span class="line">  <span class="keyword">return</span> [less, more];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>该算法的复杂度和归并排序是相同的，但是额外空间复杂度比归并排序少，只需 <code>O(logN)</code>，并且相比归并排序来说，所需的常数时间也更少</p></blockquote><p><strong>面试题</strong></p><blockquote><p>Sort Colors：该题目来自 LeetCode，题目需要我们将 <code>[2,0,2,1,1,0]</code> 排序成 <code>[0,0,1,1,2,2]</code>，这个问题就可以使用三路快排的思想</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sortColors = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">let</span> right = nums.length;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 下标如果遇到 right，说明已经排序完成</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt; right) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">      swap(nums, i++, ++left);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] == <span class="number">1</span>) &#123;</span><br><span class="line">      i++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      swap(nums, i, --right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-4-链表"><a href="#3-4-链表" class="headerlink" title="3.4 链表"></a>3.4 链表</h3><p><strong>反转单向链表</strong></p><blockquote><p>该题目来自 LeetCode，题目需要将一个单向链表反转。思路很简单，使用三个变量分别表示当前节点和当前节点的前后节点，虽然这题很简单，但是却是一道面试常考题</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseList = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判断下变量边界问题</span></span><br><span class="line">    <span class="keyword">if</span> (!head || !head.next) <span class="keyword">return</span> head</span><br><span class="line">    <span class="comment">// 初始设置为空，因为第一个节点反转后就是尾部，尾部节点指向 null</span></span><br><span class="line">    <span class="keyword">let</span> pre = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> current = head</span><br><span class="line">    <span class="keyword">let</span> next</span><br><span class="line">    <span class="comment">// 判断当前节点是否为空</span></span><br><span class="line">    <span class="comment">// 不为空就先获取当前节点的下一节点</span></span><br><span class="line">    <span class="comment">// 然后把当前节点的 next 设为上一个节点</span></span><br><span class="line">    <span class="comment">// 然后把 current 设为下一个节点，pre 设为当前节点</span></span><br><span class="line">    <span class="keyword">while</span>(current) &#123;</span><br><span class="line">        next = current.next</span><br><span class="line">        current.next = pre</span><br><span class="line">        pre = current</span><br><span class="line">        current = next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-5-树"><a href="#3-5-树" class="headerlink" title="3.5 树"></a>3.5 树</h3><p><strong>二叉树的先序，中序，后序遍历</strong></p><ul><li>先序遍历表示先访问根节点，然后访问左节点，最后访问右节点。</li><li>中序遍历表示先访问左节点，然后访问根节点，最后访问右节点。</li><li>后序遍历表示先访问左节点，然后访问右节点，最后访问根节点</li></ul><p><strong>递归实现</strong></p><p>递归实现相当简单，代码如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TreeNode</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.val = val;</span><br><span class="line">  <span class="keyword">this</span>.left = <span class="keyword">this</span>.right = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> traversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root) &#123;</span><br><span class="line">    <span class="comment">// 先序</span></span><br><span class="line">    <span class="built_in">console</span>.log(root);</span><br><span class="line">    traversal(root.left);</span><br><span class="line">    <span class="comment">// 中序</span></span><br><span class="line">    <span class="comment">// console.log(root);</span></span><br><span class="line">    traversal(root.right);</span><br><span class="line">    <span class="comment">// 后序</span></span><br><span class="line">    <span class="comment">// console.log(root);</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>对于递归的实现来说，只需要理解每个节点都会被访问三次就明白为什么这样实现了</p></blockquote><p><strong>非递归实现</strong></p><blockquote><p>非递归实现使用了栈的结构，通过栈的先进后出模拟递归实现。</p></blockquote><p>以下是先序遍历代码实现</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pre</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root) &#123;</span><br><span class="line">    <span class="keyword">let</span> stack = [];</span><br><span class="line">    <span class="comment">// 先将根节点 push</span></span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="comment">// 判断栈中是否为空</span></span><br><span class="line">    <span class="keyword">while</span> (stack.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 弹出栈顶元素</span></span><br><span class="line">      root = stack.pop();</span><br><span class="line">      <span class="built_in">console</span>.log(root);</span><br><span class="line">      <span class="comment">// 因为先序遍历是先左后右，栈是先进后出结构</span></span><br><span class="line">      <span class="comment">// 所以先 push 右边再 push 左边</span></span><br><span class="line">      <span class="keyword">if</span> (root.right) &#123;</span><br><span class="line">        stack.push(root.right);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (root.left) &#123;</span><br><span class="line">        stack.push(root.left);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是中序遍历代码实现</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mid</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root) &#123;</span><br><span class="line">    <span class="keyword">let</span> stack = [];</span><br><span class="line">    <span class="comment">// 中序遍历是先左再根最后右</span></span><br><span class="line">    <span class="comment">// 所以首先应该先把最左边节点遍历到底依次 push 进栈</span></span><br><span class="line">    <span class="comment">// 当左边没有节点时，就打印栈顶元素，然后寻找右节点</span></span><br><span class="line">    <span class="comment">// 对于最左边的叶节点来说，可以把它看成是两个 null 节点的父节点</span></span><br><span class="line">    <span class="comment">// 左边打印不出东西就把父节点拿出来打印，然后再看右节点</span></span><br><span class="line">    <span class="keyword">while</span> (stack.length &gt; <span class="number">0</span> || root) &#123;</span><br><span class="line">      <span class="keyword">if</span> (root) &#123;</span><br><span class="line">        stack.push(root);</span><br><span class="line">        root = root.left;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        root = stack.pop();</span><br><span class="line">        <span class="built_in">console</span>.log(root);</span><br><span class="line">        root = root.right;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以下是后序遍历代码实现，该代码使用了两个栈来实现遍历，相比一个栈的遍历来说要容易理解很多</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pos</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root) &#123;</span><br><span class="line">    <span class="keyword">let</span> stack1 = [];</span><br><span class="line">    <span class="keyword">let</span> stack2 = [];</span><br><span class="line">    <span class="comment">// 后序遍历是先左再右最后根</span></span><br><span class="line"><span class="comment">// 所以对于一个栈来说，应该先 push 根节点</span></span><br><span class="line">    <span class="comment">// 然后 push 右节点，最后 push 左节点</span></span><br><span class="line">    stack1.push(root);</span><br><span class="line">    <span class="keyword">while</span> (stack1.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      root = stack1.pop();</span><br><span class="line">      stack2.push(root);</span><br><span class="line">      <span class="keyword">if</span> (root.left) &#123;</span><br><span class="line">        stack1.push(root.left);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (root.right) &#123;</span><br><span class="line">        stack1.push(root.right);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (stack2.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(s2.pop());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>中序遍历的前驱后继节点</strong></p><blockquote><p>实现这个算法的前提是节点有一个 <code>parent</code> 的指针指向父节点，根节点指向 <code>null</code></p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/4/24/162f61ad8e8588b7?w=682&h=486&f=png&s=41027" alt=""></p><blockquote><p>如图所示，该树的中序遍历结果是 <code>4, 2, 5, 1, 6, 3, 7</code></p></blockquote><p><strong>前驱节点</strong></p><blockquote><p>对于节点 2 来说，他的前驱节点就是 4 ，按照中序遍历原则，可以得出以下结论</p></blockquote><ul><li>如果选取的节点的左节点不为空，就找该左节点最右的节点。对于节点 1 来说，他有左节点 2 ，那么节点 2 的最右节点就是 5</li><li>如果左节点为空，且目标节点是父节点的右节点，那么前驱节点为父节点。对于节点 5 来说，没有左节点，且是节点 2 的右节点，所以节点 2 是前驱节点</li><li>如果左节点为空，且目标节点是父节点的左节点，向上寻找到第一个是父节点的右节点的节点。对于节点 6 来说，没有左节点，且是节点 3 的左节点，所以向上寻找到节点 1 ，发现节点 3 是节点 1 的右节点，所以节点 1 是节点 6 的前驱节点</li></ul><p>以下是算法实现</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">predecessor</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span></span><br><span class="line">  <span class="comment">// 结论 1</span></span><br><span class="line">  <span class="keyword">if</span> (node.left) &#123;</span><br><span class="line">    <span class="keyword">return</span> getRight(node.left)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> parent = node.parent</span><br><span class="line">    <span class="comment">// 结论 2 3 的判断</span></span><br><span class="line">    <span class="keyword">while</span>(parent &amp;&amp; parent.right === node) &#123;</span><br><span class="line">      node = parent</span><br><span class="line">      parent = node.parent</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parent</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRight</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span></span><br><span class="line">  node = node.right</span><br><span class="line">  <span class="keyword">while</span>(node) node = node.right</span><br><span class="line">  <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>后继节点</strong></p><blockquote><p>对于节点 2 来说，他的后继节点就是 5 ，按照中序遍历原则，可以得出以下结论</p></blockquote><ul><li>如果有右节点，就找到该右节点的最左节点。对于节点 1 来说，他有右节点 3 ，那么节点 3 的最左节点就是 6</li><li>如果没有右节点，就向上遍历直到找到一个节点是父节点的左节点。对于节点 5 来说，没有右节点，就向上寻找到节点 2 ，该节点是父节点 1 的左节点，所以节点 1 是后继节点<br>以下是算法实现</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">successor</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span></span><br><span class="line">  <span class="comment">// 结论 1</span></span><br><span class="line">  <span class="keyword">if</span> (node.right) &#123;</span><br><span class="line">    <span class="keyword">return</span> getLeft(node.right)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 结论 2</span></span><br><span class="line">    <span class="keyword">let</span> parent = node.parent</span><br><span class="line">    <span class="comment">// 判断 parent 为空</span></span><br><span class="line">    <span class="keyword">while</span>(parent &amp;&amp; parent.left === node) &#123;</span><br><span class="line">      node = parent</span><br><span class="line">      parent = node.parent</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parent</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLeft</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span></span><br><span class="line">  node = node.left</span><br><span class="line">  <span class="keyword">while</span>(node) node = node.left</span><br><span class="line">  <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>树的深度</strong></p><blockquote><p>树的最大深度：该题目来自 Leetcode，题目需要求出一颗二叉树的最大深度</p></blockquote><p>以下是算法实现</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maxDepth = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>对于该递归函数可以这样理解：一旦没有找到节点就会返回 0，每弹出一次递归函数就会加一，树有三层就会得到3</p></blockquote><script>export default {  mounted () {    var script = document.createElement("script");    script.type = "text/javascript"    script.charset="UTF-8"    script.src = "http://tajs.qq.com/stats?sId=59154049"    document.body.appendChild(script);  }}</script>]]></content>
      
      
      <categories>
          
          <category> 资料整理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript知识 - 浏览器</title>
      <link href="/2017/06/26/JavaScript%E7%9F%A5%E8%AF%86%20-%20%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
      <url>/2017/06/26/JavaScript%E7%9F%A5%E8%AF%86%20-%20%E6%B5%8F%E8%A7%88%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h5 id="JavaScript知识-浏览器"><a href="#JavaScript知识-浏览器" class="headerlink" title="JavaScript知识 - 浏览器"></a>JavaScript知识 - 浏览器</h5><p>JavaScript资料整理</p><a id="more"></a><h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><h3 id="1-事件机制"><a href="#1-事件机制" class="headerlink" title="1 事件机制"></a>1 事件机制</h3><p><strong>事件触发三阶段</strong></p><ul><li><code>document</code> 往事件触发处传播，遇到注册的捕获事件会触发</li><li>传播到事件触发处时触发注册的事件</li><li>从事件触发处往 <code>document</code> 传播，遇到注册的冒泡事件会触发</li></ul><blockquote><p>事件触发一般来说会按照上面的顺序进行，但是也有特例，如果给一个目标节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下会先打印冒泡然后是捕获</span></span><br><span class="line">node.addEventListener(<span class="string">'click'</span>,(event) =&gt;&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'冒泡'</span>)</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br><span class="line">node.addEventListener(<span class="string">'click'</span>,(event) =&gt;&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'捕获 '</span>)</span><br><span class="line">&#125;,<span class="literal">true</span>)</span><br></pre></td></tr></table></figure><p><strong>注册事件</strong></p><ul><li>通常我们使用 <code>addEventListener</code> 注册事件，该函数的第三个参数可以是布尔值，也可以是对象。对于布尔值 <code>useCapture</code> 参数来说，该参数默认值为 <code>false</code> 。<code>useCapture</code> 决定了注册的事件是捕获事件还是冒泡事件</li><li>一般来说，我们只希望事件只触发在目标上，这时候可以使用 <code>stopPropagation</code> 来阻止事件的进一步传播。通常我们认为 <code>stopPropagation</code> 是用来阻止事件冒泡的，其实该函数也可以阻止捕获事件。<code>stopImmediatePropagation</code> 同样也能实现阻止事件，但是还能阻止该事件目标执行别的注册事件</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">node.addEventListener(<span class="string">'click'</span>,(event) =&gt;&#123;</span><br><span class="line">event.stopImmediatePropagation()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'冒泡'</span>)</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br><span class="line"><span class="comment">// 点击 node 只会执行上面的函数，该函数不会执行</span></span><br><span class="line">node.addEventListener(<span class="string">'click'</span>,(event) =&gt; &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'捕获 '</span>)</span><br><span class="line">&#125;,<span class="literal">true</span>)</span><br></pre></td></tr></table></figure><p><strong>事件代理</strong></p><blockquote><p>如果一个节点中的子节点是动态生成的，那么子节点需要注册事件的话应该注册在父节点上</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"ul"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">'##ul'</span>)</span></span><br><span class="line"><span class="actionscript">ul.addEventListener(<span class="string">'click'</span>, (event) =&gt; &#123;</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(event.target);</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>事件代理的方式相对于直接给目标注册事件来说，有以下优点</p></blockquote><ul><li>节省内存</li><li>不需要给子节点注销事件</li></ul><h3 id="2-跨域"><a href="#2-跨域" class="headerlink" title="2 跨域"></a>2 跨域</h3><blockquote><p>因为浏览器出于安全考虑，有同源策略。也就是说，如果协议、域名或者端口有一个不同就是跨域，<code>Ajax</code> 请求会失败</p></blockquote><p><strong>JSONP</strong></p><blockquote><p><code>JSONP</code> 的原理很简单，就是利用 <code>&lt;script&gt;</code> 标签没有跨域限制的漏洞。通过 <code>&lt;script&gt;</code> 标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://domain/api?param1=a&amp;param2=b&amp;callback=jsonp"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">jsonp</span><span class="params">(data)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(data)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>JSONP</code> 使用简单且兼容性不错，但是只限于 <code>get</code> 请求</li></ul><p><strong>CORS</strong></p><ul><li><code>CORS</code>需要浏览器和后端同时支持</li><li>浏览器会自动进行 <code>CORS</code> 通信，实现<code>CORS</code>通信的关键是后端。只要后端实现了 <code>CORS</code>，就实现了跨域。</li><li>服务端设置 <code>Access-Control-Allow-Origin</code> 就可以开启 <code>CORS</code>。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源</li></ul><p><strong>document.domain</strong></p><ul><li>该方式只能用于二级域名相同的情况下，比如 <code>a.test.com</code> 和 <code>b.test.com</code> 适用于该方式。</li><li>只需要给页面添加 <code>document.domain = &#39;test.com&#39;</code> 表示二级域名都相同就可以实现跨域</li></ul><p><strong>postMessage</strong></p><blockquote><p>这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发送消息端</span></span><br><span class="line"><span class="built_in">window</span>.parent.postMessage(<span class="string">'message'</span>, <span class="string">'http://blog.poetries.com'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收消息端</span></span><br><span class="line"><span class="keyword">var</span> mc = <span class="keyword">new</span> MessageChannel();</span><br><span class="line">mc.addEventListener(<span class="string">'message'</span>, (event) =&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> origin = event.origin || event.originalEvent.origin;</span><br><span class="line">    <span class="keyword">if</span> (origin === <span class="string">'http://blog.poetries.com'</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'验证通过'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="3-Event-loop"><a href="#3-Event-loop" class="headerlink" title="3 Event loop"></a>3 Event loop</h3><p><strong>JS中的event loop</strong></p><blockquote><p>众所周知 <code>JS</code> 是门非阻塞单线程语言，因为在最初 <code>JS</code> 就是为了和浏览器交互而诞生的。如果 <code>JS</code> 是门多线程的语言话，我们在多个线程中处理 <code>DOM</code> 就可能会发生问题（一个线程中新加节点，另一个线程中删除节点）</p></blockquote><ul><li><code>JS</code> 在执行的过程中会产生执行环境，这些执行环境会被顺序的加入到执行栈中。如果遇到异步的代码，会被挂起并加入到 <code>Task</code>（有多种 <code>task</code>） 队列中。一旦执行栈为空，<code>Event</code> <code>Loop</code> 就会从 <code>Task</code> 队列中拿出需要执行的代码并放入执行栈中执行，所以本质上来说 <code>JS</code> 中的异步还是同步行为</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>);</span><br></pre></td></tr></table></figure><blockquote><p>不同的任务源会被分配到不同的 <code>Task</code> 队列中，任务源可以分为 微任务（<code>microtask</code>） 和 宏任务（<code>macrotask</code>）。在 <code>ES6</code> 规范中，<code>microtask</code> 称为 jobs，macrotask 称为 task</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Promise'</span>)</span><br><span class="line">    resolve()</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise2'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>);</span><br><span class="line"><span class="comment">// script start =&gt; Promise =&gt; script end =&gt; promise1 =&gt; promise2 =&gt; setTimeout</span></span><br></pre></td></tr></table></figure><blockquote><p>以上代码虽然 <code>setTimeout</code> 写在 <code>Promise</code> 之前，但是因为 <code>Promise</code> 属于微任务而 <code>setTimeout</code> 属于宏任务</p></blockquote><p><strong>微任务</strong></p><ul><li><code>process.nextTick</code></li><li><code>promise</code></li><li><code>Object.observe</code></li><li><code>MutationObserver</code></li></ul><p><strong>宏任务</strong></p><ul><li><code>script</code></li><li><code>setTimeout</code></li><li><code>setInterval</code></li><li><code>setImmediate</code></li><li><code>I/O</code></li><li><code>UI rendering</code></li></ul><blockquote><p>宏任务中包括了 <code>script</code> ，浏览器会先执行一个宏任务，接下来有异步代码的话就先执行微任务</p></blockquote><p><strong>所以正确的一次 Event loop 顺序是这样的</strong></p><ul><li>执行同步代码，这属于宏任务</li><li>执行栈为空，查询是否有微任务需要执行</li><li>执行所有微任务</li><li>必要的话渲染 UI</li><li>然后开始下一轮 <code>Event loop</code>，执行宏任务中的异步代码</li></ul><blockquote><p>通过上述的 <code>Event loop</code> 顺序可知，如果宏任务中的异步代码有大量的计算并且需要操作 <code>DOM</code> 的话，为了更快的响应界面响应，我们可以把操作 <code>DOM</code> 放入微任务中</p></blockquote><p><strong>Node 中的 Event loop</strong></p><ul><li><code>Node</code> 中的 <code>Event loop</code> 和浏览器中的不相同。</li><li><code>Node</code> 的 <code>Event loop</code> 分为<code>6</code>个阶段，它们会按照顺序反复运行</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">┌───────────────────────┐</span><br><span class="line">┌─&gt;│        timers         │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     I/O callbacks     │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     idle, prepare     │</span><br><span class="line">│  └──────────┬────────────┘      ┌───────────────┐</span><br><span class="line">│  ┌──────────┴────────────┐      │   incoming:   │</span><br><span class="line">│  │         poll          │&lt;──connections───     │</span><br><span class="line">│  └──────────┬────────────┘      │   data, etc.  │</span><br><span class="line">│  ┌──────────┴────────────┐      └───────────────┘</span><br><span class="line">│  │        check          │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">└──┤    close callbacks    │</span><br><span class="line">   └───────────────────────┘</span><br></pre></td></tr></table></figure><p><strong>timer</strong></p><ul><li><code>timers</code> 阶段会执行 <code>setTimeout</code> 和 <code>setInterval</code></li><li>一个 timer 指定的时间并不是准确时间，而是在达到这个时间后尽快执行回调，可能会因为系统正在执行别的事务而延迟</li></ul><p><strong>I/O</strong></p><ul><li><code>I/O</code> 阶段会执行除了 <code>close</code> 事件，定时器和 <code>setImmediate</code> 的回调</li></ul><p><strong>poll</strong></p><ul><li><code>poll</code> 阶段很重要，这一阶段中，系统会做两件事情<ul><li>执行到点的定时器</li><li>执行 <code>poll</code> 队列中的事件</li></ul></li><li>并且当 <code>poll</code> 中没有定时器的情况下，会发现以下两件事情<ul><li>如果 <code>poll</code> 队列不为空，会遍历回调队列并同步执行，直到队列为空或者系统限制</li><li>如果 <code>poll</code> 队列为空，会有两件事发生</li><li>如果有 <code>setImmediate</code> 需要执行，<code>poll</code> 阶段会停止并且进入到 <code>check</code> 阶段执行 <code>setImmediate</code></li><li>如果没有 <code>setImmediate</code> 需要执行，会等待回调被加入到队列中并立即执行回调</li><li>如果有别的定时器需要被执行，会回到 <code>timer</code> 阶段执行回调。</li></ul></li></ul><p><strong>check</strong></p><ul><li><code>check</code> 阶段执行 <code>setImmediate</code></li></ul><p><strong>close callbacks</strong></p><ul><li><code>close callbacks</code> 阶段执行 <code>close</code> 事件</li><li>并且在 <code>Node</code> 中，有些情况下的定时器执行顺序是随机的</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line">setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setImmediate'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 这里可能会输出 setTimeout，setImmediate</span></span><br><span class="line"><span class="comment">// 可能也会相反的输出，这取决于性能</span></span><br><span class="line"><span class="comment">// 因为可能进入 event loop 用了不到 1 毫秒，这时候会执行 setImmediate</span></span><br><span class="line"><span class="comment">// 否则会执行 setTimeout</span></span><br></pre></td></tr></table></figure><blockquote><p>上面介绍的都是 <code>macrotask</code> 的执行情况，<code>microtask</code> 会在以上每个阶段完成后立即执行</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timer1'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timer2'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'promise2'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上代码在浏览器和 node 中打印情况是不同的</span></span><br><span class="line"><span class="comment">// 浏览器中一定打印 timer1, promise1, timer2, promise2</span></span><br><span class="line"><span class="comment">// node 中可能打印 timer1, timer2, promise1, promise2</span></span><br><span class="line"><span class="comment">// 也可能打印 timer1, promise1, timer2, promise2</span></span><br></pre></td></tr></table></figure><blockquote><p><code>Node</code> 中的 <code>process.nextTick</code> 会先于其他 <code>microtask</code> 执行</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">"timer1"</span>);</span><br><span class="line"></span><br><span class="line"> <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"promise1"</span>);</span><br><span class="line"> &#125;);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">"nextTick"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// nextTick, timer1, promise1</span></span><br></pre></td></tr></table></figure><h3 id="4-Service-Worker"><a href="#4-Service-Worker" class="headerlink" title="4 Service Worker"></a>4 Service Worker</h3><blockquote><p><code>Service workers</code> 本质上充当Web应用程序与浏览器之间的代理服务器，也可以在网络可用时作为浏览器和网络间的代理。它们旨在（除其他之外）使得能够创建有效的离线体验，拦截网络请求并基于网络是否可用以及更新的资源是否驻留在服务器上来采取适当的动作。他们还允许访问推送通知和后台同步API</p></blockquote><p><strong>目前该技术通常用来做缓存文件，提高首屏速度</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">if</span> (navigator.serviceWorker) &#123;</span><br><span class="line">  navigator.serviceWorker</span><br><span class="line">    .register(<span class="string">"sw.js"</span>)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">registration</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"service worker 注册成功"</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"servcie worker 注册失败"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// sw.js</span></span><br><span class="line"><span class="comment">// 监听 `install` 事件，回调中缓存所需文件</span></span><br><span class="line">self.addEventListener(<span class="string">"install"</span>, e =&gt; &#123;</span><br><span class="line">  e.waitUntil(</span><br><span class="line">    caches.open(<span class="string">"my-cache"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> cache.addAll([<span class="string">"./index.html"</span>, <span class="string">"./index.js"</span>]);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拦截所有请求事件</span></span><br><span class="line"><span class="comment">// 如果缓存中已经有请求的数据就直接用缓存，否则去请求数据</span></span><br><span class="line">self.addEventListener(<span class="string">"fetch"</span>, e =&gt; &#123;</span><br><span class="line">  e.respondWith(</span><br><span class="line">    caches.match(e.request).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (response) &#123;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"fetch source"</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>打开页面，可以在开发者工具中的 <code>Application</code> 看到 <code>Service Worker</code> 已经启动了</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/3/28/1626b1e8eba68e1c?w=1770&h=722&f=png&s=192277" alt=""></p><blockquote><p>在 Cache 中也可以发现我们所需的文件已被缓存</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/3/28/1626b20dfc4fcd26?w=1118&h=728&f=png&s=85610" alt=""></p><blockquote><p>当我们重新刷新页面可以发现我们缓存的数据是从 <code>Service</code> <code>Worker</code> 中读取的</p></blockquote><h3 id="5-渲染机制"><a href="#5-渲染机制" class="headerlink" title="5 渲染机制"></a>5 渲染机制</h3><p><strong>浏览器的渲染机制一般分为以下几个步骤</strong></p><ul><li>处理 <code>HTML</code> 并构建 <code>DOM</code> 树。</li><li>处理 <code>CSS</code> 构建 <code>CSSOM</code> 树。</li><li>将 <code>DOM</code> 与 <code>CSSOM</code> 合并成一个渲染树。</li><li>根据渲染树来布局，计算每个节点的位置。</li><li>调用 <code>GPU</code> 绘制，合成图层，显示在屏幕上</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/4/11/162b2ab2ec70ac5b?w=900&h=352&f=png&s=49983" alt=""></p><ul><li>在构建 CSSOM 树时，会阻塞渲染，直至 CSSOM 树构建完成。并且构建 CSSOM 树是一个十分消耗性能的过程，所以应该尽量保证层级扁平，减少过度层叠，越是具体的 CSS 选择器，执行速度越慢</li><li>当 HTML 解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件。并且 CSS 也会影响 JS 的执行，只有当解析完样式表才会执行 JS，所以也可以认为这种情况下，CSS 也会暂停构建 DOM</li></ul><p><strong>图层</strong></p><blockquote><p>一般来说，可以把普通文档流看成一个图层。特定的属性可以生成一个新的图层。不同的图层渲染互不影响，所以对于某些频繁需要渲染的建议单独生成一个新图层，提高性能。但也不能生成过多的图层，会引起反作用</p></blockquote><ul><li>通过以下几个常用属性可以生成新图层<ul><li><code>3D</code>变换：<code>translate3d</code>、<code>translateZ</code></li><li><code>will-change</code></li><li><code>video</code>、<code>iframe</code> 标签</li><li>通过动画实现的 <code>opacity</code> 动画转换</li><li><code>position: fixed</code></li></ul></li></ul><p><strong>重绘（Repaint）和回流（Reflow）</strong></p><ul><li>重绘是当节点需要更改外观而不会影响布局的，比如改变 <code>color</code> 就叫称为重绘</li><li>回流是布局或者几何属性需要改变就称为回流</li></ul><blockquote><p>回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变深层次的节点很可能导致父节点的一系列回流</p></blockquote><ul><li><strong>所以以下几个动作可能会导致性能问题</strong>：<ul><li>改变 <code>window</code> 大小</li><li>改变字体</li><li>添加或删除样式</li><li>文字改变</li><li>定位或者浮动</li><li>盒模型</li></ul></li></ul><p><strong>很多人不知道的是，重绘和回流其实和 <code>Event loop</code> 有关</strong></p><ul><li>当 <code>Event loop</code> 执行完 <code>Microtasks</code> 后，会判断 <code>document</code> 是否需要更新。因为浏览器是 <code>60Hz</code>的刷新率，每 <code>16ms</code>才会更新一次。</li><li>然后判断是否有 <code>resize</code> 或者 <code>scroll</code> ，有的话会去触发事件，所以 <code>resize</code> 和 <code>scroll</code> 事件也是至少 <code>16ms</code> 才会触发一次，并且自带节流功能。</li><li>判断是否触发了<code>media query</code></li><li>更新动画并且发送事件</li><li>判断是否有全屏操作事件</li><li>执行 <code>requestAnimationFrame</code> 回调</li><li>执行 <code>IntersectionObserver</code> 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好</li><li>更新界面</li><li>以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 <code>requestIdleCallback</code> 回调</li></ul><p><strong>减少重绘和回流</strong></p><ul><li>使用 <code>translate</code> 替代 <code>top</code></li><li>使用 <code>visibility</code> 替换<code>display: none</code> ，因为前者只会引起重绘，后者会引发回流（改变了布局）</li><li>不要使用 <code>table</code> 布局，可能很小的一个小改动会造成整个 table 的重新布局</li><li>动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 <code>requestAnimationFrame</code></li><li><code>CSS</code> 选择符从右往左匹配查找，避免 <code>DOM</code> 深度过深</li><li>将频繁运行的动画变为图层，图层能够阻止该节点回流影响别的元素。比如对于 <code>video</code>标签，浏览器会自动将该节点变为图层</li></ul>]]></content>
      
      
      <categories>
          
          <category> 小知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>前端基础 - 进阶篇</title>
      <link href="/2017/06/25/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%20-%20%E8%BF%9B%E9%98%B6%E7%AF%87/"/>
      <url>/2017/06/25/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%20-%20%E8%BF%9B%E9%98%B6%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h5 id="前端基础-进阶篇"><a href="#前端基础-进阶篇" class="headerlink" title="前端基础 - 进阶篇"></a>前端基础 - 进阶篇</h5><p>前端基础</p><a id="more"></a><h2 id="一、JS"><a href="#一、JS" class="headerlink" title="一、JS"></a>一、JS</h2><h3 id="1-谈谈变量提升"><a href="#1-谈谈变量提升" class="headerlink" title="1 谈谈变量提升"></a>1 谈谈变量提升</h3><blockquote><p>当执行 <code>JS</code> 代码时，会生成执行环境，只要代码不是写在函数中的，就是在全局执行环境中，函数中的代码会产生函数执行环境，只此两种执行环境。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">b() <span class="comment">// call b</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">'Hello world'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'call b'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>想必以上的输出大家肯定都已经明白了，这是因为函数和变量提升的原因。通常提升的解释是说将声明的代码移动到了顶部，这其实没有什么错误，便于大家理解。但是更准确的解释应该是：在生成执行环境时，会有两个阶段。第一个阶段是创建的阶段，<code>JS</code> 解释器会找出需要提升的变量和函数，并且给他们提前在内存中开辟好空间，函数的话会将整个函数存入内存中，变量只声明并且赋值为 <code>undefined</code>，所以在第二个阶段，也就是代码执行阶段，我们可以直接提前使用</p></blockquote><ul><li>在提升的过程中，相同的函数会覆盖上一个函数，并且函数优先于变量提升</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">b() <span class="comment">// call b second</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'call b fist'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'call b second'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">'Hello world'</span></span><br></pre></td></tr></table></figure><blockquote><p><code>var</code> 会产生很多错误，所以在 ES6中引入了 <code>let</code>。<code>let</code>不能在声明前使用，但是这并不是常说的 <code>let</code> 不会提升，<code>let</code>提升了，在第一阶段内存也已经为他开辟好了空间，但是因为这个声明的特性导致了并不能在声明前使用</p></blockquote><h3 id="2-bind、call、apply-区别"><a href="#2-bind、call、apply-区别" class="headerlink" title="2 bind、call、apply 区别"></a>2 bind、call、apply 区别</h3><ul><li><code>call</code> 和 <code>apply</code> 都是为了解决改变 <code>this</code> 的指向。作用都是相同的，只是传参的方式不同。</li><li>除了第一个参数外，<code>call</code> 可以接收一个参数列表，<code>apply</code> 只接受一个参数数组</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    value: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name)</span><br><span class="line">    <span class="built_in">console</span>.log(age)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.value)</span><br><span class="line">&#125;</span><br><span class="line">getValue.call(a, <span class="string">'yck'</span>, <span class="string">'24'</span>)</span><br><span class="line">getValue.apply(a, [<span class="string">'yck'</span>, <span class="string">'24'</span>])</span><br></pre></td></tr></table></figure><blockquote><p><code>bind</code> 和其他两个方法作用也是一致的，只是该方法会返回一个函数。并且我们可以通过 <code>bind</code> 实现柯里化</p></blockquote><h3 id="3-如何实现一个-bind-函数"><a href="#3-如何实现一个-bind-函数" class="headerlink" title="3 如何实现一个 bind 函数"></a>3 如何实现一个 bind 函数</h3><p>对于实现以下几个函数，可以从几个方面思考</p><ul><li>不传入第一个参数，那么默认为 <code>window</code></li><li>改变了 <code>this</code> 指向，让新的对象可以执行该函数。那么思路是否可以变成给新的对象添加一个函数，然后在执行完以后删除？</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Error'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> _this = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">var</span> args = [...arguments].slice(<span class="number">1</span>)</span><br><span class="line">  <span class="comment">// 返回一个函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 因为返回了一个函数，我们可以 new F()，所以需要判断</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> F) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> _this(...args, ...arguments)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _this.apply(context, args.concat(...arguments))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-如何实现一个-call-函数"><a href="#4-如何实现一个-call-函数" class="headerlink" title="4 如何实现一个 call 函数"></a>4 如何实现一个 call 函数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> context = context || <span class="built_in">window</span></span><br><span class="line">  <span class="comment">// 给 context 添加一个属性</span></span><br><span class="line">  <span class="comment">// getValue.call(a, 'yck', '24') =&gt; a.fn = getValue</span></span><br><span class="line">  context.fn = <span class="keyword">this</span></span><br><span class="line">  <span class="comment">// 将 context 后面的参数取出来</span></span><br><span class="line">  <span class="keyword">var</span> args = [...arguments].slice(<span class="number">1</span>)</span><br><span class="line">  <span class="comment">// getValue.call(a, 'yck', '24') =&gt; a.fn('yck', '24')</span></span><br><span class="line">  <span class="keyword">var</span> result = context.fn(...args)</span><br><span class="line">  <span class="comment">// 删除 fn</span></span><br><span class="line">  <span class="keyword">delete</span> context.fn</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-如何实现一个-apply-函数"><a href="#5-如何实现一个-apply-函数" class="headerlink" title="5 如何实现一个 apply 函数"></a>5 如何实现一个 apply 函数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> context = context || <span class="built_in">window</span></span><br><span class="line">  context.fn = <span class="keyword">this</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> result</span><br><span class="line">  <span class="comment">// 需要判断是否存储第二个参数</span></span><br><span class="line">  <span class="comment">// 如果存在，就将第二个参数展开</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">arguments</span>[<span class="number">1</span>]) &#123;</span><br><span class="line">    result = context.fn(...arguments[<span class="number">1</span>])</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = context.fn()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> context.fn</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-简单说下原型链？"><a href="#6-简单说下原型链？" class="headerlink" title="6 简单说下原型链？"></a>6 简单说下原型链？</h3><p><img src="https://user-gold-cdn.xitu.io/2018/9/19/165f189f736f19fd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><ul><li>每个函数都有 <code>prototype</code> 属性，除了 <code>Function.prototype.bind()</code>，该属性指向原型。</li><li>每个对象都有 <code>__proto__</code> 属性，指向了创建该对象的构造函数的原型。其实这个属性指向了 <code>[[prototype]]</code>，但是 <code>[[prototype]]</code>是内部属性，我们并不能访问到，所以使用 <code>_proto_</code>来访问。</li><li>对象可以通过 <code>__proto__</code> 来寻找不属于该对象的属性，<code>__proto__</code> 将对象连接起来组成了原型链。</li></ul><h3 id="7-怎么判断对象类型"><a href="#7-怎么判断对象类型" class="headerlink" title="7 怎么判断对象类型"></a>7 怎么判断对象类型</h3><ul><li>可以通过 <code>Object.prototype.toString.call(xx)</code>。这样我们就可以获得类似 <code>[object Type]</code> 的字符串。</li><li><code>instanceof</code> 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 <code>prototype</code></li></ul><h3 id="8-箭头函数的特点"><a href="#8-箭头函数的特点" class="headerlink" title="8 箭头函数的特点"></a>8 箭头函数的特点</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a()()())</span><br></pre></td></tr></table></figure><blockquote><p>箭头函数其实是没有 <code>this</code> 的，这个函数中的 <code>this</code> 只取决于他外面的第一个不是箭头函数的函数的 <code>this</code>。在这个例子中，因为调用 <code>a</code> 符合前面代码中的第一个情况，所以 <code>this</code> 是<code>window</code>。并且 <code>this</code>一旦绑定了上下文，就不会被任何代码改变</p></blockquote><h3 id="9-This"><a href="#9-This" class="headerlink" title="9 This"></a>9 This</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">foo()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">a: <span class="number">2</span>,</span><br><span class="line">foo: foo</span><br><span class="line">&#125;</span><br><span class="line">obj.foo()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上两者情况 `this` 只依赖于调用函数前的对象，优先级是第二个情况大于第一个情况</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下情况是优先级最高的，`this` 只会绑定在 `c` 上，不会被任何方式修改 `this` 指向</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> foo()</span><br><span class="line">c.a = <span class="number">3</span></span><br><span class="line"><span class="built_in">console</span>.log(c.a)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 还有种就是利用 call，apply，bind 改变 this，这个优先级仅次于 new</span></span><br></pre></td></tr></table></figure><h3 id="10-async、await-优缺点"><a href="#10-async、await-优缺点" class="headerlink" title="10 async、await 优缺点"></a>10 async、await 优缺点</h3><blockquote><p><code>async</code> 和 <code>await</code> 相比直接使用 <code>Promise</code> 来说，优势在于处理 then 的调用链，能够更清晰准确的写出代码。缺点在于滥用 <code>await</code> 可能会导致性能问题，因为 <code>await</code> 会阻塞代码，也许之后的异步代码并不依赖于前者，但仍然需要等待前者完成，导致代码失去了并发性</p></blockquote><p>下面来看一个使用 <code>await</code> 的代码。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  a = a + <span class="keyword">await</span> <span class="number">10</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'2'</span>, a) <span class="comment">// -&gt; '2' 10</span></span><br><span class="line">  a = (<span class="keyword">await</span> <span class="number">10</span>) + a</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'3'</span>, a) <span class="comment">// -&gt; '3' 20</span></span><br><span class="line">&#125;</span><br><span class="line">b()</span><br><span class="line">a++</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>, a) <span class="comment">// -&gt; '1' 1</span></span><br></pre></td></tr></table></figure><ul><li>首先函数<code>b</code> 先执行，在执行到 <code>await 10</code> 之前变量 <code>a</code> 还是 <code>0</code>，因为在 <code>await</code> 内部实现了 <code>generators</code> ，<code>generators</code> 会保留堆栈中东西，所以这时候 <code>a = 0</code> 被保存了下来</li><li>因为 <code>await</code> 是异步操作，遇到<code>await</code>就会立即返回一个<code>pending</code>状态的<code>Promise</code>对象，暂时返回执行代码的控制权，使得函数外的代码得以继续执行，所以会先执行 <code>console.log(&#39;1&#39;, a)</code></li><li>这时候同步代码执行完毕，开始执行异步代码，将保存下来的值拿出来使用，这时候 <code>a = 10</code></li><li>然后后面就是常规执行代码了</li></ul><h3 id="11-generator-原理"><a href="#11-generator-原理" class="headerlink" title="11 generator 原理"></a>11 generator 原理</h3><blockquote><p><code>Generator</code> 是 <code>ES6</code>中新增的语法，和 <code>Promise</code> 一样，都可以用来异步编程</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 * 表示这是一个 Generator 函数</span></span><br><span class="line"><span class="comment">// 内部可以通过 yield 暂停代码</span></span><br><span class="line"><span class="comment">// 通过调用 next 恢复执行</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span> + <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = test();</span><br><span class="line"><span class="built_in">console</span>.log(b.next()); <span class="comment">// &gt;  &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(b.next()); <span class="comment">// &gt;  &#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(b.next()); <span class="comment">// &gt;  &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>从以上代码可以发现，加上 <code>*</code>的函数执行后拥有了 <code>next</code> 函数，也就是说函数执行后返回了一个对象。每次调用 <code>next</code> 函数可以继续执行被暂停的代码。以下是 <code>Generator</code> 函数的简单实现</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cb 也就是编译过的 test 函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generator</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> object = &#123;</span><br><span class="line">      next: <span class="number">0</span>,</span><br><span class="line">      stop: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> ret = cb(object);</span><br><span class="line">        <span class="keyword">if</span> (ret === <span class="literal">undefined</span>) <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          value: ret,</span><br><span class="line">          done: <span class="literal">false</span></span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果你使用 babel 编译后可以发现 test 函数变成了这样</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a;</span><br><span class="line">  <span class="keyword">return</span> generator(<span class="function"><span class="keyword">function</span>(<span class="params">_context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">switch</span> ((_context.prev = _context.next)) &#123;</span><br><span class="line">        <span class="comment">// 可以发现通过 yield 将代码分割成几块</span></span><br><span class="line">        <span class="comment">// 每次执行 next 函数就执行一块代码</span></span><br><span class="line">        <span class="comment">// 并且表明下次需要执行哪块代码</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">          a = <span class="number">1</span> + <span class="number">2</span>;</span><br><span class="line">          _context.next = <span class="number">4</span>;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">          _context.next = <span class="number">6</span>;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 执行完毕</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"end"</span>:</span><br><span class="line">          <span class="keyword">return</span> _context.stop();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12-Promise"><a href="#12-Promise" class="headerlink" title="12 Promise"></a>12 Promise</h3><ul><li><code>Promise</code> 是 <code>ES6</code> 新增的语法，解决了回调地狱的问题。</li><li>可以把 <code>Promise</code>看成一个状态机。初始是 <code>pending</code> 状态，可以通过函数 <code>resolve</code> 和 <code>reject</code>，将状态转变为 <code>resolved</code> 或者 <code>rejected</code> 状态，状态一旦改变就不能再次变化。</li><li><code>then</code> 函数会返回一个 <code>Promise</code> 实例，并且该返回值是一个新的实例而不是之前的实例。因为 <code>Promise</code> 规范规定除了 <code>pending</code> 状态，其他状态是不可以改变的，如果返回的是一个相同实例的话，多个 <code>then</code> 调用就失去意义了。<br>对于 <code>then</code> 来说，本质上可以把它看成是 <code>flatMap</code></li></ul><h3 id="13-如何实现一个-Promise"><a href="#13-如何实现一个-Promise" class="headerlink" title="13 如何实现一个 Promise"></a>13 如何实现一个 Promise</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 三种状态</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">"pending"</span>;</span><br><span class="line"><span class="keyword">const</span> RESOLVED = <span class="string">"resolved"</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">"rejected"</span>;</span><br><span class="line"><span class="comment">// promise 接收一个函数参数，该函数会立即执行</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> _this = <span class="keyword">this</span>;</span><br><span class="line">  _this.currentState = PENDING;</span><br><span class="line">  _this.value = <span class="literal">undefined</span>;</span><br><span class="line">  <span class="comment">// 用于保存 then 中的回调，只有当 promise</span></span><br><span class="line">  <span class="comment">// 状态为 pending 时才会缓存，并且每个实例至多缓存一个</span></span><br><span class="line">  _this.resolvedCallbacks = [];</span><br><span class="line">  _this.rejectedCallbacks = [];</span><br><span class="line"></span><br><span class="line">  _this.resolve = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">      <span class="comment">// 如果 value 是个 Promise，递归执行</span></span><br><span class="line">      <span class="keyword">return</span> value.then(_this.resolve, _this.reject)</span><br><span class="line">    &#125;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">// 异步执行，保证执行顺序</span></span><br><span class="line">      <span class="keyword">if</span> (_this.currentState === PENDING) &#123;</span><br><span class="line">        _this.currentState = RESOLVED;</span><br><span class="line">        _this.value = value;</span><br><span class="line">        _this.resolvedCallbacks.forEach(<span class="function"><span class="params">cb</span> =&gt;</span> cb());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  _this.reject = <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">// 异步执行，保证执行顺序</span></span><br><span class="line">      <span class="keyword">if</span> (_this.currentState === PENDING) &#123;</span><br><span class="line">        _this.currentState = REJECTED;</span><br><span class="line">        _this.value = reason;</span><br><span class="line">        _this.rejectedCallbacks.forEach(<span class="function"><span class="params">cb</span> =&gt;</span> cb());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 用于解决以下问题</span></span><br><span class="line">  <span class="comment">// new Promise(() =&gt; throw Error('error))</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    fn(_this.resolve, _this.reject);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    _this.reject(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onResolved, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  <span class="comment">// 规范 2.2.7，then 必须返回一个新的 promise</span></span><br><span class="line">  <span class="keyword">var</span> promise2;</span><br><span class="line">  <span class="comment">// 规范 2.2.onResolved 和 onRejected 都为可选参数</span></span><br><span class="line">  <span class="comment">// 如果类型不是函数需要忽略，同时也实现了透传</span></span><br><span class="line">  <span class="comment">// Promise.resolve(4).then().then((value) =&gt; console.log(value))</span></span><br><span class="line">  onResolved = <span class="keyword">typeof</span> onResolved === <span class="string">'function'</span> ? onResolved : <span class="function"><span class="params">v</span> =&gt;</span> v;</span><br><span class="line">  onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span> ? onRejected : <span class="function"><span class="params">r</span> =&gt;</span> <span class="keyword">throw</span> r;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (self.currentState === RESOLVED) &#123;</span><br><span class="line">    <span class="keyword">return</span> (promise2 = <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 规范 2.2.4，保证 onFulfilled，onRjected 异步执行</span></span><br><span class="line">      <span class="comment">// 所以用了 setTimeout 包裹下</span></span><br><span class="line">      setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">var</span> x = onResolved(self.value);</span><br><span class="line">          resolutionProcedure(promise2, x, resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (reason) &#123;</span><br><span class="line">          reject(reason);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (self.currentState === REJECTED) &#123;</span><br><span class="line">    <span class="keyword">return</span> (promise2 = <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 异步执行onRejected</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">var</span> x = onRejected(self.value);</span><br><span class="line">          resolutionProcedure(promise2, x, resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (reason) &#123;</span><br><span class="line">          reject(reason);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (self.currentState === PENDING) &#123;</span><br><span class="line">    <span class="keyword">return</span> (promise2 = <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      self.resolvedCallbacks.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 考虑到可能会有报错，所以使用 try/catch 包裹</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">var</span> x = onResolved(self.value);</span><br><span class="line">          resolutionProcedure(promise2, x, resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (r) &#123;</span><br><span class="line">          reject(r);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      self.rejectedCallbacks.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">var</span> x = onRejected(self.value);</span><br><span class="line">          resolutionProcedure(promise2, x, resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (r) &#123;</span><br><span class="line">          reject(r);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 规范 2.3</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolutionProcedure</span>(<span class="params">promise2, x, resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 规范 2.3.1，x 不能和 promise2 相同，避免循环引用</span></span><br><span class="line">  <span class="keyword">if</span> (promise2 === x) &#123;</span><br><span class="line">    <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Error"</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 规范 2.3.2</span></span><br><span class="line">  <span class="comment">// 如果 x 为 Promise，状态为 pending 需要继续等待否则执行</span></span><br><span class="line">  <span class="keyword">if</span> (x <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x.currentState === PENDING) &#123;</span><br><span class="line">      x.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 再次调用该函数是为了确认 x resolve 的</span></span><br><span class="line">        <span class="comment">// 参数是什么类型，如果是基本类型就再次 resolve</span></span><br><span class="line">        <span class="comment">// 把值传给下个 then</span></span><br><span class="line">        resolutionProcedure(promise2, value, resolve, reject);</span><br><span class="line">      &#125;, reject);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      x.then(resolve, reject);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 规范 2.3.3.3.3</span></span><br><span class="line">  <span class="comment">// reject 或者 resolve 其中一个执行过得话，忽略其他的</span></span><br><span class="line">  <span class="keyword">let</span> called = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// 规范 2.3.3，判断 x 是否为对象或者函数</span></span><br><span class="line">  <span class="keyword">if</span> (x !== <span class="literal">null</span> &amp;&amp; (<span class="keyword">typeof</span> x === <span class="string">"object"</span> || <span class="keyword">typeof</span> x === <span class="string">"function"</span>)) &#123;</span><br><span class="line">    <span class="comment">// 规范 2.3.3.2，如果不能取出 then，就 reject</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 规范 2.3.3.1</span></span><br><span class="line">      <span class="keyword">let</span> then = x.then;</span><br><span class="line">      <span class="comment">// 如果 then 是函数，调用 x.then</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">"function"</span>) &#123;</span><br><span class="line">        <span class="comment">// 规范 2.3.3.3</span></span><br><span class="line">        then.call(</span><br><span class="line">          x,</span><br><span class="line">          y =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">            called = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 规范 2.3.3.3.1</span></span><br><span class="line">            resolutionProcedure(promise2, y, resolve, reject);</span><br><span class="line">          &#125;,</span><br><span class="line">          e =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">            called = <span class="literal">true</span>;</span><br><span class="line">            reject(e);</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 规范 2.3.3.4</span></span><br><span class="line">        resolve(x);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">      called = <span class="literal">true</span>;</span><br><span class="line">      reject(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 规范 2.3.4，x 为基本类型</span></span><br><span class="line">    resolve(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14-和-区别，什么情况用"><a href="#14-和-区别，什么情况用" class="headerlink" title="14 == 和 ===区别，什么情况用 =="></a>14 == 和 ===区别，什么情况用 ==</h3><p><img src="https://user-gold-cdn.xitu.io/2018/3/30/16275f89ebf931e9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><blockquote><p>这里来解析一道题目 <code>[] == ![] // -&gt; true</code> ，下面是这个表达式为何为 <code>true</code> 的步骤</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// [] 转成 true，然后取反变成 false</span></span><br><span class="line">[] == <span class="literal">false</span></span><br><span class="line"><span class="comment">// 根据第 8 条得出</span></span><br><span class="line">[] == ToNumber(<span class="literal">false</span>)</span><br><span class="line">[] == <span class="number">0</span></span><br><span class="line"><span class="comment">// 根据第 10 条得出</span></span><br><span class="line">ToPrimitive([]) == <span class="number">0</span></span><br><span class="line"><span class="comment">// [].toString() -&gt; ''</span></span><br><span class="line"><span class="string">''</span> == <span class="number">0</span></span><br><span class="line"><span class="comment">// 根据第 6 条得出</span></span><br><span class="line"><span class="number">0</span> == <span class="number">0</span> <span class="comment">// -&gt; true</span></span><br></pre></td></tr></table></figure><blockquote><p><code>===</code>用于判断两者类型和值是否相同。 在开发中，对于后端返回的 <code>code</code>，可以通过 <code>==</code>去判断</p></blockquote><h3 id="15-基本数据类型和引⽤类型在存储上的差别"><a href="#15-基本数据类型和引⽤类型在存储上的差别" class="headerlink" title="15 基本数据类型和引⽤类型在存储上的差别"></a>15 基本数据类型和引⽤类型在存储上的差别</h3><blockquote><p>前者存储在栈上，后者存储在堆上</p></blockquote><h3 id="16-浏览器-Eventloop-和-Node-中的有什么区别"><a href="#16-浏览器-Eventloop-和-Node-中的有什么区别" class="headerlink" title="16 浏览器 Eventloop 和 Node 中的有什么区别"></a>16 浏览器 Eventloop 和 Node 中的有什么区别</h3><blockquote><p>众所周知 JS 是门非阻塞单线程语言，因为在最初 JS 就是为了和浏览器交互而诞生的。如果 JS 是门多线程的语言话，我们在多个线程中处理 DOM 就可能会发生问题（一个线程中新加节点，另一个线程中删除节点），当然可以引入读写锁解决这个问题。</p></blockquote><ul><li><code>JS</code> 在执行的过程中会产生执行环境，这些执行环境会被顺序的加入到执行栈中。如果遇到异步的代码，会被挂起并加入到 <code>Task</code>（有多种 <code>task</code>） 队列中。一旦执行栈为空，<code>Event Loop</code> 就会从 <code>Task</code> 队列中拿出需要执行的代码并放入执行栈中执行，所以本质上来说 <code>JS</code> 中的异步还是同步行为</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>);</span><br></pre></td></tr></table></figure><ul><li>以上代码虽然 <code>setTimeout</code> 延时为 <code>0</code>，其实还是异步。这是因为 <code>HTML5</code> 标准规定这个函数第二个参数不得小于 <code>4</code> 毫秒，不足会自动增加。所以 <code>setTimeout</code>还是会在 <code>script end</code> 之后打印。</li><li>不同的任务源会被分配到不同的 <code>Task</code>队列中，任务源可以分为 微任务（<code>microtask</code>） 和 宏任务（<code>macrotask</code>）。在 ES6 规范中，<code>microtask</code> 称为 jobs，<code>macrotask</code> 称为 <code>task</code>。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Promise'</span>)</span><br><span class="line">    resolve()</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise2'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>);</span><br><span class="line"><span class="comment">// script start =&gt; Promise =&gt; script end =&gt; promise1 =&gt; promise2 =&gt; setTimeout</span></span><br></pre></td></tr></table></figure><ul><li>以上代码虽然 <code>setTimeout</code> 写在 <code>Promise</code> 之前，但是因为 <code>Promise</code> 属于微任务而 <code>setTimeout</code>属于宏任务，所以会有以上的打印。</li><li><strong>微任务包括</strong> <code>process.nextTick</code> ，<code>promise</code> ，<code>Object.observe</code>，<code>MutationObserver</code></li><li><strong>宏任务包括</strong> <code>script</code> ， <code>setTimeout</code> ，<code>setInterval</code>，<code>setImmediate</code> ，<code>I/O</code> ，<code>UI renderin</code></li></ul><blockquote><p>很多人有个误区，认为微任务快于宏任务，其实是错误的。因为宏任务中包括了 <code>script</code> ，浏览器会先执行一个宏任务，接下来有异步代码的话就先执行微任务</p></blockquote><p><strong>所以正确的一次 Event loop 顺序是这样的</strong></p><ul><li>执行同步代码，这属于宏任务</li><li>执行栈为空，查询是否有微任务需要执行</li><li>执行所有微任务</li><li>必要的话渲染 <code>UI</code></li><li>然后开始下一轮 <code>Event loop</code>，执行宏任务中的异步代码</li></ul><blockquote><p>通过上述的  <code>Event loop</code> 顺序可知，如果宏任务中的异步代码有大量的计算并且需要操作 <code>DOM</code> 的话，为了更快的 界面响应，我们可以把操作 <code>DOM</code> 放入微任务中</p></blockquote><h3 id="17-setTimeout-倒计时误差"><a href="#17-setTimeout-倒计时误差" class="headerlink" title="17 setTimeout 倒计时误差"></a>17 setTimeout 倒计时误差</h3><blockquote><p><code>JS</code> 是单线程的，所以 <code>setTimeout</code> 的误差其实是无法被完全解决的，原因有很多，可能是回调中的，有可能是浏览器中的各种事件导致。这也是为什么页面开久了，定时器会不准的原因，当然我们可以通过一定的办法去减少这个误差。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下是一个相对准备的倒计时实现</span></span><br><span class="line"><span class="keyword">var</span> period = <span class="number">60</span> * <span class="number">1000</span> * <span class="number">60</span> * <span class="number">2</span></span><br><span class="line"><span class="keyword">var</span> startTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> end = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime() + period</span><br><span class="line"><span class="keyword">var</span> interval = <span class="number">1000</span></span><br><span class="line"><span class="keyword">var</span> currentInterval = interval</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  count++</span><br><span class="line">  <span class="keyword">var</span> offset = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime() - (startTime + count * interval); <span class="comment">// 代码执行所消耗的时间</span></span><br><span class="line">  <span class="keyword">var</span> diff = end - <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line">  <span class="keyword">var</span> h = <span class="built_in">Math</span>.floor(diff / (<span class="number">60</span> * <span class="number">1000</span> * <span class="number">60</span>))</span><br><span class="line">  <span class="keyword">var</span> hdiff = diff % (<span class="number">60</span> * <span class="number">1000</span> * <span class="number">60</span>)</span><br><span class="line">  <span class="keyword">var</span> m = <span class="built_in">Math</span>.floor(hdiff / (<span class="number">60</span> * <span class="number">1000</span>))</span><br><span class="line">  <span class="keyword">var</span> mdiff = hdiff % (<span class="number">60</span> * <span class="number">1000</span>)</span><br><span class="line">  <span class="keyword">var</span> s = mdiff / (<span class="number">1000</span>)</span><br><span class="line">  <span class="keyword">var</span> sCeil = <span class="built_in">Math</span>.ceil(s)</span><br><span class="line">  <span class="keyword">var</span> sFloor = <span class="built_in">Math</span>.floor(s)</span><br><span class="line">  currentInterval = interval - offset <span class="comment">// 得到下一次循环所消耗的时间</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'时：'</span>+h, <span class="string">'分：'</span>+m, <span class="string">'毫秒：'</span>+s, <span class="string">'秒向上取整：'</span>+sCeil, <span class="string">'代码执行时间：'</span>+offset, <span class="string">'下次循环间隔'</span>+currentInterval) <span class="comment">// 打印 时 分 秒 代码执行时间 下次循环间隔</span></span><br><span class="line"></span><br><span class="line">  setTimeout(loop, currentInterval)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setTimeout(loop, currentInterval)</span><br></pre></td></tr></table></figure><h3 id="18-数组降维"><a href="#18-数组降维" class="headerlink" title="18 数组降维"></a>18 数组降维</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, [<span class="number">2</span>], <span class="number">3</span>].flatMap(<span class="function">(<span class="params">v</span>) =&gt;</span> v + <span class="number">1</span>)</span><br><span class="line"><span class="comment">// -&gt; [2, 3, 4]</span></span><br></pre></td></tr></table></figure><blockquote><p>如果想将一个多维数组彻底的降维，可以这样实现</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> flattenDeep = <span class="function">(<span class="params">arr</span>) =&gt;</span> <span class="built_in">Array</span>.isArray(arr)</span><br><span class="line">  ? arr.reduce( <span class="function">(<span class="params">a, b</span>) =&gt;</span> [...a, ...flattenDeep(b)] , [])</span><br><span class="line">  : [arr]</span><br><span class="line"></span><br><span class="line">flattenDeep([<span class="number">1</span>, [[<span class="number">2</span>], [<span class="number">3</span>, [<span class="number">4</span>]], <span class="number">5</span>]])</span><br></pre></td></tr></table></figure><h3 id="19-深拷贝"><a href="#19-深拷贝" class="headerlink" title="19 深拷贝"></a>19 深拷贝</h3><blockquote><p>这个问题通常可以通过 <code>JSON.parse(JSON.stringify(object))</code> 来解决</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    age: <span class="number">1</span>,</span><br><span class="line">    jobs: &#123;</span><br><span class="line">        first: <span class="string">'FE'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(a))</span><br><span class="line">a.jobs.first = <span class="string">'native'</span></span><br><span class="line"><span class="built_in">console</span>.log(b.jobs.first) <span class="comment">// FE</span></span><br></pre></td></tr></table></figure><p><strong>但是该方法也是有局限性的</strong>：</p><ul><li>会忽略 <code>undefined</code></li><li>会忽略 <code>symbol</code></li><li>不能序列化函数</li><li>不能解决循环引用的对象</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: &#123;</span><br><span class="line">    c: <span class="number">2</span>,</span><br><span class="line">    d: <span class="number">3</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">obj.c = obj.b</span><br><span class="line">obj.e = obj.a</span><br><span class="line">obj.b.c = obj.c</span><br><span class="line">obj.b.d = obj.b</span><br><span class="line">obj.b.e = obj.b.c</span><br><span class="line"><span class="keyword">let</span> newObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj))</span><br><span class="line"><span class="built_in">console</span>.log(newObj)</span><br><span class="line">复</span><br></pre></td></tr></table></figure><blockquote><p>在遇到函数、 <code>undefined</code> 或者 <code>symbol</code> 的时候，该对象也不能正常的序列化</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    age: <span class="literal">undefined</span>,</span><br><span class="line">    sex: <span class="built_in">Symbol</span>(<span class="string">'male'</span>),</span><br><span class="line">    jobs: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">    name: <span class="string">'yck'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(a))</span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// &#123;name: "yck"&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>但是在通常情况下，复杂数据都是可以序列化的，所以这个函数可以解决大部分问题，并且该函数是内置函数中处理深拷贝性能最快的。当然如果你的数据中含有以上三种情况下，可以使用 <code>lodash</code> 的深拷贝函数</p></blockquote><h3 id="20-typeof-于-instanceof-区别"><a href="#20-typeof-于-instanceof-区别" class="headerlink" title="20 typeof 于 instanceof 区别"></a>20 typeof 于 instanceof 区别</h3><blockquote><p><code>typeof</code> 对于基本类型，除了 <code>null</code>都可以显示正确的类型</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">1</span> <span class="comment">// 'number'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">'1'</span> <span class="comment">// 'string'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">// 'undefined'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span> <span class="comment">// 'boolean'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>() <span class="comment">// 'symbol'</span></span><br><span class="line"><span class="keyword">typeof</span> b <span class="comment">// b 没有声明，但是还会显示 undefined</span></span><br></pre></td></tr></table></figure><blockquote><p><code>typeof</code> 对于对象，除了函数都会显示 <code>object</code></p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> [] <span class="comment">// 'object'</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125; <span class="comment">// 'object'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">console</span>.log <span class="comment">// 'function'</span></span><br></pre></td></tr></table></figure><blockquote><p>对于 <code>null</code> 来说，虽然它是基本类型，但是会显示 <code>object</code>，这是一个存在很久了的 <code>Bug</code></p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typeof null &#x2F;&#x2F; &#39;object&#39;</span><br></pre></td></tr></table></figure><blockquote><p><code>instanceof</code> 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 <code>prototype</code></p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">我们也可以试着实现一下 <span class="keyword">instanceof</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instanceof</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获得类型的原型</span></span><br><span class="line">    <span class="keyword">let</span> prototype = right.prototype</span><br><span class="line">    <span class="comment">// 获得对象的原型</span></span><br><span class="line">    left = left.__proto__</span><br><span class="line">    <span class="comment">// 判断对象的类型是否等于类型的原型</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (left === <span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> (prototype === left)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    left = left.__proto__</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、浏览器"><a href="#二、浏览器" class="headerlink" title="二、浏览器"></a>二、浏览器</h2><h3 id="1-cookie和localSrorage、session、indexDB-的区别"><a href="#1-cookie和localSrorage、session、indexDB-的区别" class="headerlink" title="1 cookie和localSrorage、session、indexDB 的区别"></a>1 cookie和localSrorage、session、indexDB 的区别</h3><table><thead><tr><th>特性</th><th>cookie</th><th>localStorage</th><th>sessionStorage</th><th>indexDB</th></tr></thead><tbody><tr><td>数据生命周期</td><td>一般由服务器生成，可以设置过期时间</td><td>除非被清理，否则一直存在</td><td>页面关闭就清理</td><td>除非被清理，否则一直存在</td></tr><tr><td>数据存储大小</td><td><code>4K</code></td><td><code>5M</code></td><td><code>5M</code></td><td>无限</td></tr><tr><td>与服务端通信</td><td>每次都会携带在 header 中，对于请求性能影响</td><td>不参与</td><td>不参与</td><td>不参与</td></tr></tbody></table><blockquote><p>从上表可以看到，<code>cookie</code> 已经不建议用于存储。如果没有大量数据存储需求的话，可以使用 <code>localStorage</code>和 <code>sessionStorage</code> 。对于不怎么改变的数据尽量使用 <code>localStorage</code> 存储，否则可以用 <code>sessionStorage</code> 存储。</p></blockquote><p><strong>对于 <code>cookie</code>，我们还需要注意安全性</strong></p><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td><code>value</code></td><td>如果用于保存用户登录态，应该将该值加密，不能使用明文的用户标识</td></tr><tr><td><code>http-only</code></td><td>不能通过 <code>JS</code>访问 <code>Cookie</code>，减少 <code>XSS</code>攻击</td></tr><tr><td><code>secure</code></td><td>只能在协议为 <code>HTTPS</code> 的请求中携带</td></tr><tr><td><code>same-site</code></td><td>规定浏览器不能在跨域请求中携带 <code>Cookie</code>，减少 <code>CSRF</code> 攻击</td></tr></tbody></table><h3 id="2-怎么判断页面是否加载完成？"><a href="#2-怎么判断页面是否加载完成？" class="headerlink" title="2 怎么判断页面是否加载完成？"></a>2 怎么判断页面是否加载完成？</h3><ul><li><code>Load</code> 事件触发代表页面中的 <code>DOM</code>，<code>CSS</code>，<code>JS</code>，图片已经全部加载完毕。</li><li><code>DOMContentLoaded</code> 事件触发代表初始的 <code>HTML</code> 被完全加载和解析，不需要等待 <code>CSS</code>，<code>JS</code>，图片加载</li></ul><h3 id="3-如何解决跨域"><a href="#3-如何解决跨域" class="headerlink" title="3 如何解决跨域"></a>3 如何解决跨域</h3><blockquote><p>因为浏览器出于安全考虑，有同源策略。也就是说，如果协议、域名或者端口有一个不同就是跨域，<code>Ajax</code>请求会失败。</p></blockquote><p>我们可以通过以下几种常用方法解决跨域的问题</p><p><strong>JSONP</strong></p><blockquote><p><code>JSONP</code> 的原理很简单，就是利用 <code>&lt;script&gt;</code>标签没有跨域限制的漏洞。通过 <code>&lt;script&gt;</code>标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://domain/api?param1=a&amp;param2=b&amp;callback=jsonp"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">jsonp</span><span class="params">(data)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(data)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><code>JSONP</code> 使用简单且兼容性不错，但是只限于 <code>get</code> 请求</p></blockquote><ul><li>在开发中可能会遇到多个 <code>JSONP</code> 请求的回调函数名是相同的，这时候就需要自己封装一个 <code>JSONP</code>，以下是简单实现</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonp</span>(<span class="params">url, jsonpCallback, success</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</span><br><span class="line">  script.src = url;</span><br><span class="line">  script.async = <span class="literal">true</span>;</span><br><span class="line">  script.type = <span class="string">"text/javascript"</span>;</span><br><span class="line">  <span class="built_in">window</span>[jsonpCallback] = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    success &amp;&amp; success(data);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">&#125;</span><br><span class="line">jsonp(</span><br><span class="line">  <span class="string">"http://xxx"</span>,</span><br><span class="line">  <span class="string">"callback"</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>CORS</strong></p><ul><li><code>ORS</code>需要浏览器和后端同时支持。<code>IE 8</code> 和 <code>9</code> 需要通过 <code>XDomainRequest</code> 来实现。</li><li>浏览器会自动进行 <code>CORS</code> 通信，实现<code>CORS</code>通信的关键是后端。只要后端实现了 <code>CORS</code>，就实现了跨域。</li><li>服务端设置 <code>Access-Control-Allow-Origin</code> 就可以开启 <code>CORS</code>。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。</li></ul><p><strong>document.domain</strong></p><ul><li>该方式只能用于二级域名相同的情况下，比如 <code>a.test.com</code> 和 <code>b.test.com</code> 适用于该方式。</li><li>只需要给页面添加 <code>document.domain = &#39;test.com&#39;</code> 表示二级域名都相同就可以实现跨域</li></ul><p><strong>postMessage</strong></p><blockquote><p>这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发送消息端</span></span><br><span class="line"><span class="built_in">window</span>.parent.postMessage(<span class="string">'message'</span>, <span class="string">'http://test.com'</span>);</span><br><span class="line"><span class="comment">// 接收消息端</span></span><br><span class="line"><span class="keyword">var</span> mc = <span class="keyword">new</span> MessageChannel();</span><br><span class="line">mc.addEventListener(<span class="string">'message'</span>, (event) =&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> origin = event.origin || event.originalEvent.origin;</span><br><span class="line">    <span class="keyword">if</span> (origin === <span class="string">'http://test.com'</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'验证通过'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="4-什么是事件代理"><a href="#4-什么是事件代理" class="headerlink" title="4 什么是事件代理"></a>4 什么是事件代理</h3><blockquote><p>如果一个节点中的子节点是动态生成的，那么子节点需要注册事件的话应该注册在父节点上</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"ul"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">'#ul'</span>)</span></span><br><span class="line"><span class="actionscript">ul.addEventListener(<span class="string">'click'</span>, (event) =&gt; &#123;</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(event.target);</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>事件代理的方式相对于直接给目标注册事件来说，有以下优点<ul><li>节省内存</li><li>不需要给子节点注销事件</li></ul></li></ul><h3 id="5-Service-worker"><a href="#5-Service-worker" class="headerlink" title="5 Service worker"></a>5 Service worker</h3><p>::: tip service worker<br><code>Service workers</code> 本质上充当Web应用程序与浏览器之间的代理服务器，也可以在网络可用时作为浏览器和网络间的代理。它们旨在（除其他之外）使得能够创建有效的离线体验，拦截网络请求并基于网络是否可用以及更新的资源是否驻留在服务器上来采取适当的动作。他们还允许访问推送通知和后台同步API<br>:::</p><p>目前该技术通常用来做缓存文件，提高首屏速度，可以试着来实现这个功能</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">if</span> (navigator.serviceWorker) &#123;</span><br><span class="line">  navigator.serviceWorker</span><br><span class="line">    .register(<span class="string">"sw.js"</span>)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">registration</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"service worker 注册成功"</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"servcie worker 注册失败"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// sw.js</span></span><br><span class="line"><span class="comment">// 监听 `install` 事件，回调中缓存所需文件</span></span><br><span class="line">self.addEventListener(<span class="string">"install"</span>, e =&gt; &#123;</span><br><span class="line">  e.waitUntil(</span><br><span class="line">    caches.open(<span class="string">"my-cache"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> cache.addAll([<span class="string">"./index.html"</span>, <span class="string">"./index.js"</span>]);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拦截所有请求事件</span></span><br><span class="line"><span class="comment">// 如果缓存中已经有请求的数据就直接用缓存，否则去请求数据</span></span><br><span class="line">self.addEventListener(<span class="string">"fetch"</span>, e =&gt; &#123;</span><br><span class="line">  e.respondWith(</span><br><span class="line">    caches.match(e.request).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (response) &#123;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"fetch source"</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>打开页面，可以在开发者工具中的 <code>Application</code> 看到 <code>Service Worker</code>已经启动了</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/3/28/1626b1e8eba68e1c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><h3 id="6-浏览器缓存"><a href="#6-浏览器缓存" class="headerlink" title="6 浏览器缓存"></a>6 浏览器缓存</h3><blockquote><p>缓存对于前端性能优化来说是个很重要的点，良好的缓存策略可以降低资源的重复加载提高网页的整体加载速度。</p></blockquote><ul><li>通常浏览器缓存策略分为两种：强缓存和协商缓存。</li></ul><p><strong>强缓存</strong></p><blockquote><p>实现强缓存可以通过两种响应头实现：<code>Expires</code> 和 <code>Cache-Control</code> 。强缓存表示在缓存期间不需要请求，<code>state code</code> 为 <code>200</code></p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Expires: Wed, 22 Oct 2018 08:41:00 GMT</span><br></pre></td></tr></table></figure><blockquote><p><code>Expires</code> 是 <code>HTTP / 1.0</code> 的产物，表示资源会在<code>Wed</code>,<code>22 Oct 2018 08:41:00 GMT</code> 后过期，需要再次请求。并且 <code>Expires</code> 受限于本地时间，如果修改了本地时间，可能会造成缓存失效。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cache-control: max-age&#x3D;30</span><br></pre></td></tr></table></figure><ul><li><code>Cache-Control</code> 出现于 <code>HTTP / 1.1</code>，优先级高于 <code>Expires</code> 。该属性表示资源会在 <code>30</code> 秒后过期，需要再次请求。</li></ul><p><strong>协商缓存</strong></p><ul><li>如果缓存过期了，我们就可以使用协商缓存来解决问题。协商缓存需要请求，如果缓存有效会返回 <code>304</code>。</li><li>协商缓存需要客户端和服务端共同实现，和强缓存一样，也有两种实现方式</li></ul><p><strong>Last-Modified 和 If-Modified-Since</strong></p><ul><li><code>Last-Modified</code>表示本地文件最后修改日期，<code>If-Modified-Since</code> 会将 <code>Last-Modified</code> 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来。</li><li>但是如果在本地打开缓存文件，就会造成 <code>Last-Modified</code>被修改，所以在 <code>HTTP / 1.1</code> 出现了 <code>ETag</code></li></ul><p><strong>ETag 和 If-None-Match</strong></p><blockquote><p><code>ETag</code> 类似于文件指纹，<code>If-None-Match</code> 会将当前 <code>ETag</code>发送给服务器，询问该资源 <code>ETag</code> 是否变动，有变动的话就将新的资源发送回来。并且 <code>ETag</code> 优先级比 <code>Last-Modified</code> 高</p></blockquote><p><strong>选择合适的缓存策略</strong></p><blockquote><p>对于大部分的场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方可能需要选择特殊的缓存策略</p></blockquote><ul><li>对于某些不需要缓存的资源，可以使用 <code>Cache-control: no-store</code> ，表示该资源不需要缓存</li><li>对于频繁变动的资源，可以使用 <code>Cache-Control: no-cache</code>并配合 <code>ETag</code> 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新。</li><li>对于代码文件来说，通常使用 <code>Cache-Control: max-age=31536000</code> 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件</li></ul><h3 id="7-浏览器性能问题"><a href="#7-浏览器性能问题" class="headerlink" title="7 浏览器性能问题"></a>7 浏览器性能问题</h3><p><strong>重绘（Repaint）和回流（Reflow）</strong></p><ul><li>重绘和回流是渲染步骤中的一小节，但是这两个步骤对于性能影响很大。</li><li>重绘是当节点需要更改外观而不会影响布局的，比如改变 <code>color</code>就叫称为重绘</li><li>回流是布局或者几何属性需要改变就称为回流。</li><li>回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变深层次的节点很可能导致父节点的一系列回流。</li></ul><p><strong>所以以下几个动作可能会导致性能问题</strong>：</p><ul><li>改变 <code>window</code> 大小</li><li>改变字体</li><li>添加或删除样式</li><li>文字改变</li><li>定位或者浮动</li><li>盒模型</li></ul><p><strong>很多人不知道的是，重绘和回流其实和 Event loop 有关</strong>。</p><ul><li>当 <code>Event loop</code> 执行完 <code>Microtasks</code>后，会判断 <code>document</code> 是否需要更新。- 因为浏览器是 <code>60Hz</code> 的刷新率，每 <code>16ms</code>才会更新一次。</li><li>然后判断是否有<code>resize</code> 或者 <code>scroll</code> ，有的话会去触发事件，所以 <code>resize</code> 和 <code>scroll</code> 事件也是至少 16ms 才会触发一次，并且自带节流功能。</li><li>判断是否触发了 <code>media query</code></li><li>更新动画并且发送事件</li><li>判断是否有全屏操作事件</li><li>执行 <code>requestAnimationFrame</code>回调</li><li>执行 <code>IntersectionObserver</code> 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好</li><li>更新界面</li><li>以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 <code>requestIdleCallback</code> 回调。</li></ul><p><strong>减少重绘和回流</strong></p><blockquote><p>使用 <code>translate</code> 替代 <code>top</code></p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.test</span> &#123;</span></span><br><span class="line">position: absolute;</span><br><span class="line">top: 10px;</span><br><span class="line">width: 100px;</span><br><span class="line">height: 100px;</span><br><span class="line">background: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 引起回流</span></span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.querySelector(<span class="string">'.test'</span>).style.top = <span class="string">'100px'</span></span></span><br><span class="line">&#125;, 1000)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>使用 <code>visibility</code> 替换 <code>display: none</code> ，因为前者只会引起重绘，后者会引发回流（改变了布局）</li><li>把 <code>DOM</code> 离线后修改，比如：先把 <code>DOM</code> 给 <code>display:none</code>(有一次 <code>Reflow</code>)，然后你修改<code>100</code>次，然后再把它显示出来</li><li>不要把 <code>DOM</code>结点的属性值放在一个循环里当成循环里的变量</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 获取 offsetTop 会导致回流，因为需要去获取正确的值</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">document</span>.querySelector(<span class="string">'.test'</span>).style.offsetTop)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不要使用 <code>table</code> 布局，可能很小的一个小改动会造成整个 <code>table</code> 的重新布局<br>动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 <code>requestAnimationFrame</code></li><li><code>CSS</code>选择符从右往左匹配查找，避免 <code>DOM</code> 深度过深</li><li>将频繁运行的动画变为图层，图层能够阻止该节点回流影响别的元素。比如对于 <code>video</code> 标签，浏览器会自动将该节点变为图层。</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/3/29/1626fb6f33a6f9d7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><p><strong>CDN</strong></p><blockquote><p>静态资源尽量使用 <code>CDN</code> 加载，由于浏览器对于单个域名有并发请求上限，可以考虑使用多个 <code>CDN</code> 域名。对于 <code>CDN</code> 加载静态资源需要注意 CDN 域名要与主站不同，否则每次请求都会带上主站的 <code>Cookie</code></p></blockquote><p><strong>使用 Webpack 优化项目</strong></p><ul><li>对于 <code>Webpack4</code>，打包项目使用 <code>production</code> 模式，这样会自动开启代码压缩</li><li>使用 <code>ES6</code> 模块来开启 <code>tree shaking</code>，这个技术可以移除没有使用的代码</li><li>优化图片，对于小图可以使用 <code>base64</code> 的方式写入文件中</li><li>按照路由拆分代码，实现按需加载</li></ul><h2 id="三、Webpack"><a href="#三、Webpack" class="headerlink" title="三、Webpack"></a>三、Webpack</h2><p></p><h3 id="1-优化打包速度"><a href="#1-优化打包速度" class="headerlink" title="1 优化打包速度"></a>1 优化打包速度</h3><ul><li>减少文件搜索范围<ul><li>比如通过别名</li><li><code>loader</code> 的 <code>test</code>，<code>include &amp; exclude</code></li></ul></li><li><code>Webpack4</code> 默认压缩并行</li><li><code>Happypack</code> 并发调用</li><li><code>babel</code> 也可以缓存编译</li></ul><h3 id="2-Babel-原理"><a href="#2-Babel-原理" class="headerlink" title="2 Babel 原理"></a>2 Babel 原理</h3><ul><li>本质就是编译器，当代码转为字符串生成 <code>AST</code>，对 <code>AST</code> 进行转变最后再生成新的代码</li><li>分为三步：词法分析生成 <code>Token</code>，语法分析生成 <code>AST</code>，遍历 <code>AST</code>，根据插件变换相应的节点，最后把 <code>AST</code>转换为代码</li></ul><h3 id="3-如何实现一个插件"><a href="#3-如何实现一个插件" class="headerlink" title="3 如何实现一个插件"></a>3 如何实现一个插件</h3><ul><li>调用插件 <code>apply</code> 函数传入 <code>compiler</code> 对象</li><li>通过 <code>compiler</code> 对象监听事件</li></ul><p>比如你想实现一个编译结束退出命令的插件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">apply (compiler) &#123;</span><br><span class="line">  <span class="keyword">const</span> afterEmit = <span class="function">(<span class="params">compilation, cb</span>) =&gt;</span> &#123;</span><br><span class="line">    cb()</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      process.exit(<span class="number">0</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  compiler.plugin(<span class="string">'after-emit'</span>, afterEmit)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = BuildEndPlugin</span><br></pre></td></tr></table></figure><script>export default {  mounted () {    var script = document.createElement("script");    script.type = "text/javascript"    script.charset="UTF-8"    script.src = "http://tajs.qq.com/stats?sId=59154049"    document.body.appendChild(script);  }}</script><script>export default {  mounted () {    var script = document.createElement("script");    script.type = "text/javascript"    script.charset="UTF-8"    script.src = "http://tajs.qq.com/stats?sId=59154049"    document.body.appendChild(script);  }}</script>]]></content>
      
      
      <categories>
          
          <category> 资料整理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript知识 -继承</title>
      <link href="/2017/06/25/JavaScript%E7%9F%A5%E8%AF%86%20-%20%E7%BB%A7%E6%89%BF/"/>
      <url>/2017/06/25/JavaScript%E7%9F%A5%E8%AF%86%20-%20%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<h5 id="JavaScript知识-继承"><a href="#JavaScript知识-继承" class="headerlink" title="JavaScript知识 - 继承"></a>JavaScript知识 - 继承</h5><p>JavaScript资料整理</p><a id="more"></a><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><blockquote><p>在 ES5 中，我们可以使用如下方式解决继承的问题</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Super.prototype.getNumber = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> Sub()</span><br><span class="line">Sub.prototype = <span class="built_in">Object</span>.create(Super.prototype, &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: &#123;</span><br><span class="line">    value: Sub,</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>以上继承实现思路就是将子类的原型设置为父类的原型</li><li>在 <code>ES6</code> 中，我们可以通过 <code>class</code> 语法轻松解决这个问题</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDate</span> <span class="keyword">extends</span> <span class="title">Date</span> </span>&#123;</span><br><span class="line">  test() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.getTime()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myDate = <span class="keyword">new</span> MyDate()</span><br><span class="line">myDate.test()</span><br></pre></td></tr></table></figure><ul><li>但是 <code>ES6</code> 不是所有浏览器都兼容，所以我们需要使用 <code>Babel</code> 来编译这段代码。</li><li>如果你使用编译过得代码调用 <code>myDate.test()</code>你会惊奇地发现出现了报错</li></ul><blockquote><p>因为在 <code>JS</code> 底层有限制，如果不是由 <code>Date</code>构造出来的实例的话，是不能调用 <code>Date</code> 里的函数的。所以这也侧面的说明了：<code>ES6</code> 中的 <code>class</code> 继承与 <code>ES5</code> 中的一般继承写法是不同的。</p></blockquote><ul><li>既然底层限制了实例必须由 <code>Date</code> 构造出来，那么我们可以改变下思路实现继承</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">MyData.prototype.test = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.getTime()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(d, MyData.prototype)</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(MyData.prototype, <span class="built_in">Date</span>.prototype)</span><br></pre></td></tr></table></figure><ul><li>以上继承实现思路：先创建父类实例 =&gt; 改变实例原先的 <code>_proto__</code>转而连接到子类的 <code>prototype</code>=&gt; 子类的 <code>prototype</code> 的 <code>__proto__</code> 改为父类的 <code>prototype</code>。</li><li>通过以上方法实现的继承就可以完美解决 <code>JS</code> 底层的这个限制</li></ul>]]></content>
      
      
      <categories>
          
          <category> 小知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript知识- 闭包</title>
      <link href="/2017/06/25/JavaScript%E7%9F%A5%E8%AF%86%20-%20%E9%97%AD%E5%8C%85/"/>
      <url>/2017/06/25/JavaScript%E7%9F%A5%E8%AF%86%20-%20%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h5 id="JavaScript知识-闭包"><a href="#JavaScript知识-闭包" class="headerlink" title="JavaScript知识 - 闭包"></a>JavaScript知识 - 闭包</h5><p>JavaScript资料整理</p><a id="more"></a><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><blockquote><p>闭包的定义很简单：函数 A 返回了一个函数 B，并且函数 B 中使用了函数 A 的变量，函数 B 就被称为闭包。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(a)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> B</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>你是否会疑惑，为什么函数 <code>A</code>已经弹出调用栈了，为什么函数 <code>B</code> 还能引用到函数 <code>A</code>中的变量。因为函数 <code>A</code> 中的变量这时候是存储在堆上的。现在的 <code>JS</code>引擎可以通过逃逸分析辨别出哪些变量需要存储在堆上，哪些需要存储在栈上。</p></blockquote><p>经典面试题，循环中使用闭包解决 var 定义函数的问题</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ( <span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( i );</span><br><span class="line">&#125;, i*<span class="number">1000</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先因为 <code>setTimeout</code> 是个异步函数，所有会先把循环全部执行完毕，这时候 <code>i</code> 就是 <code>6</code> 了，所以会输出一堆 <code>6</code>。</li><li>解决办法两种，第一种使用闭包</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(j);</span><br><span class="line">    &#125;, j * <span class="number">1000</span>);</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第二种就是使用 <code>setTimeout</code> 的第三个参数</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ( <span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params">j</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( j );</span><br><span class="line">&#125;, i*<span class="number">1000</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>第三种就是使用 <code>let</code> 定义 <code>i</code> 了</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> ( <span class="keyword">let</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( i );</span><br><span class="line">&#125;, i*<span class="number">1000</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>因为对于 <code>let</code> 来说，他会创建一个块级作用域，相当于</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123; <span class="comment">// 形成块级作用域</span></span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> ii = i</span><br><span class="line">    setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( i );</span><br><span class="line">    &#125;, i*<span class="number">1000</span> );</span><br><span class="line">  &#125;</span><br><span class="line">  i++</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> ii = i</span><br><span class="line">  &#125;</span><br><span class="line">  i++</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> ii = i</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 小知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>前端基础 - 高频考点</title>
      <link href="/2017/06/22/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%20-%20%E9%AB%98%E9%A2%91%E8%80%83%E7%82%B9/"/>
      <url>/2017/06/22/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%20-%20%E9%AB%98%E9%A2%91%E8%80%83%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h5 id="前端基础-高频考点"><a href="#前端基础-高频考点" class="headerlink" title="前端基础 - 高频考点"></a>前端基础 - 高频考点</h5><p>资料整理</p><a id="more"></a><h1 id="第五部分：高频考点"><a href="#第五部分：高频考点" class="headerlink" title="第五部分：高频考点"></a>第五部分：高频考点</h1><h2 id="1-typeof类型判断"><a href="#1-typeof类型判断" class="headerlink" title="1 typeof类型判断"></a>1 typeof类型判断</h2><blockquote><p><code>typeof</code> 是否能正确判断类型？<code>instanceof</code> 能正确判断对象的原理是什么</p></blockquote><ul><li><code>typeof</code> 对于原始类型来说，除了 <code>null</code> 都可以显示正确的类型</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">1</span> <span class="comment">// 'number'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">'1'</span> <span class="comment">// 'string'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">// 'undefined'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span> <span class="comment">// 'boolean'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>() <span class="comment">// 'symbol'</span></span><br></pre></td></tr></table></figure><blockquote><p><code>typeof</code> 对于对象来说，除了函数都会显示 <code>object</code>，所以说 <code>typeof</code> 并不能准确判断变量到底是什么类型</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> [] <span class="comment">// 'object'</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125; <span class="comment">// 'object'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">console</span>.log <span class="comment">// 'function'</span></span><br></pre></td></tr></table></figure><blockquote><p>如果我们想判断一个对象的正确类型，这时候可以考虑使用 <code>instanceof</code>，因为内部机制是通过原型链来判断的</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Person()</span><br><span class="line">p1 <span class="keyword">instanceof</span> Person <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'hello world'</span></span><br><span class="line">str <span class="keyword">instanceof</span> <span class="built_in">String</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str1 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'hello world'</span>)</span><br><span class="line">str1 <span class="keyword">instanceof</span> <span class="built_in">String</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><blockquote><p>对于原始类型来说，你想直接通过 <code>instanceof</code>来判断类型是不行的</p></blockquote><h2 id="2-类型转换"><a href="#2-类型转换" class="headerlink" title="2 类型转换"></a>2 类型转换</h2><blockquote><p>首先我们要知道，在 <code>JS</code> 中类型转换只有三种情况，分别是：</p></blockquote><ul><li>转换为布尔值</li><li>转换为数字</li><li>转换为字符串</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/1480597-c1ede6d7eb711a22.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><strong>转Boolean</strong></p><blockquote><p>在条件判断时，除了 <code>undefined</code>，<code>null</code>， <code>false</code>， <code>NaN</code>， <code>&#39;&#39;</code>， <code>0</code>， <code>-0</code>，其他所有值都转为 <code>true</code>，包括所有对象</p></blockquote><p><strong>对象转原始类型</strong></p><blockquote><p>对象在转换类型的时候，会调用内置的 <code>[[ToPrimitive]]</code> 函数，对于该函数来说，算法逻辑一般来说如下</p></blockquote><ul><li>如果已经是原始类型了，那就不需要转换了</li><li>调用 <code>x.valueOf()</code>，如果转换为基础类型，就返回转换的值</li><li>调用 <code>x.toString()</code>，如果转换为基础类型，就返回转换的值</li><li>如果都没有返回原始类型，就会报错</li></ul><blockquote><p>当然你也可以重写 <code>Symbol.toPrimitive</code>，该方法在转原始类型时调用优先级最高。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  valueOf() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'1'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  [<span class="built_in">Symbol</span>.toPrimitive]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1</span> + a <span class="comment">// =&gt; 3</span></span><br></pre></td></tr></table></figure><p><strong>四则运算符</strong></p><blockquote><p>它有以下几个特点：</p></blockquote><ul><li>运算中其中一方为字符串，那么就会把另一方也转换为字符串</li><li>如果一方不是字符串或者数字，那么会将它转换为数字或者字符串</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="string">'1'</span> <span class="comment">// '11'</span></span><br><span class="line"><span class="literal">true</span> + <span class="literal">true</span> <span class="comment">// 2</span></span><br><span class="line"><span class="number">4</span> + [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] <span class="comment">// "41,2,3"</span></span><br></pre></td></tr></table></figure><ul><li>对于第一行代码来说，触发特点一，所以将数字 <code>1</code> 转换为字符串，得到结果 <code>&#39;11&#39;</code></li><li>对于第二行代码来说，触发特点二，所以将 <code>true</code> 转为数字 <code>1</code></li><li>对于第三行代码来说，触发特点二，所以将数组通过 <code>toString</code>转为字符串 <code>1,2,3</code>，得到结果 <code>41,2,3</code></li></ul><blockquote><p>另外对于加法还需要注意这个表达式 <code>&#39;a&#39; + + &#39;b&#39;</code></p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;a&#39; + + &#39;b&#39; &#x2F;&#x2F; -&gt; &quot;aNaN&quot;</span><br></pre></td></tr></table></figure><ul><li>因为 <code>+ &#39;b&#39;</code> 等于 <code>NaN</code>，所以结果为 <code>&quot;aNaN&quot;</code>，你可能也会在一些代码中看到过 <code>+ &#39;1&#39;</code>的形式来快速获取 <code>number</code> 类型。</li><li>那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span> * <span class="string">'3'</span> <span class="comment">// 12</span></span><br><span class="line"><span class="number">4</span> * [] <span class="comment">// 0</span></span><br><span class="line"><span class="number">4</span> * [<span class="number">1</span>, <span class="number">2</span>] <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><p><strong>比较运算符</strong></p><ul><li>如果是对象，就通过 <code>toPrimitive</code> 转换对象</li><li>如果是字符串，就通过 <code>unicode</code> 字符索引来比较</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  valueOf() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'1'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">a &gt; <span class="number">-1</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><blockquote><p>在以上代码中，因为 <code>a</code> 是对象，所以会通过 <code>valueOf</code> 转换为原始类型再比较值。</p></blockquote><h2 id="3-This"><a href="#3-This" class="headerlink" title="3 This"></a>3 This</h2><blockquote><p>我们先来看几个函数调用的场景</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">foo()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  foo: foo</span><br><span class="line">&#125;</span><br><span class="line">obj.foo()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> foo()</span><br></pre></td></tr></table></figure><ul><li>对于直接调用 <code>foo</code> 来说，不管 <code>foo</code> 函数被放在了什么地方，<code>this</code> 一定是<code>window</code></li><li>对于 <code>obj.foo()</code> 来说，我们只需要记住，谁调用了函数，谁就是 <code>this</code>，所以在这个场景下 <code>foo</code> 函数中的 <code>this</code> 就是 <code>obj</code> 对象</li><li>对于 <code>new</code> 的方式来说，<code>this</code> 被永远绑定在了 <code>c</code> 上面，不会被任何方式改变 <code>this</code></li></ul><blockquote><p>说完了以上几种情况，其实很多代码中的 <code>this</code> 应该就没什么问题了，下面让我们看看箭头函数中的 <code>this</code></p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a()()())</span><br></pre></td></tr></table></figure><ul><li>首先箭头函数其实是没有 <code>this</code> 的，箭头函数中的 <code>this</code> 只取决包裹箭头函数的第一个普通函数的 <code>this</code>。在这个例子中，因为包裹箭头函数的第一个普通函数是 <code>a</code>，所以此时的 <code>this</code> 是 <code>window</code>。另外对箭头函数使用 <code>bind</code>这类函数是无效的。</li><li>最后种情况也就是 <code>bind</code> 这些改变上下文的 <code>API</code> 了，对于这些函数来说，<code>this</code> 取决于第一个参数，如果第一个参数为空，那么就是 <code>window</code>。</li><li>那么说到 <code>bind</code>，不知道大家是否考虑过，如果对一个函数进行多次 <code>bind</code>，那么上下文会是什么呢？</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="keyword">this</span>) &#125;</span><br><span class="line">fn.bind().bind(a)() <span class="comment">// =&gt; ?</span></span><br></pre></td></tr></table></figure><blockquote><p>如果你认为输出结果是 <code>a</code>，那么你就错了，其实我们可以把上述代码转换成另一种形式</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fn.bind().bind(a) 等于</span></span><br><span class="line"><span class="keyword">let</span> fn2 = <span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.apply()</span><br><span class="line">  &#125;.apply(a)</span><br><span class="line">&#125;</span><br><span class="line">fn2()</span><br></pre></td></tr></table></figure><blockquote><p>可以从上述代码中发现，不管我们给函数 <code>bind</code> 几次，<code>fn</code> 中的 <code>this</code> 永远由第一次 <code>bind</code> 决定，所以结果永远是 <code>window</code></p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123; <span class="attr">name</span>: <span class="string">'poetries'</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line">foo.bind(a)() <span class="comment">// =&gt; 'poetries'</span></span><br></pre></td></tr></table></figure><blockquote><p>以上就是 <code>this</code> 的规则了，但是可能会发生多个规则同时出现的情况，这时候不同的规则之间会根据优先级最高的来决定 <code>this</code> 最终指向哪里。</p></blockquote><blockquote><p>首先，<code>new</code> 的方式优先级最高，接下来是 <code>bind</code> 这些函数，然后是 <code>obj.foo()</code> 这种调用方式，最后是 <code>foo</code> 这种调用方式，同时，箭头函数的 <code>this</code> 一旦被绑定，就不会再被任何方式所改变。</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/1480597-ce6e82dfdc1b3415.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="4-和-有什么区别"><a href="#4-和-有什么区别" class="headerlink" title="4 == 和 === 有什么区别"></a>4 == 和 === 有什么区别</h2><blockquote><p>对于 <code>==</code> 来说，如果对比双方的类型不一样的话，就会进行类型转换</p></blockquote><p><strong>假如我们需要对比 x 和 y 是否相同，就会进行如下判断流程</strong></p><ol><li>首先会判断两者类型是否相同。相同的话就是比大小了</li><li>类型不相同的话，那么就会进行类型转换</li><li>会先判断是否在对比 <code>null</code> 和 <code>undefined</code>，是的话就会返回 <code>true</code></li><li>判断两者类型是否为 <code>string</code> 和 <code>number</code>，是的话就会将字符串转换为 <code>number</code></li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 &#x3D;&#x3D; &#39;1&#39;</span><br><span class="line">      ↓</span><br><span class="line">1 &#x3D;&#x3D;  1</span><br></pre></td></tr></table></figure><ol start="5"><li>判断其中一方是否为 <code>boolean</code>，是的话就会把 <code>boolean</code> 转为 <code>number</code> 再进行判断</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;1&#39; &#x3D;&#x3D; true</span><br><span class="line">        ↓</span><br><span class="line">&#39;1&#39; &#x3D;&#x3D;  1</span><br><span class="line">        ↓</span><br><span class="line"> 1  &#x3D;&#x3D;  1</span><br></pre></td></tr></table></figure><ol start="6"><li>判断其中一方是否为 <code>object</code> 且另一方为 <code>string</code>、<code>number</code> 或者 <code>symbol</code>，是的话就会把 <code>object</code> 转为原始类型再进行判断</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;1&#39; &#x3D;&#x3D; &#123; name: &#39;yck&#39; &#125;</span><br><span class="line">        ↓</span><br><span class="line">&#39;1&#39; &#x3D;&#x3D; &#39;[object Object]&#39;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/1480597-88daf8ffd440c0dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><blockquote><p>对于 <code>===</code> 来说就简单多了，就是判断两者类型和值是否相同</p></blockquote><h2 id="5-闭包"><a href="#5-闭包" class="headerlink" title="5 闭包"></a>5 闭包</h2><blockquote><p>闭包的定义其实很简单：函数 <code>A</code> 内部有一个函数 <code>B</code>，函数 <code>B</code> 可以访问到函数 <code>A</code> 中的变量，那么函数 <code>B</code> 就是闭包</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">  <span class="built_in">window</span>.B = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(a)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">A()</span><br><span class="line">B() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p><strong>闭包存在的意义就是让我们可以间接访问函数内部的变量</strong></p><blockquote><p>经典面试题，循环中使用闭包解决 <code>var</code> 定义函数的问题</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;, i * <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>首先因为 <code>setTimeout</code> 是个异步函数，所以会先把循环全部执行完毕，这时候 <code>i</code>就是 <code>6</code> 了，所以会输出一堆 <code>6</code></p></blockquote><p><strong>解决办法有三种</strong></p><ol><li>第一种是使用闭包的方式</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  ;(<span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(j)</span><br><span class="line">    &#125;, j * <span class="number">1000</span>)</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在上述代码中，我们首先使用了立即执行函数将 <code>i</code> 传入函数内部，这个时候值就被固定在了参数 <code>j</code> 上面不会改变，当下次执行 <code>timer</code> 这个闭包的时候，就可以使用外部函数的变量 <code>j</code>，从而达到目的</p></blockquote><ol start="2"><li>第二种就是使用 <code>setTimeout</code> 的第三个参数，这个参数会被当成 <code>timer</code> 函数的参数传入</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  setTimeout(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params">j</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(j)</span><br><span class="line">    &#125;,</span><br><span class="line">    i * <span class="number">1000</span>,</span><br><span class="line">    i</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>第三种就是使用 <code>let</code> 定义 <code>i</code> 了来解决问题了，这个也是最为推荐的方式</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;, i * <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-深浅拷贝"><a href="#6-深浅拷贝" class="headerlink" title="6 深浅拷贝"></a>6 深浅拷贝</h2><p><strong>浅拷贝</strong></p><blockquote><p>首先可以通过 <code>Object.assign</code> 来解决这个问题，很多人认为这个函数是用来深拷贝的。其实并不是，<code>Object.assign</code> 只会拷贝所有的属性值到新的对象中，如果属性值是对象的话，拷贝的是地址，所以并不是深拷贝</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  age: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Object</span>.assign(&#123;&#125;, a)</span><br><span class="line">a.age = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(b.age) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><blockquote><p>另外我们还可以通过展开运算符 <code>...</code> 来实现浅拷贝</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  age: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = &#123; ...a &#125;</span><br><span class="line">a.age = <span class="number">2</span></span><br><span class="line"><span class="built_in">console</span>.log(b.age) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><blockquote><p>通常浅拷贝就能解决大部分问题了，但是当我们遇到如下情况就可能需要使用到深拷贝了</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  age: <span class="number">1</span>,</span><br><span class="line">  jobs: &#123;</span><br><span class="line">    first: <span class="string">'FE'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = &#123; ...a &#125;</span><br><span class="line">a.jobs.first = <span class="string">'native'</span></span><br><span class="line"><span class="built_in">console</span>.log(b.jobs.first) <span class="comment">// native</span></span><br></pre></td></tr></table></figure><blockquote><p>浅拷贝只解决了第一层的问题，如果接下去的值中还有对象的话，那么就又回到最开始的话题了，两者享有相同的地址。要解决这个问题，我们就得使用深拷贝了。</p></blockquote><p><strong>深拷贝</strong></p><blockquote><p>这个问题通常可以通过 <code>JSON.parse(JSON.stringify(object))</code> 来解决。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  age: <span class="number">1</span>,</span><br><span class="line">  jobs: &#123;</span><br><span class="line">    first: <span class="string">'FE'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(a))</span><br><span class="line">a.jobs.first = <span class="string">'native'</span></span><br><span class="line"><span class="built_in">console</span>.log(b.jobs.first) <span class="comment">// FE</span></span><br></pre></td></tr></table></figure><p><strong>但是该方法也是有局限性的</strong>：</p><ul><li>会忽略 <code>undefined</code></li><li>会忽略 <code>symbol</code></li><li>不能序列化函数</li><li>不能解决循环引用的对象</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: &#123;</span><br><span class="line">    c: <span class="number">2</span>,</span><br><span class="line">    d: <span class="number">3</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">obj.c = obj.b</span><br><span class="line">obj.e = obj.a</span><br><span class="line">obj.b.c = obj.c</span><br><span class="line">obj.b.d = obj.b</span><br><span class="line">obj.b.e = obj.b.c</span><br><span class="line"><span class="keyword">let</span> newObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj))</span><br><span class="line"><span class="built_in">console</span>.log(newObj)</span><br></pre></td></tr></table></figure><blockquote><p>更多详情 <a href="https://www.jianshu.com/p/2d8a26b3958f" target="_blank" rel="noopener">https://www.jianshu.com/p/2d8a26b3958f</a></p></blockquote><h2 id="7-原型"><a href="#7-原型" class="headerlink" title="7 原型"></a>7 原型</h2><blockquote><p>原型链就是多个对象通过 <code>__proto__</code> 的方式连接了起来。为什么 <code>obj</code> 可以访问到 <code>valueOf</code> 函数，就是因为 <code>obj</code> 通过原型链找到了 <code>valueOf</code> 函数</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/11/16/1671d387e4189ec8" alt=""></p><ul><li><code>Object</code> 是所有对象的爸爸，所有对象都可以通过 <code>__proto__</code>找到它</li><li><code>Function</code> 是所有函数的爸爸，所有函数都可以通过 <code>__proto__</code> 找到它</li><li>函数的 <code>prototype</code> 是一个对象</li><li>对象的<code>__proto__</code> 属性指向原型， <code>__proto__</code> 将对象和原型连接起来组成了原型链</li></ul><h2 id="8-var、let-及-const-区别"><a href="#8-var、let-及-const-区别" class="headerlink" title="8 var、let 及 const 区别"></a>8 var、let 及 const 区别</h2><blockquote><p>涉及面试题：什么是提升？什么是暂时性死区？var、let 及 const 区别？</p></blockquote><ul><li>函数提升优先于变量提升，函数提升会把整个函数挪到作用域顶部，变量提升只会把声明挪到作用域顶部</li><li><code>var</code> 存在提升，我们能在声明之前使用。<code>let</code>、<code>const</code> 因为暂时性死区的原因，不能在声明前使用</li><li><code>var</code> 在全局作用域下声明变量会导致变量挂载在 <code>window</code>上，其他两者不会</li><li><code>let</code> 和 <code>const</code> 作用基本一致，但是后者声明的变量不能再次赋值</li></ul><h2 id="9-原型继承和-Class-继承"><a href="#9-原型继承和-Class-继承" class="headerlink" title="9 原型继承和 Class 继承"></a>9 原型继承和 Class 继承</h2><blockquote><p>涉及面试题：原型如何实现继承？<code>Class</code> 如何实现继承？<code>Class</code> 本质是什么？</p></blockquote><p>首先先来讲下 <code>class</code>，其实在 <code>JS</code>中并不存在类，<code>class</code> 只是语法糖，本质还是函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line">Person <span class="keyword">instanceof</span> <span class="built_in">Function</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>组合继承</strong></p><blockquote><p>组合继承是最常用的继承方式</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.val = value</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.getValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.val)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="keyword">this</span>, value)</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> Child(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">child.getValue() <span class="comment">// 1</span></span><br><span class="line">child <span class="keyword">instanceof</span> Parent <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li>以上继承的方式核心是在子类的构造函数中通过 <code>Parent.call(this)</code> 继承父类的属性，然后改变子类的原型为 <code>new Parent()</code> 来继承父类的函数。</li><li>这种继承方式优点在于构造函数可以传参，不会与父类引用属性共享，可以复用父类的函数，但是也存在一个缺点就是在继承父类函数的时候调用了父类构造函数，导致子类的原型上多了不需要的父类属性，存在内存上的浪费</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/11/19/1672aeb24a2e2cae" alt=""></p><p><strong>寄生组合继承</strong></p><blockquote><p>这种继承方式对组合继承进行了优化，组合继承缺点在于继承父类函数时调用了构造函数，我们只需要优化掉这点就行了</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.val = value</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.getValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="keyword">this</span>, value)</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="built_in">Object</span>.create(Parent.prototype, &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: &#123;</span><br><span class="line">    value: Child,</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> Child(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">child.getValue() <span class="comment">// 1</span></span><br><span class="line">child <span class="keyword">instanceof</span> Parent <span class="comment">// true</span></span><br></pre></td></tr></table></figure><blockquote><p>以上继承实现的核心就是将父类的原型赋值给了子类，并且将构造函数设置为子类，这样既解决了无用的父类属性问题，还能正确的找到子类的构造函数。</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/11/19/1672afb8dfa21361" alt=""></p><p><strong>Class 继承</strong></p><blockquote><p>以上两种继承方式都是通过原型去解决的，在 ES6 中，我们可以使用 class 去实现继承，并且实现起来很简单</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.val = value</span><br><span class="line">  &#125;</span><br><span class="line">  getValue() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.val)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">    <span class="keyword">super</span>(value)</span><br><span class="line">    <span class="keyword">this</span>.val = value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> child = <span class="keyword">new</span> Child(<span class="number">1</span>)</span><br><span class="line">child.getValue() <span class="comment">// 1</span></span><br><span class="line">child <span class="keyword">instanceof</span> Parent <span class="comment">// true</span></span><br></pre></td></tr></table></figure><blockquote><p><code>class</code> 实现继承的核心在于使用 <code>extends</code> 表明继承自哪个父类，并且在子类构造函数中必须调用 <code>super</code>，因为这段代码可以看成 <code>Parent.call(this, value)</code>。</p></blockquote><h2 id="10-模块化"><a href="#10-模块化" class="headerlink" title="10 模块化"></a>10 模块化</h2><blockquote><p>涉及面试题：为什么要使用模块化？都有哪几种方式可以实现模块化，各有什么特点？</p></blockquote><p>使用一个技术肯定是有原因的，那么使用模块化可以给我们带来以下好处</p><ul><li>解决命名冲突</li><li>提供复用性</li><li>提高代码可维护性</li></ul><p><strong>立即执行函数</strong></p><blockquote><p>在早期，使用立即执行函数实现模块化是常见的手段，通过函数作用域解决了命名冲突、污染全局作用域的问题</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(function(globalVariable)&#123;</span><br><span class="line">   globalVariable.test &#x3D; function() &#123;&#125;</span><br><span class="line">   &#x2F;&#x2F; ... 声明各种变量、函数都不会污染全局作用域</span><br><span class="line">&#125;)(globalVariable)</span><br></pre></td></tr></table></figure><p><strong>AMD 和 CMD</strong></p><blockquote><p>鉴于目前这两种实现方式已经很少见到，所以不再对具体特性细聊，只需要了解这两者是如何使用的。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AMD</span></span><br><span class="line">define([<span class="string">'./a'</span>, <span class="string">'./b'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 加载模块完毕可以使用</span></span><br><span class="line">  a.do()</span><br><span class="line">  b.do()</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// CMD</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 加载模块</span></span><br><span class="line">  <span class="comment">// 可以把 require 写在函数体的任意地方实现延迟加载</span></span><br><span class="line">  <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>)</span><br><span class="line">  a.doSomething()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>CommonJS</strong></p><blockquote><p><code>CommonJS</code> 最早是 <code>Node</code> 在使用，目前也仍然广泛使用，比如在 <code>Webpack</code> 中你就能见到它，当然目前在 <code>Node</code> 中的模块管理已经和 <code>CommonJS</code>有一些区别了</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    a: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line">exports.a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = <span class="built_in">require</span>(<span class="string">'./a.js'</span>)</span><br><span class="line"><span class="built_in">module</span>.a <span class="comment">// -&gt; log 1</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ar <span class="built_in">module</span> = <span class="built_in">require</span>(<span class="string">'./a.js'</span>)</span><br><span class="line"><span class="built_in">module</span>.a</span><br><span class="line"><span class="comment">// 这里其实就是包装了一层立即执行函数，这样就不会污染全局变量了，</span></span><br><span class="line"><span class="comment">// 重要的是 module 这里，module 是 Node 独有的一个变量</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    a: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// module 基本实现</span></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = &#123;</span><br><span class="line">  id: <span class="string">'xxxx'</span>, <span class="comment">// 我总得知道怎么去找到他吧</span></span><br><span class="line">  exports: &#123;&#125; <span class="comment">// exports 就是个空对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这个是为什么 exports 和 module.exports 用法相似的原因</span></span><br><span class="line"><span class="keyword">var</span> exports = <span class="built_in">module</span>.exports</span><br><span class="line"><span class="keyword">var</span> load = <span class="function"><span class="keyword">function</span> (<span class="params">module</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 导出的东西</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">    <span class="built_in">module</span>.exports = a</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">module</span>.exports</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 然后当我 require 的时候去找到独特的</span></span><br><span class="line"><span class="comment">// id，然后将要使用的东西用立即执行函数包装下，over</span></span><br></pre></td></tr></table></figure><blockquote><p>另外虽然 <code>exports</code> 和 <code>module.exports</code> 用法相似，但是不能对 <code>exports</code> 直接赋值。因为 <code>var exports = module.exports</code> 这句代码表明了 <code>exports</code> 和 <code>module.exports</code>享有相同地址，通过改变对象的属性值会对两者都起效，但是如果直接对 <code>exports</code> 赋值就会导致两者不再指向同一个内存地址，修改并不会对 <code>module.exports</code> 起效</p></blockquote><p><strong>ES Module</strong></p><blockquote><p><code>ES Module</code> 是原生实现的模块化方案，与 <code>CommonJS</code> 有以下几个区别</p></blockquote><ol><li><code>CommonJS</code> 支持动态导入，也就是 <code>require(${path}/xx.js)</code>，后者目前不支持，但是已有提案</li><li><code>CommonJS</code> 是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响</li><li><code>CommonJS</code> 在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。但是 <code>ES Module</code> 采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化</li><li><code>ES Module</code> 会编译成 <code>require/exports</code>来执行的</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入模块 API</span></span><br><span class="line"><span class="keyword">import</span> XXX <span class="keyword">from</span> <span class="string">'./a.js'</span></span><br><span class="line"><span class="keyword">import</span> &#123; XXX &#125; <span class="keyword">from</span> <span class="string">'./a.js'</span></span><br><span class="line"><span class="comment">// 导出模块 API</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="11-实现一个简洁版的promise"><a href="#11-实现一个简洁版的promise" class="headerlink" title="11 实现一个简洁版的promise"></a>11 实现一个简洁版的promise</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 三个常量用于表示状态</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">'pending'</span></span><br><span class="line"><span class="keyword">const</span> RESOLVED = <span class="string">'resolved'</span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">'rejected'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> that = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">this</span>.state = PENDING</span><br><span class="line"></span><br><span class="line">    <span class="comment">// value 变量用于保存 resolve 或者 reject 中传入的值</span></span><br><span class="line">    <span class="keyword">this</span>.value = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于保存 then 中的回调，因为当执行完 Promise 时状态可能还是等待中，这时候应该把 then 中的回调保存起来用于状态改变时使用</span></span><br><span class="line">    that.resolvedCallbacks = []</span><br><span class="line">    that.rejectedCallbacks = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">         <span class="comment">// 首先两个函数都得判断当前状态是否为等待中</span></span><br><span class="line">        <span class="keyword">if</span>(that.state === PENDING) &#123;</span><br><span class="line">            that.state = RESOLVED</span><br><span class="line">            that.value = value</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历回调数组并执行</span></span><br><span class="line">            that.resolvedCallbacks.map(<span class="function"><span class="params">cb</span>=&gt;</span>cb(that.value))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(that.state === PENDING) &#123;</span><br><span class="line">            that.state = REJECTED</span><br><span class="line">            that.value = value</span><br><span class="line">            that.rejectedCallbacks.map(<span class="function"><span class="params">cb</span>=&gt;</span>cb(that.value))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 完成以上两个函数以后，我们就该实现如何执行 Promise 中传入的函数了</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fn(resolve,reject)</span><br><span class="line">    &#125;cach(e)&#123;</span><br><span class="line">        reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后我们来实现较为复杂的 then 函数</span></span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled,onRejected</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> that = <span class="keyword">this</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断两个参数是否为函数类型，因为这两个参数是可选参数</span></span><br><span class="line">  onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">'function'</span> ? onFulfilled : <span class="function"><span class="params">v</span>=&gt;</span>v</span><br><span class="line">  onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span> ? onRejected : <span class="function"><span class="params">e</span>=&gt;</span><span class="keyword">throw</span> e</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当状态不是等待态时，就去执行相对应的函数。如果状态是等待态的话，就往回调函数中 push 函数</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>.state === PENDING) &#123;</span><br><span class="line">      <span class="keyword">this</span>.resolvedCallbacks.push(onFulfilled)</span><br><span class="line">      <span class="keyword">this</span>.rejectedCallbacks.push(onRejected)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>.state === RESOLVED) &#123;</span><br><span class="line">      onFulfilled(that.value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">this</span>.state === REJECTED) &#123;</span><br><span class="line">      onRejected(that.value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-Event-Loop"><a href="#12-Event-Loop" class="headerlink" title="12 Event Loop"></a>12 Event Loop</h2><h3 id="12-1-进程与线程"><a href="#12-1-进程与线程" class="headerlink" title="12.1 进程与线程"></a>12.1 进程与线程</h3><blockquote><p>涉及面试题：进程与线程区别？<code>JS</code> 单线程带来的好处？</p></blockquote><ul><li><code>JS</code> 是单线程执行的，但是你是否疑惑过什么是线程？</li><li>讲到线程，那么肯定也得说一下进程。本质上来说，两个名词都是 <code>CPU</code> 工作时间片的一个描述。</li><li>进程描述了 <code>CPU</code> 在运行指令及加载和保存上下文所需的时间，放在应用上来说就代表了一个程序。线程是进程中的更小单位，描述了执行一段指令所需的时间</li></ul><blockquote><p>把这些概念拿到浏览器中来说，当你打开一个 <code>Tab</code> 页时，其实就是创建了一个进程，一个进程中可以有多个线程，比如渲染线程、<code>JS</code> 引擎线程、<code>HTTP</code> 请求线程等等。当你发起一个请求时，其实就是创建了一个线程，当请求结束后，该线程可能就会被销毁</p></blockquote><ul><li>上文说到了 <code>JS</code> 引擎线程和渲染线程，大家应该都知道，在 <code>JS</code> 运行的时候可能会阻止 <code>UI</code> 渲染，这说明了两个线程是互斥的。这其中的原因是因为 JS 可以修改 <code>DOM</code>，如果在 <code>JS</code> 执行的时候 <code>UI</code> 线程还在工作，就可能导致不能安全的渲染 <code>UI</code>。这其实也是一个单线程的好处，得益于 <code>JS</code> 是单线程运行的，可以达到节省内存，节约上下文切换时间，没有锁的问题的好处</li></ul><h3 id="12-2-执行栈"><a href="#12-2-执行栈" class="headerlink" title="12.2 执行栈"></a>12.2 执行栈</h3><blockquote><p>涉及面试题：什么是执行栈？</p></blockquote><p>可以把执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则</p><p><img src="https://user-gold-cdn.xitu.io/2018/11/13/1670d2d20ead32ec" alt=""></p><blockquote><p>当开始执行 <code>JS</code> 代码时，首先会执行一个 <code>main</code> 函数，然后执行我们的代码。根据先进后出的原则，后执行的函数会先弹出栈，在图中我们也可以发现，<code>foo</code> 函数后执行，当执行完毕后就从栈中弹出了</p></blockquote><p>在开发中，大家也可以在报错中找到执行栈的痕迹</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  foo()</span><br><span class="line">&#125;</span><br><span class="line">bar()</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2018/11/13/1670c0e21540090c" alt=""></p><blockquote><p>大家可以在上图清晰的看到报错在 <code>foo</code> 函数，<code>foo</code> 函数又是在 <code>bar</code> 函数中调用的</p></blockquote><p>当我们使用递归的时候，因为栈可存放的函数是有限制的，一旦存放了过多的函数且没有得到释放的话，就会出现爆栈的问题</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  bar()</span><br><span class="line">&#125;</span><br><span class="line">bar()</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2018/11/13/1670c128acce975f" alt=""></p><h3 id="12-3-浏览器中的-Event-Loop"><a href="#12-3-浏览器中的-Event-Loop" class="headerlink" title="12.3 浏览器中的 Event Loop"></a>12.3 浏览器中的 Event Loop</h3><blockquote><p>涉及面试题：异步代码执行顺序？解释一下什么是 <code>Event Loop</code> ？</p></blockquote><blockquote><p>众所周知 <code>JS</code> 是门非阻塞单线程语言，因为在最初 <code>JS</code> 就是为了和浏览器交互而诞生的。如果 <code>JS</code> 是门多线程的语言话，我们在多个线程中处理 <code>DOM</code> 就可能会发生问题（一个线程中新加节点，另一个线程中删除节点）</p></blockquote><ul><li><code>JS</code> 在执行的过程中会产生执行环境，这些执行环境会被顺序的加入到执行栈中。如果遇到异步的代码，会被挂起并加入到 <code>Task</code>（有多种 <code>task</code>） 队列中。一旦执行栈为空，<code>Event</code> <code>Loop</code> 就会从 <code>Task</code> 队列中拿出需要执行的代码并放入执行栈中执行，所以本质上来说 <code>JS</code> 中的异步还是同步行为</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/11/23/16740fa4cd9c6937" alt=""></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>);</span><br></pre></td></tr></table></figure><blockquote><p>不同的任务源会被分配到不同的 <code>Task</code> 队列中，任务源可以分为 微任务（<code>microtask</code>） 和 宏任务（<code>macrotask</code>）。在 <code>ES6</code> 规范中，<code>microtask</code> 称为 <code>jobs</code>，<code>macrotask</code> 称为 <code>task</code></p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Promise'</span>)</span><br><span class="line">    resolve()</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise2'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>);</span><br><span class="line"><span class="comment">// script start =&gt; Promise =&gt; script end =&gt; promise1 =&gt; promise2 =&gt; setTimeout</span></span><br></pre></td></tr></table></figure><blockquote><p>以上代码虽然 <code>setTimeout</code> 写在 <code>Promise</code> 之前，但是因为 <code>Promise</code> 属于微任务而 <code>setTimeout</code> 属于宏任务</p></blockquote><p><strong>微任务</strong></p><ul><li><code>process.nextTick</code></li><li><code>promise</code></li><li><code>Object.observe</code></li><li><code>MutationObserver</code></li></ul><p><strong>宏任务</strong></p><ul><li><code>script</code></li><li><code>setTimeout</code></li><li><code>setInterval</code></li><li><code>setImmediate</code></li><li><code>I/O</code></li><li><code>UI rendering</code></li></ul><blockquote><p>宏任务中包括了 <code>script</code> ，浏览器会先执行一个宏任务，接下来有异步代码的话就先执行微任务</p></blockquote><p><strong>所以正确的一次 Event loop 顺序是这样的</strong></p><ul><li>执行同步代码，这属于宏任务</li><li>执行栈为空，查询是否有微任务需要执行</li><li>执行所有微任务</li><li>必要的话渲染 UI</li><li>然后开始下一轮 <code>Event loop</code>，执行宏任务中的异步代码</li></ul><blockquote><p>通过上述的 <code>Event loop</code> 顺序可知，如果宏任务中的异步代码有大量的计算并且需要操作 <code>DOM</code> 的话，为了更快的响应界面响应，我们可以把操作 <code>DOM</code> 放入微任务中</p></blockquote><h3 id="12-4-Node-中的-Event-loop"><a href="#12-4-Node-中的-Event-loop" class="headerlink" title="12.4 Node 中的 Event loop"></a>12.4 Node 中的 Event loop</h3><ul><li><code>Node</code> 中的 <code>Event loop</code> 和浏览器中的不相同。</li><li><code>Node</code> 的 <code>Event loop</code> 分为<code>6</code>个阶段，它们会按照顺序反复运行</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">┌───────────────────────┐</span><br><span class="line">┌─&gt;│        timers         │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     I&#x2F;O callbacks     │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     idle, prepare     │</span><br><span class="line">│  └──────────┬────────────┘      ┌───────────────┐</span><br><span class="line">│  ┌──────────┴────────────┐      │   incoming:   │</span><br><span class="line">│  │         poll          │&lt;──connections───     │</span><br><span class="line">│  └──────────┬────────────┘      │   data, etc.  │</span><br><span class="line">│  ┌──────────┴────────────┐      └───────────────┘</span><br><span class="line">│  │        check          │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">└──┤    close callbacks    │</span><br><span class="line">   └───────────────────────┘</span><br></pre></td></tr></table></figure><p><strong>timer</strong></p><ul><li><code>timers</code> 阶段会执行 <code>setTimeout</code> 和 <code>setInterval</code></li><li>一个 timer 指定的时间并不是准确时间，而是在达到这个时间后尽快执行回调，可能会因为系统正在执行别的事务而延迟</li></ul><p><strong>I/O</strong></p><ul><li><code>I/O</code> 阶段会执行除了 <code>close</code> 事件，定时器和 <code>setImmediate</code> 的回调</li></ul><p><strong>poll</strong></p><ul><li><code>poll</code> 阶段很重要，这一阶段中，系统会做两件事情<ul><li>执行到点的定时器</li><li>执行 <code>poll</code> 队列中的事件</li></ul></li><li>并且当 <code>poll</code> 中没有定时器的情况下，会发现以下两件事情<ul><li>如果 <code>poll</code> 队列不为空，会遍历回调队列并同步执行，直到队列为空或者系统限制</li><li>如果 <code>poll</code> 队列为空，会有两件事发生</li><li>如果有 <code>setImmediate</code> 需要执行，<code>poll</code> 阶段会停止并且进入到 <code>check</code> 阶段执行 <code>setImmediate</code></li><li>如果没有 <code>setImmediate</code> 需要执行，会等待回调被加入到队列中并立即执行回调</li><li>如果有别的定时器需要被执行，会回到 <code>timer</code> 阶段执行回调。</li></ul></li></ul><p><strong>check</strong></p><ul><li><code>check</code> 阶段执行 <code>setImmediate</code></li></ul><p><strong>close callbacks</strong></p><ul><li><code>close callbacks</code> 阶段执行 <code>close</code> 事件</li><li>并且在 <code>Node</code> 中，有些情况下的定时器执行顺序是随机的</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line">setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setImmediate'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 这里可能会输出 setTimeout，setImmediate</span></span><br><span class="line"><span class="comment">// 可能也会相反的输出，这取决于性能</span></span><br><span class="line"><span class="comment">// 因为可能进入 event loop 用了不到 1 毫秒，这时候会执行 setImmediate</span></span><br><span class="line"><span class="comment">// 否则会执行 setTimeout</span></span><br></pre></td></tr></table></figure><blockquote><p>上面介绍的都是 <code>macrotask</code> 的执行情况，<code>microtask</code> 会在以上每个阶段完成后立即执行</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timer1'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timer2'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'promise2'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上代码在浏览器和 node 中打印情况是不同的</span></span><br><span class="line"><span class="comment">// 浏览器中一定打印 timer1, promise1, timer2, promise2</span></span><br><span class="line"><span class="comment">// node 中可能打印 timer1, timer2, promise1, promise2</span></span><br><span class="line"><span class="comment">// 也可能打印 timer1, promise1, timer2, promise2</span></span><br></pre></td></tr></table></figure><blockquote><p><code>Node</code> 中的 <code>process.nextTick</code> 会先于其他 <code>microtask</code> 执行</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">"timer1"</span>);</span><br><span class="line"></span><br><span class="line"> <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"promise1"</span>);</span><br><span class="line"> &#125;);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">"nextTick"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// nextTick, timer1, promise1</span></span><br></pre></td></tr></table></figure><blockquote><p>对于 <code>microtask</code> 来说，它会在以上每个阶段完成前清空 <code>microtask</code> 队列，下图中的 <code>Tick</code> 就代表了 <code>microtask</code></p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/11/14/16710fb80dd42d27" alt=""></p><h2 id="13-手写-call、apply-及-bind-函数"><a href="#13-手写-call、apply-及-bind-函数" class="headerlink" title="13 手写 call、apply 及 bind 函数"></a>13 手写 call、apply 及 bind 函数</h2><blockquote><p>首先从以下几点来考虑如何实现这几个函数</p></blockquote><ul><li>不传入第一个参数，那么上下文默认为 <code>window</code></li><li>改变了 <code>this</code> 指向，让新的对象可以执行该函数，并能接受参数</li></ul><p><strong>实现 call</strong></p><ul><li>首先 <code>context</code>为可选参数，如果不传的话默认上下文为 <code>window</code></li><li>接下来给 <code>context</code> 创建一个 <code>fn</code> 属性，并将值设置为需要调用的函数</li><li>因为 <code>call</code> 可以传入多个参数作为调用函数的参数，所以需要将参数剥离出来</li><li>然后调用函数并将对象上的函数删除</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Error'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  context = context || <span class="built_in">window</span></span><br><span class="line">  context.fn = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">const</span> args = [...arguments].slice(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">const</span> result = context.fn(...args)</span><br><span class="line">  <span class="keyword">delete</span> context.fn</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>apply实现</strong></p><blockquote><p><code>apply</code> 的实现也类似，区别在于对参数的处理</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Error'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  context = context || <span class="built_in">window</span></span><br><span class="line">  context.fn = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">let</span> result</span><br><span class="line">  <span class="comment">// 处理参数和 call 有区别</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">arguments</span>[<span class="number">1</span>]) &#123;</span><br><span class="line">    result = context.fn(...arguments[<span class="number">1</span>])</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = context.fn()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> context.fn</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>bind 的实现</strong></p><blockquote><p><code>bind</code> 的实现对比其他两个函数略微地复杂了一点，因为 <code>bind</code> 需要返回一个函数，需要判断一些边界问题，以下是 <code>bind</code> 的实现</p></blockquote><ul><li><code>bind</code> 返回了一个函数，对于函数来说有两种方式调用，一种是直接调用，一种是通过 <code>new</code> 的方式，我们先来说直接调用的方式</li><li>对于直接调用来说，这里选择了 <code>apply</code> 的方式实现，但是对于参数需要注意以下情况：因为 <code>bind</code> 可以实现类似这样的代码 <code>f.bind(obj, 1)(2)</code>，所以我们需要将两边的参数拼接起来，于是就有了这样的实现 <code>args.concat(...arguments)</code></li><li>最后来说通过 <code>new</code> 的方式，在之前的章节中我们学习过如何判断 <code>this</code>，对于 <code>new</code> 的情况来说，不会被任何方式改变 <code>this</code>，所以对于这种情况我们需要忽略传入的 <code>this</code></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Error'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> _this = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">const</span> args = [...arguments].slice(<span class="number">1</span>)</span><br><span class="line">  <span class="comment">// 返回一个函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 因为返回了一个函数，我们可以 new F()，所以需要判断</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> F) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> _this(...args, ...arguments)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _this.apply(context, args.concat(...arguments))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="14-new"><a href="#14-new" class="headerlink" title="14 new"></a>14 new</h2><blockquote><p>涉及面试题：<code>new</code> 的原理是什么？通过 <code>new</code>的方式创建对象和通过字面量创建有什么区别？</p></blockquote><p><strong>在调用 new 的过程中会发生四件事情</strong></p><ul><li>新生成了一个对象</li><li>链接到原型</li><li>绑定 <code>this</code></li><li>返回新对象</li></ul><blockquote><p>根据以上几个过程，我们也可以试着来自己实现一个 new</p></blockquote><ul><li>创建一个空对象</li><li>获取构造函数</li><li>设置空对象的原型</li><li>绑定 <code>this</code> 并执行构造函数</li><li>确保返回值为对象</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">  <span class="keyword">let</span> Con = [].shift.call(<span class="built_in">arguments</span>)</span><br><span class="line">  obj.__proto__ = Con.prototype</span><br><span class="line">  <span class="keyword">let</span> result = Con.apply(obj, <span class="built_in">arguments</span>)</span><br><span class="line">  <span class="keyword">return</span> result <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? result : obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对于对象来说，其实都是通过 <code>new</code> 产生的，无论是 <code>function Foo()</code> 还是 <code>let a = { b : 1 }</code>。</li><li>对于创建一个对象来说，更推荐使用字面量的方式创建对象（无论性能上还是可读性）。因为你使用 <code>new Object()</code> 的方式创建对象需要通过作用域链一层层找到 <code>Object</code>，但是你使用字面量的方式就没这个问题</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// function 就是个语法糖</span></span><br><span class="line"><span class="comment">// 内部等同于 new Function()</span></span><br><span class="line"><span class="keyword">let</span> a = &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="comment">// 这个字面量内部也是使用了 new Object()</span></span><br></pre></td></tr></table></figure><h2 id="15-instanceof-的原理"><a href="#15-instanceof-的原理" class="headerlink" title="15 instanceof 的原理"></a>15 instanceof 的原理</h2><blockquote><p>涉及面试题：<code>instanceof</code> 的原理是什么？</p></blockquote><p><code>instanceof</code> 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 <code>prototype</code></p><p><strong>实现一下 instanceof</strong></p><ul><li>首先获取类型的原型</li><li>然后获得对象的原型</li><li>然后一直循环判断对象的原型是否等于类型的原型，直到对象原型为 <code>null</code>，因为原型链最终为 <code>null</code></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myInstanceof</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> prototype = right.prototype</span><br><span class="line">  left = left.__proto__</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (left === <span class="literal">null</span> || left === <span class="literal">undefined</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> (prototype === left)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    left = left.__proto__</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="16-为什么-0-1-0-2-0-3"><a href="#16-为什么-0-1-0-2-0-3" class="headerlink" title="16 为什么 0.1 + 0.2 != 0.3"></a>16 为什么 0.1 + 0.2 != 0.3</h2><blockquote><p>涉及面试题：为什么 <code>0.1 + 0.2 != 0.3</code>？如何解决这个问题？</p></blockquote><p><strong>原因</strong>，因为 <code>JS</code> 采用 <code>IEEE 754</code>双精度版本（<code>64</code>位），并且只要采用 <code>IEEE 754</code>的语言都有该问题</p><blockquote><p>我们都知道计算机是通过二进制来存储东西的，那么 <code>0.1</code> 在二进制中会表示为</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// (0011) 表示循环</span></span><br><span class="line"><span class="number">0.1</span> = <span class="number">2</span>^<span class="number">-4</span> * <span class="number">1.10011</span>(<span class="number">0011</span>)</span><br></pre></td></tr></table></figure><blockquote><p>我们可以发现，<code>0.1</code> 在二进制中是无限循环的一些数字，其实不只是 <code>0.1</code>，其实很多十进制小数用二进制表示都是无限循环的。这样其实没什么问题，但是 <code>JS</code>采用的浮点数标准却会裁剪掉我们的数字。</p></blockquote><p><strong>IEEE 754 双精度版本（64位）将 64 位分为了三段</strong></p><ul><li>第一位用来表示符号</li><li>接下去的 <code>11</code> 位用来表示指数</li><li>其他的位数用来表示有效位，也就是用二进制表示 <code>0.1</code> 中的 <code>10011(0011)</code></li></ul><blockquote><p>那么这些循环的数字被裁剪了，就会出现精度丢失的问题，也就造成了 <code>0.1</code> 不再是 <code>0.1</code> 了，而是变成了 <code>0.100000000000000002</code></p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0.100000000000000002 &#x3D;&#x3D;&#x3D; 0.1 &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><blockquote><p>那么同样的，<code>0.2</code> 在二进制也是无限循环的，被裁剪后也失去了精度变成了 <code>0.200000000000000002</code></p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0.200000000000000002 &#x3D;&#x3D;&#x3D; 0.2 &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><blockquote><p>所以这两者相加不等于 <code>0.3</code> 而是 <code>0.300000000000000004</code></p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0.1 + 0.2 &#x3D;&#x3D;&#x3D; 0.30000000000000004 &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure><blockquote><p>那么可能你又会有一个疑问，既然 <code>0.1</code> 不是 <code>0.1</code>，那为什么 <code>console.log(0.1)</code> 却是正确的呢？</p></blockquote><blockquote><p>因为在输入内容的时候，二进制被转换为了十进制，十进制又被转换为了字符串，在这个转换的过程中发生了取近似值的过程，所以打印出来的其实是一个近似值，你也可以通过以下代码来验证</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(0.100000000000000002) &#x2F;&#x2F; 0.1</span><br></pre></td></tr></table></figure><p><strong>解决</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>((<span class="number">0.1</span> + <span class="number">0.2</span>).toFixed(<span class="number">10</span>)) === <span class="number">0.3</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="17-事件机制"><a href="#17-事件机制" class="headerlink" title="17 事件机制"></a>17 事件机制</h2><blockquote><p>涉及面试题：事件的触发过程是怎么样的？知道什么是事件代理嘛？</p></blockquote><h3 id="17-1-事件触发三阶段"><a href="#17-1-事件触发三阶段" class="headerlink" title="17.1 事件触发三阶段"></a>17.1 事件触发三阶段</h3><p><strong>事件触发有三个阶段</strong>：</p><ul><li><code>window</code>往事件触发处传播，遇到注册的捕获事件会触发</li><li>传播到事件触发处时触发注册的事件</li><li>从事件触发处往 <code>window</code> 传播，遇到注册的冒泡事件会触发</li></ul><blockquote><p>事件触发一般来说会按照上面的顺序进行，但是也有特例，如果给一个 <code>body</code> 中的子节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下会先打印冒泡然后是捕获</span></span><br><span class="line">node.addEventListener(</span><br><span class="line">  <span class="string">'click'</span>,</span><br><span class="line">  event =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'冒泡'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">)</span><br><span class="line">node.addEventListener(</span><br><span class="line">  <span class="string">'click'</span>,</span><br><span class="line">  event =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'捕获 '</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">true</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="17-2-注册事件"><a href="#17-2-注册事件" class="headerlink" title="17.2 注册事件"></a>17.2 注册事件</h3><blockquote><p>通常我们使用 <code>addEventListener</code> 注册事件，该函数的第三个参数可以是布尔值，也可以是对象。对于布尔值 <code>useCapture</code> 参数来说，该参数默认值为 <code>false</code> ，<code>useCapture</code> 决定了注册的事件是捕获事件还是冒泡事件。对于对象参数来说，可以使用以下几个属性</p></blockquote><ul><li><code>capture</code>：布尔值，和 <code>useCapture</code> 作用一样</li><li><code>once</code>：布尔值，值为 <code>true</code> 表示该回调只会调用一次，调用后会移除监听</li><li><code>passive</code>：布尔值，表示永远不会调用 <code>preventDefault</code></li></ul><blockquote><p>一般来说，如果我们只希望事件只触发在目标上，这时候可以使用 <code>stopPropagation</code>来阻止事件的进一步传播。通常我们认为 <code>stopPropagation</code> 是用来阻止事件冒泡的，其实该函数也可以阻止捕获事件<code>。stopImmediatePropagation</code>同样也能实现阻止事件，但是还能阻止该事件目标执行别的注册事件。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">node.addEventListener(</span><br><span class="line">  <span class="string">'click'</span>,</span><br><span class="line">  event =&gt; &#123;</span><br><span class="line">    event.stopImmediatePropagation()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'冒泡'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 点击 node 只会执行上面的函数，该函数不会执行</span></span><br><span class="line">node.addEventListener(</span><br><span class="line">  <span class="string">'click'</span>,</span><br><span class="line">  event =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'捕获 '</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">true</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="17-3-事件代理"><a href="#17-3-事件代理" class="headerlink" title="17.3 事件代理"></a>17.3 事件代理</h3><blockquote><p>如果一个节点中的子节点是动态生成的，那么子节点需要注册事件的话应该注册在父节点上</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"ul"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">'#ul'</span>)</span></span><br><span class="line"><span class="actionscript">ul.addEventListener(<span class="string">'click'</span>, (event) =&gt; &#123;</span></span><br><span class="line"><span class="javascript"><span class="built_in">console</span>.log(event.target);</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>事件代理的方式相较于直接给目标注册事件来说，有以下优点</strong>：</p><ul><li>节省内存</li><li>不需要给子节点注销事件</li></ul><h2 id="18-跨域"><a href="#18-跨域" class="headerlink" title="18 跨域"></a>18 跨域</h2><blockquote><p>涉及面试题：什么是跨域？为什么浏览器要使用同源策略？你有几种方式可以解决跨域问题？了解预检请求嘛？</p></blockquote><ul><li>因为浏览器出于安全考虑，有同源策略。也就是说，如果协议、域名或者端口有一个不同就是跨域，<code>Ajax</code> 请求会失败。</li><li>那么是出于什么安全考虑才会引入这种机制呢？ 其实主要是用来防止 <code>CSRF</code> 攻击的。简单点说，<code>CSRF</code> 攻击是利用用户的登录态发起恶意请求。</li><li>也就是说，没有同源策略的情况下，<code>A</code> 网站可以被任意其他来源的 <code>Ajax</code> 访问到内容。如果你当前 <code>A</code> 网站还存在登录态，那么对方就可以通过 <code>Ajax</code> 获得你的任何信息。当然跨域并不能完全阻止 <code>CSRF</code>。</li></ul><blockquote><p>然后我们来考虑一个问题，请求跨域了，那么请求到底发出去没有？ 请求必然是发出去了，但是浏览器拦截了响应。你可能会疑问明明通过表单的方式可以发起跨域请求，为什么 <code>Ajax</code>就不会。因为归根结底，跨域是为了阻止用户读取到另一个域名下的内容，<code>Ajax</code> 可以获取响应，浏览器认为这不安全，所以拦截了响应。但是表单并不会获取新的内容，所以可以发起跨域请求。同时也说明了跨域并不能完全阻止 <code>CSRF</code>，因为请求毕竟是发出去了。</p></blockquote><p>接下来我们将来学习几种常见的方式来解决跨域的问题</p><h3 id="18-1-JSONP"><a href="#18-1-JSONP" class="headerlink" title="18.1 JSONP"></a>18.1 JSONP</h3><blockquote><p><code>JSONP</code> 的原理很简单，就是利用 <code>&lt;script&gt;</code> 标签没有跨域限制的漏洞。通过 <code>&lt;script&gt;</code>标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://domain/api?param1=a&amp;param2=b&amp;callback=jsonp"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">jsonp</span><span class="params">(data)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(data)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p><code>JSONP</code> 使用简单且兼容性不错，但是只限于 <code>get</code> 请求。</p></blockquote><blockquote><p>在开发中可能会遇到多个 <code>JSONP</code> 请求的回调函数名是相同的，这时候就需要自己封装一个 <code>JSONP</code>，以下是简单实现</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonp</span>(<span class="params">url, jsonpCallback, success</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>)</span><br><span class="line">  script.src = url</span><br><span class="line">  script.async = <span class="literal">true</span></span><br><span class="line">  script.type = <span class="string">'text/javascript'</span></span><br><span class="line">  <span class="built_in">window</span>[jsonpCallback] = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    success &amp;&amp; success(data)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(script)</span><br><span class="line">&#125;</span><br><span class="line">jsonp(<span class="string">'http://xxx'</span>, <span class="string">'callback'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="18-2-CORS"><a href="#18-2-CORS" class="headerlink" title="18.2 CORS"></a>18.2 CORS</h3><ul><li><code>CORS</code> 需要浏览器和后端同时支持。<code>IE 8</code> 和 <code>9</code> 需要通过 <code>XDomainRequest</code> 来实现。</li><li>浏览器会自动进行 <code>CORS</code> 通信，实现 <code>CORS</code> 通信的关键是后端。只要后端实现了 <code>CORS</code>，就实现了跨域。</li><li>服务端设置 <code>Access-Control-Allow-Origin</code> 就可以开启 <code>CORS</code>。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。<br>虽然设置 <code>CORS</code>和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为简单请求和复杂请求。</li></ul><p><strong>简单请求</strong></p><blockquote><p>以 <code>Ajax</code> 为例，当满足以下条件时，会触发简单请求</p></blockquote><ol><li>使用下列方法之一：</li></ol><ul><li><code>GET</code></li><li><code>HEAD</code></li><li><code>POST</code></li></ul><ol start="2"><li><code>Content-Type</code> 的值仅限于下列三者之一：</li></ol><ul><li>text/plain</li><li><code>multipart/form-data</code></li><li><code>application/x-www-form-urlencoded</code></li></ul><blockquote><p>请求中的任意 <code>XMLHttpRequestUpload</code> 对象均没有注册任何事件监听器； <code>XMLHttpRequestUpload</code> 对象可以使用 <code>XMLHttpRequest.upload</code> 属性访问</p></blockquote><p><strong>复杂请求</strong></p><blockquote><p>对于复杂请求来说，首先会发起一个预检请求，该请求是 <code>option</code> 方法的，通过该请求来知道服务端是否允许跨域请求。</p></blockquote><p>对于预检请求来说，如果你使用过 <code>Node</code> 来设置 <code>CORS</code> 的话，可能会遇到过这么一个坑。</p><p>以下以 <code>express</code>框架举例</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.use(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  res.header(<span class="string">'Access-Control-Allow-Origin'</span>, <span class="string">'*'</span>)</span><br><span class="line">  res.header(<span class="string">'Access-Control-Allow-Methods'</span>, <span class="string">'PUT, GET, POST, DELETE, OPTIONS'</span>)</span><br><span class="line">  res.header(</span><br><span class="line">    <span class="string">'Access-Control-Allow-Headers'</span>,</span><br><span class="line">    <span class="string">'Origin, X-Requested-With, Content-Type, Accept, Authorization, Access-Control-Allow-Credentials'</span></span><br><span class="line">  )</span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>该请求会验证你的 <code>Authorization</code> 字段，没有的话就会报错。</li><li>当前端发起了复杂请求后，你会发现就算你代码是正确的，返回结果也永远是报错的。因为预检请求也会进入回调中，也会触发 <code>next</code> 方法，因为预检请求并不包含 <code>Authorization</code> 字段，所以服务端会报错。</li></ul><blockquote><p>想解决这个问题很简单，只需要在回调中过滤 <code>option</code> 方法即可</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.statusCode = <span class="number">204</span></span><br><span class="line">res.setHeader(<span class="string">'Content-Length'</span>, <span class="string">'0'</span>)</span><br><span class="line">res.end()</span><br></pre></td></tr></table></figure><h3 id="18-3-document-domain"><a href="#18-3-document-domain" class="headerlink" title="18.3 document.domain"></a>18.3 document.domain</h3><ul><li>该方式只能用于主域名相同的情况下，比如 <code>a.test.com</code> 和 <code>b.test.com</code> 适用于该方式。</li><li>只需要给页面添加 <code>document.domain = &#39;test.com&#39;</code> 表示主域名都相同就可以实现跨域</li></ul><h3 id="18-4-postMessage"><a href="#18-4-postMessage" class="headerlink" title="18.4 postMessage"></a>18.4 postMessage</h3><blockquote><p>这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 发送消息端</span></span><br><span class="line"><span class="built_in">window</span>.parent.postMessage(<span class="string">'message'</span>, <span class="string">'http://test.com'</span>)</span><br><span class="line"><span class="comment">// 接收消息端</span></span><br><span class="line"><span class="keyword">var</span> mc = <span class="keyword">new</span> MessageChannel()</span><br><span class="line">mc.addEventListener(<span class="string">'message'</span>, event =&gt; &#123;</span><br><span class="line">  <span class="keyword">var</span> origin = event.origin || event.originalEvent.origin</span><br><span class="line">  <span class="keyword">if</span> (origin === <span class="string">'http://test.com'</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'验证通过'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="19-存储"><a href="#19-存储" class="headerlink" title="19 存储"></a>19 存储</h2><blockquote><p>涉及面试题：有几种方式可以实现存储功能，分别有什么优缺点？什么是 <code>Service Worker</code>？</p></blockquote><p><strong>cookie，localStorage，sessionStorage，indexDB</strong></p><table><thead><tr><th>特性</th><th>cookie</th><th>localStorage</th><th>sessionStorage</th><th>indexDB</th></tr></thead><tbody><tr><td>数据生命周期</td><td>一般由服务器生成，可以设置过期时间</td><td>除非被清理，否则一直存在</td><td>页面关闭就清理</td><td>除非被清理，否则一直存在</td></tr><tr><td>数据存储大小</td><td><code>4K</code></td><td><code>5M</code></td><td><code>5M</code></td><td>无限</td></tr><tr><td>与服务端通信</td><td>每次都会携带在 <code>header</code> 中，对于请求性能影响</td><td>不参与</td><td>不参与</td><td>不参与</td></tr></tbody></table><blockquote><p>从上表可以看到，<code>cookie</code> 已经不建议用于存储。如果没有大量数据存储需求的话，可以使用 <code>localStorage</code> 和 <code>sessionStorage</code> 。对于不怎么改变的数据尽量使用 <code>localStorage</code> 存储，否则可以用 <code>sessionStorage</code>存储</p></blockquote><p><strong>对于 cookie 来说，我们还需要注意安全性。</strong></p><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td><code>value</code></td><td>如果用于保存用户登录态，应该将该值加密，不能使用明文的用户标识</td></tr><tr><td><code>http-only</code></td><td>不能通过 <code>JS</code> 访问 <code>Cookie</code>，减少 <code>XSS</code> 攻击</td></tr><tr><td><code>secure</code></td><td>只能在协议为 <code>HTTPS</code> 的请求中携带</td></tr><tr><td><code>same-site</code></td><td>规定浏览器不能在跨域请求中携带 <code>Cookie</code>，减少 <code>CSRF</code> 攻击</td></tr></tbody></table><p><strong>Service Worker</strong></p><ul><li><code>Service Worker</code> 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 <code>Service Worker</code>的话，传输协议必须为 <code>HTTPS</code>。因为 <code>Service Worker</code> 中涉及到请求拦截，所以必须使用 <code>HTTPS</code> 协议来保障安全</li><li><code>Service Worker</code> 实现缓存功能一般分为三个步骤：首先需要先注册 <code>Service Worker</code>，然后监听到 <code>install</code> 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。以下是这个步骤的实现：</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">if</span> (navigator.serviceWorker) &#123;</span><br><span class="line">  navigator.serviceWorker</span><br><span class="line">    .register(<span class="string">'sw.js'</span>)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">registration</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'service worker 注册成功'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'servcie worker 注册失败'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// sw.js</span></span><br><span class="line"><span class="comment">// 监听 `install` 事件，回调中缓存所需文件</span></span><br><span class="line">self.addEventListener(<span class="string">'install'</span>, e =&gt; &#123;</span><br><span class="line">  e.waitUntil(</span><br><span class="line">    caches.open(<span class="string">'my-cache'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> cache.addAll([<span class="string">'./index.html'</span>, <span class="string">'./index.js'</span>])</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拦截所有请求事件</span></span><br><span class="line"><span class="comment">// 如果缓存中已经有请求的数据就直接用缓存，否则去请求数据</span></span><br><span class="line">self.addEventListener(<span class="string">'fetch'</span>, e =&gt; &#123;</span><br><span class="line">  e.respondWith(</span><br><span class="line">    caches.match(e.request).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (response) &#123;</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'fetch source'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>打开页面，可以在开发者工具中的 <code>Application</code> 看到 <code>Service Worker</code> 已经启动了</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/3/28/1626b1e8eba68e1c" alt=""></p><blockquote><p>在 <code>Cache</code> 中也可以发现我们所需的文件已被缓存</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/3/28/1626b20dfc4fcd26" alt=""></p><blockquote><p>当我们重新刷新页面可以发现我们缓存的数据是从 <code>Service Worker</code> 中读取的</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/3/28/1626b20e4f8f3257" alt=""></p><h2 id="20-浏览器缓存机制"><a href="#20-浏览器缓存机制" class="headerlink" title="20 浏览器缓存机制"></a>20 浏览器缓存机制</h2><blockquote><p>注意：该知识点属于性能优化领域，并且整一章节都是一个面试题</p></blockquote><ul><li>缓存可以说是性能优化中简单高效的一种优化方式了，它可以显著减少网络传输所带来的损耗。</li><li>对于一个数据请求来说，可以分为发起网络请求、后端处理、浏览器响应三个步骤。浏览器缓存可以帮助我们在第一和第三步骤中优化性能。比如说直接使用缓存而不发起请求，或者发起了请求但后端存储的数据和前端一致，那么就没有必要再将数据回传回来，这样就减少了响应数据。</li></ul><blockquote><p>接下来的内容中我们将通过以下几个部分来探讨浏览器缓存机制：</p></blockquote><ul><li>缓存位置</li><li>缓存策略</li><li>实际场景应用缓存策略</li></ul><h3 id="20-1-缓存位置"><a href="#20-1-缓存位置" class="headerlink" title="20.1 缓存位置"></a>20.1 缓存位置</h3><blockquote><p>从缓存位置上来说分为四种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络</p></blockquote><ol><li><code>Service Worker</code></li><li><code>Memory Cache</code></li><li><code>Disk Cache</code></li><li><code>Push Cache</code></li><li>网络请求</li></ol><p><strong>1. Service Worker</strong></p><ul><li><code>service Worker</code> 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。</li><li>当 <code>Service Worker</code> 没有命中缓存的时候，我们需要去调用 <code>fetch</code> 函数获取数据。也就是说，如果我们没有在 <code>Service Worker</code> 命中缓存的话，会根据缓存查找优先级去查找数据。但是不管我们是从 <code>Memory Cache</code> 中还是从网络请求中获取的数据，浏览器都会显示我们是从 <code>Service Worker</code> 中获取的内容。</li></ul><p><strong>2. Memory Cache</strong></p><ul><li><code>Memory Cache</code> 也就是内存中的缓存，读取内存中的数据肯定比磁盘快。但是内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。 一旦我们关闭 <code>Tab</code> 页面，内存中的缓存也就被释放了。</li><li>当我们访问过页面以后，再次刷新页面，可以发现很多数据都来自于内存缓存</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/12/5/1677db8003dc8311" alt=""></p><blockquote><p>那么既然内存缓存这么高效，我们是不是能让数据都存放在内存中呢？</p></blockquote><ul><li>先说结论，这是不可能的。首先计算机中的内存一定比硬盘容量小得多，操作系统需要精打细算内存的使用，所以能让我们使用的内存必然不多。内存中其实可以存储大部分的文件，比如说 <code>JS</code>、<code>HTML</code>、<code>CSS</code>、图片等等</li><li>当然，我通过一些实践和猜测也得出了一些结论：</li><li>对于大文件来说，大概率是不存储在内存中的，反之优先当前系统内存使用率高的话，文件优先存储进硬盘</li></ul><p><strong>3. Disk Cache</strong></p><ul><li><code>Disk Cache</code> 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 <code>Memory Cache</code> 胜在容量和存储时效性上。</li><li>在所有浏览器缓存中，<code>Disk Cache</code> 覆盖面基本是最大的。它会根据 ·HTTP Herder· 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据</li></ul><p><strong>4. Push Cache</strong></p><ul><li><code>Push Cache</code> 是 <code>HTTP/2</code> 中的内容，当以上三种缓存都没有命中时，它才会被使用。并且缓存时间也很短暂，只在会话（<code>Session</code>）中存在，一旦会话结束就被释放。</li><li><code>Push Cache</code> 在国内能够查到的资料很少，也是因为 <code>HTTP/2</code> 在国内不够普及，但是 <code>HTTP/2</code> 将会是日后的一个趋势</li></ul><blockquote><p>结论</p></blockquote><ul><li>所有的资源都能被推送，但是 <code>Edge</code> 和 <code>Safari</code> 浏览器兼容性不怎么好</li><li>可以推送 <code>no-cache</code> 和 <code>no-store</code> 的资源</li><li>一旦连接被关闭，<code>Push Cache</code> 就被释放</li><li>多个页面可以使用相同的 <code>HTTP/2</code> 连接，也就是说能使用同样的缓存</li><li><code>Push Cache</code> 中的缓存只能被使用一次</li><li>浏览器可以拒绝接受已经存在的资源推送</li><li>你可以给其他域名推送资源</li></ul><p><strong>5. 网络请求</strong></p><ul><li>如果所有缓存都没有命中的话，那么只能发起请求来获取资源了。</li><li>那么为了性能上的考虑，大部分的接口都应该选择好缓存策略，接下来我们就来学习缓存策略这部分的内容</li></ul><h3 id="20-2-缓存策略"><a href="#20-2-缓存策略" class="headerlink" title="20.2 缓存策略"></a>20.2 缓存策略</h3><blockquote><p>通常浏览器缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置 <code>HTTP Header</code> 来实现的</p></blockquote><h4 id="20-2-1-强缓存"><a href="#20-2-1-强缓存" class="headerlink" title="20.2.1 强缓存"></a>20.2.1 强缓存</h4><blockquote><p>强缓存可以通过设置两种 <code>HTTP Header</code> 实现：<code>Expires</code> 和 <code>Cache-Control</code> 。强缓存表示在缓存期间不需要请求，<code>state code</code>为 <code>200</code></p></blockquote><p><strong>Expires</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Expires: Wed, 22 Oct 2018 08:41:00 GMT</span><br></pre></td></tr></table></figure><blockquote><p><code>Expires</code> 是 <code>HTTP/1</code> 的产物，表示资源会在 <code>Wed, 22 Oct 2018 08:41:00 GMT</code> 后过期，需要再次请求。并且 <code>Expires</code> 受限于本地时间，如果修改了本地时间，可能会造成缓存失效。</p></blockquote><p><strong>Cache-control</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cache-control: max-age&#x3D;30</span><br></pre></td></tr></table></figure><ul><li><code>Cache-Control</code> 出现于 <code>HTTP/1.1</code>，优先级高于 <code>Expires</code> 。该属性值表示资源会在 <code>30</code> 秒后过期，需要再次请求。</li><li><code>Cache-Control</code> 可以在请求头或者响应头中设置，并且可以组合使用多种指令</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/12/6/1678234a1ed20487" alt=""></p><blockquote><p>从图中我们可以看到，我们可以将多个指令配合起来一起使用，达到多个目的。比如说我们希望资源能被缓存下来，并且是客户端和代理服务器都能缓存，还能设置缓存失效时间等</p></blockquote><p><strong>一些常见指令的作用</strong></p><p><img src="https://user-gold-cdn.xitu.io/2018/12/5/1677ef2cd7bf1bba" alt=""></p><h4 id="20-2-2-协商缓存"><a href="#20-2-2-协商缓存" class="headerlink" title="20.2.2 协商缓存"></a>20.2.2 协商缓存</h4><ul><li>如果缓存过期了，就需要发起请求验证资源是否有更新。协商缓存可以通过设置两种 <code>HTTP Header</code> 实现：<code>Last-Modified</code> 和 <code>ETag</code></li><li>当浏览器发起请求验证资源时，如果资源没有做改变，那么服务端就会返回 <code>304</code> 状态码，并且更新浏览器缓存有效期。</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/12/6/16782357baddf1c6" alt=""></p><p><strong>Last-Modified 和 If-Modified-Since</strong></p><blockquote><p><code>Last-Modified</code> 表示本地文件最后修改日期，<code>If-Modified-Since</code> 会将 <code>Last-Modified</code> 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来，否则返回 <code>304</code> 状态码。</p></blockquote><p>但是 <code>Last-Modified</code>存在一些弊端：</p><ul><li>如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 <code>Last-Modified</code> 被修改，服务端不能命中缓存导致发送相同的资源</li><li>因为 <code>Last-Modified</code> 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源<br>因为以上这些弊端，所以在 <code>HTTP / 1.1</code> 出现了 <code>ETag</code></li></ul><p><strong>ETag 和 If-None-Match</strong></p><ul><li><code>ETag</code> 类似于文件指纹，<code>If-None-Match</code> 会将当前 <code>ETag</code> 发送给服务器，询问该资源 <code>ETag</code> 是否变动，有变动的话就将新的资源发送回来。并且 <code>ETag</code>优先级比 <code>Last-Modified</code> 高。</li></ul><blockquote><p>以上就是缓存策略的所有内容了，看到这里，不知道你是否存在这样一个疑问。如果什么缓存策略都没设置，那么浏览器会怎么处理？</p></blockquote><p>对于这种情况，浏览器会采用一个启发式的算法，通常会取响应头中的 <code>Date</code> 减去 <code>Last-Modified</code> 值的 <code>10%</code> 作为缓存时间。</p><h3 id="20-3-实际场景应用缓存策略"><a href="#20-3-实际场景应用缓存策略" class="headerlink" title="20.3 实际场景应用缓存策略"></a>20.3 实际场景应用缓存策略</h3><p><strong>频繁变动的资源</strong></p><blockquote><p>对于频繁变动的资源，首先需要使用 <code>Cache-Control: no-cache</code> 使浏览器每次都请求服务器，然后配合 <code>ETag</code> 或者 <code>Last-Modified</code> 来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小。</p></blockquote><p><strong>代码文件</strong></p><blockquote><p>这里特指除了 <code>HTML</code> 外的代码文件，因为 <code>HTML</code> 文件一般不缓存或者缓存时间很短。</p></blockquote><p>一般来说，现在都会使用工具来打包代码，那么我们就可以对文件名进行哈希处理，只有当代码修改后才会生成新的文件名。基于此，我们就可以给代码文件设置缓存有效期一年 <code>Cache-Control: max-age=31536000</code>，这样只有当 <code>HTML</code> 文件中引入的文件名发生了改变才会去下载最新的代码文件，否则就一直使用缓存</p><blockquote><p>更多缓存知识详解 <a href="http://blog.poetries.top/2019/01/02/browser-cache" target="_blank" rel="noopener">http://blog.poetries.top/2019/01/02/browser-cache</a></p></blockquote><h2 id="21-浏览器渲染原理"><a href="#21-浏览器渲染原理" class="headerlink" title="21 浏览器渲染原理"></a>21 浏览器渲染原理</h2><blockquote><p>注意：该章节都是一个面试题。</p></blockquote><h3 id="21-1-渲染过程"><a href="#21-1-渲染过程" class="headerlink" title="21.1 渲染过程"></a>21.1 渲染过程</h3><p><strong>1. 浏览器接收到 HTML 文件并转换为 DOM 树</strong></p><blockquote><p>当我们打开一个网页时，浏览器都会去请求对应的 <code>HTML</code> 文件。虽然平时我们写代码时都会分为 <code>JS</code>、<code>CSS</code>、<code>HTML</code> 文件，也就是字符串，但是计算机硬件是不理解这些字符串的，所以在网络中传输的内容其实都是 <code>0</code> 和 <code>1</code> 这些字节数据。当浏览器接收到这些字节数据以后，它会将这些字节数据转换为字符串，也就是我们写的代码。</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/11/27/16754281e59587f3" alt=""></p><blockquote><p>当数据转换为字符串以后，浏览器会先将这些字符串通过词法分析转换为标记（<code>token</code>），这一过程在词法分析中叫做标记化（<code>tokenization</code>）</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/11/27/16754288f37a5347" alt=""></p><blockquote><p>那么什么是标记呢？这其实属于编译原理这一块的内容了。简单来说，标记还是字符串，是构成代码的最小单位。这一过程会将代码分拆成一块块，并给这些内容打上标记，便于理解这些最小单位的代码是什么意思</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/11/27/167540a7b5cef612" alt=""></p><blockquote><p>当结束标记化后，这些标记会紧接着转换为 <code>Node</code>，最后这些 <code>Node</code> 会根据不同 <code>Node</code> 之前的联系构建为一颗 <code>DOM</code> 树</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/11/27/1675416cbea98c3c" alt=""></p><blockquote><p>以上就是浏览器从网络中接收到 <code>HTML</code> 文件然后一系列的转换过程</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/11/27/167542b09875a74a" alt=""></p><blockquote><p>当然，在解析 <code>HTML</code> 文件的时候，浏览器还会遇到 <code>CSS</code> 和 <code>JS</code> 文件，这时候浏览器也会去下载并解析这些文件，接下来就让我们先来学习浏览器如何解析 <code>CSS</code> 文件</p></blockquote><p><strong>2. 将 CSS 文件转换为 CSSOM 树</strong></p><blockquote><p>其实转换 <code>CSS</code> 到 <code>CSSOM</code> 树的过程和上一小节的过程是极其类似的</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/11/27/167542a9af5f193f" alt=""></p><ul><li>在这一过程中，浏览器会确定下每一个节点的样式到底是什么，并且这一过程其实是很消耗资源的。因为样式你可以自行设置给某个节点，也可以通过继承获得。在这一过程中，浏览器得递归 <code>CSSOM</code> 树，然后确定具体的元素到底是什么样式。</li></ul><p>如果你有点不理解为什么会消耗资源的话，我这里举个例子</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span>&gt;</span> <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span> <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  span &#123;</span><br><span class="line">    color: red;</span><br><span class="line">  &#125;</span><br><span class="line">  div &gt; a &gt; span &#123;</span><br><span class="line">    color: red;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>对于第一种设置样式的方式来说，浏览器只需要找到页面中所有的 <code>span</code> 标签然后设置颜色，但是对于第二种设置样式的方式来说，浏览器首先需要找到所有的 <code>span</code> 标签，然后找到 <code>span</code> 标签上的 <code>a</code> 标签，最后再去找到 <code>div</code> 标签，然后给符合这种条件的 <code>span</code> 标签设置颜色，这样的递归过程就很复杂。所以我们应该尽可能的避免写过于具体的 <code>CSS</code> 选择器，然后对于 <code>HTML</code> 来说也尽量少的添加无意义标签，保证层级扁平</p></blockquote><p><strong>3. 生成渲染树</strong></p><blockquote><p>当我们生成 <code>DOM</code> 树和 <code>CSSOM</code> 树以后，就需要将这两棵树组合为渲染树</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/11/27/16754488529c48bd" alt=""></p><ul><li>在这一过程中，不是简单的将两者合并就行了。渲染树只会包括需要显示的节点和这些节点的样式信息，如果某个节点是 <code>display: none</code> 的，那么就不会在渲染树中显示。</li><li>当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流），然后调用 <code>GPU</code>绘制，合成图层，显示在屏幕上。对于这一部分的内容因为过于底层，还涉及到了硬件相关的知识，这里就不再继续展开内容了。</li></ul><h3 id="21-2-为什么操作-DOM-慢"><a href="#21-2-为什么操作-DOM-慢" class="headerlink" title="21.2 为什么操作 DOM 慢"></a>21.2 为什么操作 DOM 慢</h3><blockquote><p>想必大家都听过操作 DOM 性能很差，但是这其中的原因是什么呢？</p></blockquote><ul><li>因为 <code>DOM</code>是属于渲染引擎中的东西，而 <code>JS</code> 又是 <code>JS</code> 引擎中的东西。当我们通过 <code>JS</code> 操作 <code>DOM</code> 的时候，其实这个操作涉及到了两个线程之间的通信，那么势必会带来一些性能上的损耗。操作 <code>DOM</code> 次数一多，也就等同于一直在进行线程之间的通信，并且操作 <code>DOM</code> 可能还会带来重绘回流的情况，所以也就导致了性能上的问题。</li></ul><blockquote><p>经典面试题：插入几万个 DOM，如何实现页面不卡顿？</p></blockquote><ul><li>对于这道题目来说，首先我们肯定不能一次性把几万个 <code>DOM</code> 全部插入，这样肯定会造成卡顿，所以解决问题的重点应该是如何分批次部分渲染 <code>DOM</code>。大部分人应该可以想到通过 <code>requestAnimationFrame</code> 的方式去循环的插入 <code>DOM</code>，其实还有种方式去解决这个问题：虚拟滚动（<code>virtualized scroller</code>）。</li><li>这种技术的原理就是只渲染可视区域内的内容，非可见区域的那就完全不渲染了，当用户在滚动的时候就实时去替换渲染的内容</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/12/15/167b1c6887ecbba7" alt=""></p><blockquote><p>从上图中我们可以发现，即使列表很长，但是渲染的 <code>DOM</code> 元素永远只有那么几个，当我们滚动页面的时候就会实时去更新 <code>DOM</code>，这个技术就能顺利解决这道经典面试题</p></blockquote><h3 id="21-3-什么情况阻塞渲染"><a href="#21-3-什么情况阻塞渲染" class="headerlink" title="21.3 什么情况阻塞渲染"></a>21.3 什么情况阻塞渲染</h3><ul><li>首先渲染的前提是生成渲染树，所以 <code>HTML</code> 和 <code>CSS</code> 肯定会阻塞渲染。如果你想渲染的越快，你越应该降低一开始需要渲染的文件大小，并且扁平层级，优化选择器。</li><li>然后当浏览器在解析到 <code>script</code> 标签时，会暂停构建 <code>DOM</code>，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 <code>JS</code>文件，这也是都建议将 <code>script</code> 标签放在 <code>body</code> 标签底部的原因。</li><li>当然在当下，并不是说 <code>script</code> 标签必须放在底部，因为你可以给 <code>script</code> 标签添加 <code>defer</code> 或者 <code>async</code> 属性。</li><li>当 <code>script</code> 标签加上 <code>defer</code> 属性以后，表示该 <code>JS</code> 文件会并行下载，但是会放到 <code>HTML</code> 解析完成后顺序执行，所以对于这种情况你可以把 <code>script</code>标签放在任意位置。</li><li>对于没有任何依赖的 <code>JS</code> 文件可以加上 <code>async</code> 属性，表示 <code>JS</code> 文件下载和解析不会阻塞渲染。</li></ul><h3 id="21-4-重绘（Repaint）和回流（Reflow）"><a href="#21-4-重绘（Repaint）和回流（Reflow）" class="headerlink" title="21.4 重绘（Repaint）和回流（Reflow）"></a>21.4 重绘（Repaint）和回流（Reflow）</h3><blockquote><p>重绘和回流会在我们设置节点样式时频繁出现，同时也会很大程度上影响性能。</p></blockquote><ul><li>重绘是当节点需要更改外观而不会影响布局的，比如改变 <code>color</code> 就叫称为重绘</li><li>回流是布局或者几何属性需要改变就称为回流。</li><li>回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流。</li></ul><p><strong>以下几个动作可能会导致性能问题</strong>：</p><ul><li>改变 <code>window</code> 大小</li><li>改变字体</li><li>添加或删除样式</li><li>文字改变</li><li>定位或者浮动</li><li>盒模型</li></ul><blockquote><p>并且很多人不知道的是，重绘和回流其实也和 <code>Eventloop</code> 有关。</p></blockquote><ul><li>当 <code>Eventloop</code> 执行完 <code>Microtasks</code> 后，会判断 <code>document</code> 是否需要更新，因为浏览器是 <code>60Hz</code> 的刷新率，每 <code>16.6ms</code> 才会更新一次。</li><li>然后判断是否有 <code>resize</code> 或者 <code>scroll</code> 事件，有的话会去触发事件，所以 <code>resize</code> 和 <code>scroll</code> 事件也是至少 <code>16ms</code> 才会触发一次，并且自带节流功能。</li><li>判断是否触发了 <code>media query</code></li><li>更新动画并且发送事件</li><li>判断是否有全屏操作事件</li><li>执行 <code>requestAnimationFrame</code>回调</li><li>执行 <code>IntersectionObserver</code> 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好<br>更新界面</li><li>以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 <code>requestIdleCallback</code>回调</li></ul><h3 id="21-5-减少重绘和回流"><a href="#21-5-减少重绘和回流" class="headerlink" title="21.5 减少重绘和回流"></a>21.5 减少重绘和回流</h3><ol><li>使用 <code>transform</code> 替代 <code>top</code></li></ol><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.test</span> &#123;</span></span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 10px;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    background: red;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 引起回流</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.querySelector(<span class="string">'.test'</span>).style.top = <span class="string">'100px'</span></span></span><br><span class="line">  &#125;, 1000)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>使用 <code>visibility</code> 替换<code>display: none</code> ，因为前者只会引起重绘，后者会引发回流（改变了布局）</li><li>不要把节点的属性值放在一个循环里当成循环里的变量</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 获取 offsetTop 会导致回流，因为需要去获取正确的值</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">document</span>.querySelector(<span class="string">'.test'</span>).style.offsetTop)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>不要使用 <code>table</code> 布局，可能很小的一个小改动会造成整个 <code>table</code> 的重新布局</li><li>动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 <code>requestAnimationFrame</code></li><li><code>CSS</code> 选择符从右往左匹配查找，避免节点层级过多</li><li>将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点。比如对于 <code>video</code> 标签来说，浏览器会自动将该节点变为图层。</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/3/29/1626fb6f33a6f9d7" alt=""></p><blockquote><p>设置节点为图层的方式有很多，我们可以通过以下几个常用属性可以生成新图层</p></blockquote><ul><li><code>will-change</code></li><li><code>video</code>、<code>iframe</code> 标签</li></ul><h2 id="22-安全防范"><a href="#22-安全防范" class="headerlink" title="22 安全防范"></a>22 安全防范</h2><h3 id="22-1-XSS"><a href="#22-1-XSS" class="headerlink" title="22.1 XSS"></a>22.1 XSS</h3><blockquote><p>涉及面试题：什么是 <code>XSS</code> 攻击？如何防范 <code>XSS</code> 攻击？什么是 <code>CSP</code>？</p></blockquote><ul><li><code>XSS</code> 简单点来说，就是攻击者想尽一切办法将可以执行的代码注入到网页中。</li><li><code>XSS</code> 可以分为多种类型，但是总体上我认为分为两类：持久型和非持久型。</li><li>持久型也就是攻击的代码被服务端写入进数据库中，这种攻击危害性很大，因为如果网站访问量很大的话，就会导致大量正常访问页面的用户都受到攻击。</li></ul><blockquote><p>举个例子，对于评论功能来说，就得防范持久型 <code>XSS</code> 攻击，因为我可以在评论中输入以下内容</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/1480597-4d0534470dcfe615.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li>这种情况如果前后端没有做好防御的话，这段评论就会被存储到数据库中，这样每个打开该页面的用户都会被攻击到。</li><li>非持久型相比于前者危害就小的多了，一般通过修改 <code>URL</code> 参数的方式加入攻击代码，诱导用户访问链接从而进行攻击。</li></ul><blockquote><p>举个例子，如果页面需要从 <code>URL</code> 中获取某些参数作为内容的话，不经过过滤就会导致攻击代码被执行</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- http://www.domain.com?name=&lt;script&gt;alert(1)&lt;/script&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>但是对于这种攻击方式来说，如果用户使用 <code>Chrome</code> 这类浏览器的话，浏览器就能自动帮助用户防御攻击。但是我们不能因此就不防御此类攻击了，因为我不能确保用户都使用了该类浏览器。</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/12/2/1676d5e1a09c8367" alt=""></p><blockquote><p>对于 <code>XSS</code> 攻击来说，通常有两种方式可以用来防御。</p></blockquote><ol><li><strong>转义字符</strong></li></ol><blockquote><p>首先，对于用户的输入应该是永远不信任的。最普遍的做法就是转义输入输出的内容，对于引号、尖括号、斜杠进行转义</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">escape</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  str = str.replace(<span class="regexp">/&amp;/g</span>, <span class="string">'&amp;amp;'</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/&lt;/g</span>, <span class="string">'&amp;lt;'</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/&gt;/g</span>, <span class="string">'&amp;gt;'</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/"/g</span>, <span class="string">'&amp;quto;'</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/'/g</span>, <span class="string">'&amp;#39;'</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/`/g</span>, <span class="string">'&amp;#96;'</span>)</span><br><span class="line">  str = str.replace(<span class="regexp">/\//g</span>, <span class="string">'&amp;#x2F;'</span>)</span><br><span class="line">  <span class="keyword">return</span> str</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>通过转义可以将攻击代码 <code>&lt;script&gt;alert(1)&lt;/script&gt;</code> 变成</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// -&gt; &amp;lt;script&amp;gt;alert(1)&amp;lt;&amp;#x2F;script&amp;gt;</span></span><br><span class="line"><span class="built_in">escape</span>(<span class="string">'&lt;script&gt;alert(1)&lt;/script&gt;'</span>)</span><br></pre></td></tr></table></figure><blockquote><p>但是对于显示富文本来说，显然不能通过上面的办法来转义所有字符，因为这样会把需要的格式也过滤掉。对于这种情况，通常采用白名单过滤的办法，当然也可以通过黑名单过滤，但是考虑到需要过滤的标签和标签属性实在太多，更加推荐使用白名单的方式</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> xss = <span class="built_in">require</span>(<span class="string">'xss'</span>)</span><br><span class="line"><span class="keyword">let</span> html = xss(<span class="string">'&lt;h1 id="title"&gt;XSS Demo&lt;/h1&gt;&lt;script&gt;alert("xss");&lt;/script&gt;'</span>)</span><br><span class="line"><span class="comment">// -&gt; &lt;h1&gt;XSS Demo&lt;/h1&gt;&amp;lt;script&amp;gt;alert("xss");&amp;lt;/script&amp;gt;</span></span><br><span class="line"><span class="built_in">console</span>.log(html)</span><br></pre></td></tr></table></figure><blockquote><p>以上示例使用了 <code>js-xss</code> 来实现，可以看到在输出中保留了 <code>h1</code> 标签且过滤了 <code>script</code>标签</p></blockquote><ol start="2"><li><strong>CSP</strong></li></ol><blockquote><p><code>CSP</code> 本质上就是建立白名单，开发者明确告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截是由浏览器自己实现的。我们可以通过这种方式来尽量减少 <code>XSS</code> 攻击。</p></blockquote><p><strong>通常可以通过两种方式来开启 CSP</strong>：</p><ul><li>设置 <code>HTTP Header</code> 中的 <code>Content-Security-Policy</code></li><li>设置 <code>meta</code> 标签的方式 <code>&lt;meta http-equiv=&quot;Content-Security-Policy&quot;&gt;</code></li></ul><p>这里以设置 <code>HTTP Header</code> 来举例</p><p><strong>只允许加载本站资源</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Content-Security-Policy: default-src ‘self’</span><br></pre></td></tr></table></figure><p><strong>只允许加载 HTTPS 协议图片</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Content-Security-Policy: img-src https:&#x2F;&#x2F;*</span><br></pre></td></tr></table></figure><p><strong>允许加载任何来源框架</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Content-Security-Policy: child-src &#39;none&#39;</span><br></pre></td></tr></table></figure><blockquote><p>当然可以设置的属性远不止这些，你可以通过查阅 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy" target="_blank" rel="noopener">文档</a> 的方式来学习，这里就不过多赘述其他的属性了。</p></blockquote><blockquote><p>对于这种方式来说，只要开发者配置了正确的规则，那么即使网站存在漏洞，攻击者也不能执行它的攻击代码，并且 <code>CSP</code> 的兼容性也不错。</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/12/2/1676d8215a3d1f5b" alt=""></p><h3 id="22-2-CSRF"><a href="#22-2-CSRF" class="headerlink" title="22.2 CSRF"></a>22.2 CSRF</h3><blockquote><p>涉及面试题：什么是 <code>CSRF</code> 攻击？如何防范 <code>CSRF</code> 攻击？</p></blockquote><blockquote><p><code>CSRF</code> 中文名为跨站请求伪造。原理就是攻击者构造出一个后端请求地址，诱导用户点击或者通过某些途径自动发起请求。如果用户是在登录状态下的话，后端就以为是用户在操作，从而进行相应的逻辑。</p></blockquote><p>举个例子，假设网站中有一个通过 <code>GET</code> 请求提交用户评论的接口，那么攻击者就可以在钓鱼网站中加入一个图片，图片的地址就是评论接口</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://www.domain.com/xxx?comment='attack'"</span>/&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>那么你是否会想到使用 <code>POST</code> 方式提交请求是不是就没有这个问题了呢？其实并不是，使用这种方式也不是百分百安全的，攻击者同样可以诱导用户进入某个页面，在页面中通过表单提交 <code>POST</code> 请求。</p></blockquote><p><strong>如何防御</strong></p><ul><li><code>Get</code> 请求不对数据进行修改</li><li>不让第三方网站访问到用户 <code>Cookie</code></li><li>阻止第三方网站请求接口</li><li>请求时附带验证信息，比如验证码或者 <code>Token</code></li></ul><p><strong>SameSite</strong></p><blockquote><p>可以对 <code>Cookie</code> 设置 <code>SameSite</code> 属性。该属性表示 <code>Cookie</code> 不随着跨域请求发送，可以很大程度减少 <code>CSRF</code> 的攻击，但是该属性目前并不是所有浏览器都兼容。</p></blockquote><p><strong>验证 Referer</strong></p><blockquote><p>对于需要防范 <code>CSRF</code> 的请求，我们可以通过验证 <code>Referer</code> 来判断该请求是否为第三方网站发起的。</p></blockquote><p><strong>Token</strong></p><blockquote><p>服务器下发一个随机 <code>Token</code>，每次发起请求时将 <code>Token</code> 携带上，服务器验证 <code>Token</code> 是否有效</p></blockquote><h3 id="22-3-点击劫持"><a href="#22-3-点击劫持" class="headerlink" title="22.3 点击劫持"></a>22.3 点击劫持</h3><blockquote><p>涉及面试题：什么是点击劫持？如何防范点击劫持？</p></blockquote><blockquote><p>点击劫持是一种视觉欺骗的攻击手段。攻击者将需要攻击的网站通过 <code>iframe</code> 嵌套的方式嵌入自己的网页中，并将 <code>iframe</code> 设置为透明，在页面中透出一个按钮诱导用户点击</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/1480597-e2fd2624a105fce7.png" alt="image.png"></p><blockquote><p>对于这种攻击方式，推荐防御的方法有两种</p></blockquote><p><strong>1. X-FRAME-OPTIONS</strong></p><blockquote><p><code>X-FRAME-OPTIONS</code> 是一个 <code>HTTP</code> 响应头，在现代浏览器有一个很好的支持。这个 HTTP 响应头 就是为了防御用<code>iframe</code> 嵌套的点击劫持攻击。</p></blockquote><blockquote><p>该响应头有三个值可选，分别是</p></blockquote><ul><li><code>DENY</code>，表示页面不允许通过 <code>iframe</code> 的方式展示</li><li><code>SAMEORIGIN</code>，表示页面可以在相同域名下通过 <code>iframe</code> 的方式展示</li><li><code>ALLOW-FROM</code>，表示页面可以在指定来源的 <code>iframe</code> 中展示</li></ul><p><strong>2. JS 防御</strong></p><blockquote><p>对于某些远古浏览器来说，并不能支持上面的这种方式，那我们只有通过 JS 的方式来防御点击劫持了。</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span> <span class="attr">id</span>=<span class="string">"click-jack"</span>&gt;</span></span><br><span class="line">    html &#123;</span><br><span class="line">      display: none !important;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">    if (self == top) &#123;</span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> style = <span class="built_in">document</span>.getElementById(<span class="string">'click-jack'</span>)</span></span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.body.removeChild(style)</span></span><br><span class="line"><span class="actionscript">    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line">      top.location = self.location</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>以上代码的作用就是当通过 <code>iframe</code> 的方式加载页面时，攻击者的网页直接不显示所有内容了</p></blockquote><h2 id="23-从-V8-中看-JS-性能优化"><a href="#23-从-V8-中看-JS-性能优化" class="headerlink" title="23 从 V8 中看 JS 性能优化"></a>23 从 V8 中看 JS 性能优化</h2><blockquote><p>注意：该知识点属于性能优化领域。</p></blockquote><h3 id="23-1-测试性能工具"><a href="#23-1-测试性能工具" class="headerlink" title="23.1 测试性能工具"></a>23.1 测试性能工具</h3><blockquote><p><code>Chrome</code> 已经提供了一个大而全的性能测试工具 <code>Audits</code></p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/12/3/16772c479b194d48" alt=""></p><blockquote><p>点我们点击 <code>Audits</code> 后，可以看到如下的界面</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/12/3/16772c52e83d97c7" alt=""></p><blockquote><p>在这个界面中，我们可以选择想测试的功能然后点击 <code>Run audits</code> ，工具就会自动运行帮助我们测试问题并且给出一个完整的报告</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/12/3/16772ca3d13a68ab" alt=""></p><blockquote><p>上图是给掘金首页测试性能后给出的一个报告，可以看到报告中分别为性能、体验、SEO 都给出了打分，并且每一个指标都有详细的评估</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/12/3/16772cae50f7eb81" alt=""></p><p>评估结束后，工具还提供了一些建议便于我们提高这个指标的分数</p><p><img src="https://user-gold-cdn.xitu.io/2018/12/3/16772cbdcdaccf15" alt=""></p><p>我们只需要一条条根据建议去优化性能即可。</p><blockquote><p>除了 <code>Audits</code> 工具之外，还有一个 <code>Performance</code>工具也可以供我们使用。</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/12/3/16772cf78a4fa18f" alt=""></p><blockquote><p>在这张图中，我们可以详细的看到每个时间段中浏览器在处理什么事情，哪个过程最消耗时间，便于我们更加详细的了解性能瓶颈</p></blockquote><h3 id="23-2-JS-性能优化"><a href="#23-2-JS-性能优化" class="headerlink" title="23.2 JS 性能优化"></a>23.2 JS 性能优化</h3><blockquote><p><code>JS</code> 是编译型还是解释型语言其实并不固定。首先 <code>JS</code> 需要有引擎才能运行起来，无论是浏览器还是在 <code>Node</code> 中，这是解释型语言的特性。但是在 V8 引擎下，又引入了 <code>TurboFan</code> 编译器，他会在特定的情况下进行优化，将代码编译成执行效率更高的 <code>Machine Code</code>，当然这个编译器并不是 <code>JS</code> 必须需要的，只是为了提高代码执行性能，所以总的来说 <code>JS</code> 更偏向于解释型语言。</p></blockquote><p>那么这一小节的内容主要会针对于 <code>Chrome</code> 的 <code>V8</code> 引擎来讲解。</p><blockquote><p>在这一过程中，<code>JS</code> 代码首先会解析为抽象语法树（<code>AST</code>），然后会通过解释器或者编译器转化为 <code>Bytecode</code> 或者<code>Machine Code</code></p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/12/3/167736409eebe688" alt=""></p><blockquote><p>从上图中我们可以发现，<code>JS</code> 会首先被解析为 <code>AST</code>，解析的过程其实是略慢的。代码越多，解析的过程也就耗费越长，这也是我们需要压缩代码的原因之一。另外一种减少解析时间的方式是预解析，会作用于未执行的函数，这个我们下面再谈</p></blockquote><p>这里需要注意一点，对于函数来说，应该尽可能避免声明嵌套函数（类也是函数），因为这样会造成函数的重复解析</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 会被重复解析</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>然后 <code>Ignition</code> 负责将 <code>AST</code> 转化为 <code>Bytecode</code>，<code>TurboFan</code> 负责编译出优化后的 <code>Machine Code</code>，并且 <code>Machine Code</code> 在执行效率上优于 <code>Bytecode</code></p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/12/3/16773b904cfb732f" alt=""></p><blockquote><p>那么我们就产生了一个疑问，什么情况下代码会编译为 <code>Machine Code</code>？</p></blockquote><blockquote><p><code>JS</code> 是一门动态类型的语言，并且还有一大堆的规则。简单的加法运算代码，内部就需要考虑好几种规则，比如数字相加、字符串相加、对象和字符串相加等等。这样的情况也就势必导致了内部要增加很多判断逻辑，降低运行效率。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="number">1</span>)</span><br><span class="line">test(<span class="number">2</span>)</span><br><span class="line">test(<span class="number">3</span>)</span><br><span class="line">test(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><ul><li>对于以上代码来说，如果一个函数被多次调用并且参数一直传入 <code>number</code> 类型，那么 <code>V8</code> 就会认为该段代码可以编译为 <code>Machine Code</code>，因为你固定了类型，不需要再执行很多判断逻辑了。</li><li>但是如果一旦我们传入的参数类型改变，那么 <code>Machine Code</code> 就会被 <code>DeOptimized</code>为 <code>Bytecode</code>，这样就有性能上的一个损耗了。所以如果我们希望代码能多的编译为 <code>Machine Code</code> 并且 <code>DeOptimized</code>的次数减少，就应该尽可能保证传入的类型一致。</li><li>那么你可能会有一个疑问，到底优化前后有多少的提升呢，接下来我们就来实践测试一下到底有多少的提升</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; performance, PerformanceObserver &#125; = <span class="built_in">require</span>(<span class="string">'perf_hooks'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + x</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// node 10 中才有 PerformanceObserver</span></span><br><span class="line"><span class="comment">// 在这之前的 node 版本可以直接使用 performance 中的 API</span></span><br><span class="line"><span class="keyword">const</span> obs = <span class="keyword">new</span> PerformanceObserver(<span class="function">(<span class="params">list, observer</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(list.getEntries())</span><br><span class="line">  observer.disconnect()</span><br><span class="line">&#125;)</span><br><span class="line">obs.observe(&#123; <span class="attr">entryTypes</span>: [<span class="string">'measure'</span>], <span class="attr">buffered</span>: <span class="literal">true</span> &#125;)</span><br><span class="line"></span><br><span class="line">performance.mark(<span class="string">'start'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> number = <span class="number">10000000</span></span><br><span class="line"><span class="comment">// 不优化代码</span></span><br><span class="line">%NeverOptimizeFunction(test)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (number--) &#123;</span><br><span class="line">  test(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">performance.mark(<span class="string">'end'</span>)</span><br><span class="line">performance.measure(<span class="string">'test'</span>, <span class="string">'start'</span>, <span class="string">'end'</span>)</span><br></pre></td></tr></table></figure><blockquote><p>以上代码中我们使用了 <code>performance API</code>，这个 <code>API</code> 在性能测试上十分好用。不仅可以用来测量代码的执行时间，还能用来测量各种网络连接中的时间消耗等等，并且这个 API 也可以在浏览器中使</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/12/4/16778338eb8b7130" alt=""></p><blockquote><p>从上图中我们可以发现，优化过的代码执行时间只需要 <code>9ms</code>，但是不优化过的代码执行时间却是前者的二十倍，已经接近 <code>200ms</code> 了。在这个案例中，我相信大家已经看到了 <code>V8</code> 的性能优化到底有多强，只需要我们符合一定的规则书写代码，引擎底层就能帮助我们自动优化代码。</p></blockquote><blockquote><p>另外，编译器还有个骚操作 <code>Lazy-Compile</code>，当函数没有被执行的时候，会对函数进行一次预解析，直到代码被执行以后才会被解析编译。对于上述代码来说，<code>test</code> 函数需要被预解析一次，然后在调用的时候再被解析编译。但是对于这种函数马上就被调用的情况来说，预解析这个过程其实是多余的，那么有什么办法能够让代码不被预解析呢？</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + x</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>但是不可能我们为了性能优化，给所有的函数都去套上括号，并且也不是所有函数都需要这样做。我们可以通过 <code>optimize-js</code> 实现这个功能，这个库会分析一些函数的使用情况，然后给需要的函数添加括号，当然这个库很久没人维护了，如果需要使用的话，还是需要测试过相关内容的。</p></blockquote><p>其实很简单，我们只需要给函数套上括号就可以了</p><h2 id="24-性能优化"><a href="#24-性能优化" class="headerlink" title="24 性能优化"></a>24 性能优化</h2><blockquote><p>总的来说性能优化这个领域的很多内容都很碎片化，这一章节我们将来学习这些碎片化的内容。</p></blockquote><h3 id="24-1-图片优化"><a href="#24-1-图片优化" class="headerlink" title="24.1 图片优化"></a>24.1 图片优化</h3><p><strong>计算图片大小</strong></p><blockquote><p>对于一张 <code>100 * 100</code> 像素的图片来说，图像上有 <code>10000</code> 个像素点，如果每个像素的值是 <code>RGBA</code> 存储的话，那么也就是说每个像素有 <code>4</code> 个通道，每个通道 <code>1</code> 个字节（<code>8</code> 位 = <code>1</code>个字节），所以该图片大小大概为 <code>39KB</code>（<code>10000 * 1 * 4 / 1024</code>）。</p></blockquote><ul><li>但是在实际项目中，一张图片可能并不需要使用那么多颜色去显示，我们可以通过减少每个像素的调色板来相应缩小图片的大小。</li><li>了解了如何计算图片大小的知识，那么对于如何优化图片，想必大家已经有 2 个思路了：</li></ul><ol><li>减少像素点</li><li>减少每个像素点能够显示的颜色</li></ol><h3 id="24-2-图片加载优化"><a href="#24-2-图片加载优化" class="headerlink" title="24.2 图片加载优化"></a>24.2 图片加载优化</h3><ul><li>不用图片。很多时候会使用到很多修饰类图片，其实这类修饰图片完全可以用 <code>CSS</code> 去代替。</li><li>对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。一般图片都用 <code>CDN</code> 加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片。</li><li>小图使用 <code>base64</code> 格式</li><li>将多个图标文件整合到一张图片中（雪碧图）</li><li>选择正确的图片格式：<ul><li>对于能够显示 <code>WebP</code>格式的浏览器尽量使用 <code>WebP</code> 格式。因为 <code>WebP</code> 格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，缺点就是兼容性并不好</li><li>小图使用 <code>PNG</code>，其实对于大部分图标这类图片，完全可以使用 <code>SVG</code>代替</li><li>照片使用 <code>JPEG</code></li></ul></li></ul><h3 id="24-3-DNS-预解析"><a href="#24-3-DNS-预解析" class="headerlink" title="24.3 DNS 预解析"></a>24.3 DNS 预解析</h3><blockquote><p><code>DNS</code> 解析也是需要时间的，可以通过预解析的方式来预先获得域名所对应的 <code>IP</code>。</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"dns-prefetch"</span> <span class="attr">href</span>=<span class="string">"//blog.poetries.top"</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="24-4-节流"><a href="#24-4-节流" class="headerlink" title="24.4 节流"></a>24.4 节流</h3><blockquote><p>考虑一个场景，滚动事件中会发起网络请求，但是我们并不希望用户在滚动过程中一直发起请求，而是隔一段时间发起一次，对于这种情况我们就可以使用节流。</p></blockquote><p>理解了节流的用途，我们就来实现下这个函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// func是用户传入需要防抖的函数</span></span><br><span class="line"><span class="comment">// wait是等待时间</span></span><br><span class="line"><span class="keyword">const</span> throttle = <span class="function">(<span class="params">func, wait = <span class="number">50</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 上一次执行该函数的时间</span></span><br><span class="line">  <span class="keyword">let</span> lastTime = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 当前时间</span></span><br><span class="line">    <span class="keyword">let</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    <span class="comment">// 将当前时间和上一次执行函数时间对比</span></span><br><span class="line">    <span class="comment">// 如果差值大于设置的等待时间就执行函数</span></span><br><span class="line">    <span class="keyword">if</span> (now - lastTime &gt; wait) &#123;</span><br><span class="line">      lastTime = now</span><br><span class="line">      func.apply(<span class="keyword">this</span>, args)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setInterval(</span><br><span class="line">  throttle(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  &#125;, <span class="number">500</span>),</span><br><span class="line">  <span class="number">1</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="24-5-防抖"><a href="#24-5-防抖" class="headerlink" title="24.5 防抖"></a>24.5 防抖</h3><blockquote><p>考虑一个场景，有一个按钮点击会触发网络请求，但是我们并不希望每次点击都发起网络请求，而是当用户点击按钮一段时间后没有再次点击的情况才去发起网络请求，对于这种情况我们就可以使用防抖。</p></blockquote><p>理解了防抖的用途，我们就来实现下这个函数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// func是用户传入需要防抖的函数</span></span><br><span class="line"><span class="comment">// wait是等待时间</span></span><br><span class="line"><span class="keyword">const</span> debounce = <span class="function">(<span class="params">func, wait = <span class="number">50</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 缓存一个定时器id</span></span><br><span class="line">  <span class="keyword">let</span> timer = <span class="number">0</span></span><br><span class="line">  <span class="comment">// 这里返回的函数是每次用户实际调用的防抖函数</span></span><br><span class="line">  <span class="comment">// 如果已经设定过定时器了就清空上一次的定时器</span></span><br><span class="line">  <span class="comment">// 开始一个新的定时器，延迟执行用户传入的方法</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timer) clearTimeout(timer)</span><br><span class="line">    timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      func.apply(<span class="keyword">this</span>, args)</span><br><span class="line">    &#125;, wait)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="24-6-预加载"><a href="#24-6-预加载" class="headerlink" title="24.6 预加载"></a>24.6 预加载</h3><ul><li>在开发中，可能会遇到这样的情况。有些资源不需要马上用到，但是希望尽早获取，这时候就可以使用预加载。</li><li>预加载其实是声明式的 <code>fetch</code> ，强制浏览器请求资源，并且不会阻塞 <code>onload</code> 事件，可以使用以下代码开启预加载</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preload"</span> <span class="attr">href</span>=<span class="string">"http://blog.poetries.top"</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>预加载可以一定程度上降低首屏的加载时间，因为可以将一些不影响首屏但重要的文件延后加载，唯一缺点就是兼容性不好。</p></blockquote><h3 id="24-7-预渲染"><a href="#24-7-预渲染" class="headerlink" title="24.7 预渲染"></a>24.7 预渲染</h3><blockquote><p>可以通过预渲染将下载的文件预先在后台渲染，可以使用以下代码开启预渲染</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"prerender"</span> <span class="attr">href</span>=<span class="string">"http://blog.poetries.top"</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>预渲染虽然可以提高页面的加载速度，但是要确保该页面大概率会被用户在之后打开，否则就是白白浪费资源去渲染。</p></blockquote><h3 id="24-8-懒执行"><a href="#24-8-懒执行" class="headerlink" title="24.8 懒执行"></a>24.8 懒执行</h3><blockquote><p>懒执行就是将某些逻辑延迟到使用时再计算。该技术可以用于首屏优化，对于某些耗时逻辑并不需要在首屏就使用的，就可以使用懒执行。懒执行需要唤醒，一般可以通过定时器或者事件的调用来唤醒。</p></blockquote><h3 id="24-9-懒加载"><a href="#24-9-懒加载" class="headerlink" title="24.9 懒加载"></a>24.9 懒加载</h3><ul><li>懒加载就是将不关键的资源延后加载。</li><li>懒加载的原理就是只加载自定义区域（通常是可视区域，但也可以是即将进入可视区域）内需要加载的东西。对于图片来说，先设置图片标签的 <code>src</code> 属性为一张占位图，将真实的图片资源放入一个自定义属性中，当进入自定义区域时，就将自定义属性替换为 <code>src</code> 属性，这样图片就会去下载资源，实现了图片懒加载。</li><li>懒加载不仅可以用于图片，也可以使用在别的资源上。比如进入可视区域才开始播放视频等等。</li></ul><h3 id="24-10-CDN"><a href="#24-10-CDN" class="headerlink" title="24.10 CDN"></a>24.10 CDN</h3><blockquote><p><code>CDN</code>的原理是尽可能的在各个地方分布机房缓存数据，这样即使我们的根服务器远在国外，在国内的用户也可以通过国内的机房迅速加载资源。</p></blockquote><blockquote><p>因此，我们可以将静态资源尽量使用 <code>CDN</code> 加载，由于浏览器对于单个域名有并发请求上限，可以考虑使用多个 <code>CDN</code> 域名。并且对于 <code>CDN</code> 加载静态资源需要注意 <code>CDN</code>  域名要与主站不同，否则每次请求都会带上主站的 <code>Cookie</code>，平白消耗流量</p></blockquote><h2 id="25-Webpack-性能优化"><a href="#25-Webpack-性能优化" class="headerlink" title="25 Webpack 性能优化"></a>25 Webpack 性能优化</h2><blockquote><p>在这部分的内容中，我们会聚焦于以下两个知识点，并且每一个知识点都属于高频考点：</p></blockquote><ul><li>有哪些方式可以减少 <code>Webpack</code> 的打包时间</li><li>有哪些方式可以让 <code>Webpack</code> 打出来的包更小</li></ul><h3 id="25-1-减少-Webpack-打包时间"><a href="#25-1-减少-Webpack-打包时间" class="headerlink" title="25.1 减少 Webpack 打包时间"></a>25.1 减少 Webpack 打包时间</h3><p><strong>1. 优化 Loader</strong></p><blockquote><p>对于 <code>Loader</code> 来说，影响打包效率首当其冲必属 <code>Babel</code> 了。因为 <code>Babel</code> 会将代码转为字符串生成 <code>AST</code>，然后对 <code>AST</code> 继续进行转变最后再生成新的代码，项目越大，转换代码越多，效率就越低。当然了，我们是有办法优化的</p></blockquote><blockquote><p>首先我们可以优化 <code>Loader</code> 的文件搜索范围</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// js 文件才使用 babel</span></span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">        <span class="comment">// 只在 src 文件夹下查找</span></span><br><span class="line">        include: [resolve(<span class="string">'src'</span>)],</span><br><span class="line">        <span class="comment">// 不会去查找的路径</span></span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对于 <code>Babel</code> 来说，我们肯定是希望只作用在 <code>JS</code>代码上的，然后 <code>node_modules</code> 中使用的代码都是编译过的，所以我们也完全没有必要再去处理一遍</p></blockquote><ul><li>当然这样做还不够，我们还可以将 <code>Babel</code> 编译过的文件缓存起来，下次只需要编译更改过的代码文件即可，这样可以大幅度加快打包时间</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">loader: <span class="string">'babel-loader?cacheDirectory=true'</span></span><br></pre></td></tr></table></figure><p><strong>2. HappyPack</strong></p><blockquote><p>受限于 <code>Node</code> 是单线程运行的，所以 <code>Webpack</code> 在打包的过程中也是单线程的，特别是在执行<code>Loader</code> 的时候，长时间编译的任务很多，这样就会导致等待的情况。</p></blockquote><blockquote><p><code>HappyPack</code> 可以将 <code>Loader</code> 的同步执行转换为并行的，这样就能充分利用系统资源来加快打包效率了</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  loaders: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      include: [resolve(<span class="string">'src'</span>)],</span><br><span class="line">      exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">      <span class="comment">// id 后面的内容对应下面</span></span><br><span class="line">      loader: <span class="string">'happypack/loader?id=happybabel'</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line">    id: <span class="string">'happybabel'</span>,</span><br><span class="line">    loaders: [<span class="string">'babel-loader?cacheDirectory'</span>],</span><br><span class="line">    <span class="comment">// 开启 4 个线程</span></span><br><span class="line">    threads: <span class="number">4</span></span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>3. DllPlugin</strong></p><blockquote><p><code>DllPlugin</code> 可以将特定的类库提前打包然后引入。这种方式可以极大的减少打包类库的次数，只有当类库更新版本才有需要重新打包，并且也实现了将公共代码抽离成单独文件的优化方案。</p></blockquote><p>接下来我们就来学习如何使用 <code>DllPlugin</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单独配置在一个文件中</span></span><br><span class="line"><span class="comment">// webpack.dll.conf.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    <span class="comment">// 想统一打包的类库</span></span><br><span class="line">    vendor: [<span class="string">'react'</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.join(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'[name].dll.js'</span>,</span><br><span class="line">    library: <span class="string">'[name]-[hash]'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.DllPlugin(&#123;</span><br><span class="line">      <span class="comment">// name 必须和 output.library 一致</span></span><br><span class="line">      name: <span class="string">'[name]-[hash]'</span>,</span><br><span class="line">      <span class="comment">// 该属性需要与 DllReferencePlugin 中一致</span></span><br><span class="line">      context: __dirname,</span><br><span class="line">      path: path.join(__dirname, <span class="string">'dist'</span>, <span class="string">'[name]-manifest.json'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>然后我们需要执行这个配置文件生成依赖文件，接下来我们需要使用 <code>DllReferencePlugin</code> 将依赖文件引入项目中</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.conf.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...省略其他配置</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.DllReferencePlugin(&#123;</span><br><span class="line">      context: __dirname,</span><br><span class="line">      <span class="comment">// manifest 就是之前打包出来的 json 文件</span></span><br><span class="line">      manifest: <span class="built_in">require</span>(<span class="string">'./dist/vendor-manifest.json'</span>),</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4. 代码压缩</strong></p><blockquote><p>在 <code>Webpack3</code> 中，我们一般使用 <code>UglifyJS</code> 来压缩代码，但是这个是单线程运行的，为了加快效率，我们可以使用 <code>webpack-parallel-uglify-plugin</code> 来并行运行 <code>UglifyJS</code>，从而提高效率。</p></blockquote><blockquote><p>在 <code>Webpack4</code> 中，我们就不需要以上这些操作了，只需要将 <code>mode</code> 设置为 <code>production</code> 就可以默认开启以上功能。代码压缩也是我们必做的性能优化方案，当然我们不止可以压缩 <code>JS</code> 代码，还可以压缩 <code>HTML</code>、<code>CSS</code> 代码，并且在压缩 <code>JS</code> 代码的过程中，我们还可以通过配置实现比如删除 <code>console.log</code> 这类代码的功能。</p></blockquote><p><strong>5. 一些小的优化点</strong></p><blockquote><p>我们还可以通过一些小的优化点来加快打包速度</p></blockquote><ul><li><code>resolve.extensions</code>：用来表明文件后缀列表，默认查找顺序是 <code>[&#39;.js&#39;, &#39;.json&#39;]</code>，如果你的导入文件没有添加后缀就会按照这个顺序查找文件。我们应该尽可能减少后缀列表长度，然后将出现频率高的后缀排在前面</li><li><code>resolve.alias</code>：可以通过别名的方式来映射一个路径，能让 <code>Webpack</code> 更快找到路径</li><li><code>module.noParse</code>：如果你确定一个文件下没有其他依赖，就可以使用该属性让 Webpack 不扫描该文件，这种方式对于大型的类库很有帮助</li></ul><h3 id="25-2-减少-Webpack-打包后的文件体积"><a href="#25-2-减少-Webpack-打包后的文件体积" class="headerlink" title="25.2 减少 Webpack 打包后的文件体积"></a>25.2 减少 Webpack 打包后的文件体积</h3><p><strong>1. 按需加载</strong></p><blockquote><p>想必大家在开发 <code>SPA</code> 项目的时候，项目中都会存在十几甚至更多的路由页面。如果我们将这些页面全部打包进一个 <code>JS</code>文件的话，虽然将多个请求合并了，但是同样也加载了很多并不需要的代码，耗费了更长的时间。那么为了首页能更快地呈现给用户，我们肯定是希望首页能加载的文件体积越小越好，这时候我们就可以使用按需加载，将每个路由页面单独打包为一个文件。当然不仅仅路由可以按需加载，对于 <code>loadash</code> 这种大型类库同样可以使用这个功能。</p></blockquote><blockquote><p>按需加载的代码实现这里就不详细展开了，因为鉴于用的框架不同，实现起来都是不一样的。当然了，虽然他们的用法可能不同，但是底层的机制都是一样的。都是当使用的时候再去下载对应文件，返回一个 <code>Promise</code>，当 <code>Promise</code>成功以后去执行回调。</p></blockquote><p><strong>2. Scope Hoisting</strong></p><blockquote><p><code>Scope Hoisting</code> 会分析出模块之间的依赖关系，尽可能的把打包出来的模块合并到一个函数中去。</p></blockquote><p>比如我们希望打包两个文件</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; a &#125; <span class="keyword">from</span> <span class="string">'./test.js'</span></span><br></pre></td></tr></table></figure><blockquote><p>对于这种情况，我们打包出来的代码会类似这样</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  <span class="comment">/* 0 */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">module, exports, require</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">/* 1 */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">module, exports, require</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><blockquote><p>但是如果我们使用 <code>Scope Hoisting</code> 的话，代码就会尽可能的合并到一个函数中去，也就变成了这样的类似代码</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  <span class="comment">/* 0 */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">module, exports, require</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><blockquote><p>这样的打包方式生成的代码明显比之前的少多了。如果在 <code>Webpack4</code> 中你希望开启这个功能，只需要启用 <code>optimization.concatenateModules</code>就可以了。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    concatenateModules: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3. Tree Shaking</strong></p><blockquote><p><code>Tree Shaking</code> 可以实现删除项目中未被引用的代码，比如</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> b = <span class="number">2</span></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; a &#125; <span class="keyword">from</span> <span class="string">'./test.js'</span></span><br></pre></td></tr></table></figure><ul><li>对于以上情况，<code>test</code> 文件中的变量 <code>b</code> 如果没有在项目中使用到的话，就不会被打包到文件中。</li><li>如果你使用 <code>Webpack 4</code> 的话，开启生产环境就会自动启动这个优化功能。</li></ul><h2 id="26-实现小型打包工具"><a href="#26-实现小型打包工具" class="headerlink" title="26 实现小型打包工具"></a>26 实现小型打包工具</h2><blockquote><p>该工具可以实现以下两个功能</p></blockquote><ul><li>将 <code>ES6</code> 转换为 <code>ES5</code></li><li>支持在 <code>JS</code> 文件中 <code>import CSS</code> 文件</li></ul><blockquote><p>通过这个工具的实现，大家可以理解到打包工具的原理到底是什么</p></blockquote><p><strong>实现</strong></p><blockquote><p>因为涉及到 <code>ES6</code> 转 <code>ES5</code>，所以我们首先需要安装一些 <code>Babel</code> 相关的工具</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add babylon babel-traverse babel-core babel-preset-env</span><br></pre></td></tr></table></figure><p>接下来我们将这些工具引入文件中</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> babylon = <span class="built_in">require</span>(<span class="string">'babylon'</span>)</span><br><span class="line"><span class="keyword">const</span> traverse = <span class="built_in">require</span>(<span class="string">'babel-traverse'</span>).default</span><br><span class="line"><span class="keyword">const</span> &#123; transformFromAst &#125; = <span class="built_in">require</span>(<span class="string">'babel-core'</span>)</span><br></pre></td></tr></table></figure><p>首先，我们先来实现如何使用 <code>Babel</code> 转换代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readCode</span>(<span class="params">filePath</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 读取文件内容</span></span><br><span class="line">  <span class="keyword">const</span> content = fs.readFileSync(filePath, <span class="string">'utf-8'</span>)</span><br><span class="line">  <span class="comment">// 生成 AST</span></span><br><span class="line">  <span class="keyword">const</span> ast = babylon.parse(content, &#123;</span><br><span class="line">    sourceType: <span class="string">'module'</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 寻找当前文件的依赖关系</span></span><br><span class="line">  <span class="keyword">const</span> dependencies = []</span><br><span class="line">  traverse(ast, &#123;</span><br><span class="line">    ImportDeclaration: <span class="function">(<span class="params">&#123; node &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      dependencies.push(node.source.value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 通过 AST 将代码转为 ES5</span></span><br><span class="line">  <span class="keyword">const</span> &#123; code &#125; = transformFromAst(ast, <span class="literal">null</span>, &#123;</span><br><span class="line">    presets: [<span class="string">'env'</span>]</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    filePath,</span><br><span class="line">    dependencies,</span><br><span class="line">    code</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先我们传入一个文件路径参数，然后通过 <code>fs</code> 将文件中的内容读取出来</li><li>接下来我们通过 <code>babylon</code> 解析代码获取 <code>AST</code>，目的是为了分析代码中是否还引入了别的文件</li><li>通过 <code>dependencies</code> 来存储文件中的依赖，然后再将 <code>AST</code> 转换为 <code>ES5</code> 代码</li><li>最后函数返回了一个对象，对象中包含了当前文件路径、当前文件依赖和当前文件转换后的代码</li></ul><blockquote><p>接下来我们需要实现一个函数，这个函数的功能有以下几点</p></blockquote><ul><li>调用 <code>readCode</code> 函数，传入入口文件</li><li>分析入口文件的依赖</li><li>识别 <code>JS</code> 和 <code>CSS</code> 文件</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDependencies</span>(<span class="params">entry</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 读取入口文件</span></span><br><span class="line">  <span class="keyword">const</span> entryObject = readCode(entry)</span><br><span class="line">  <span class="keyword">const</span> dependencies = [entryObject]</span><br><span class="line">  <span class="comment">// 遍历所有文件依赖关系</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> asset <span class="keyword">of</span> dependencies) &#123;</span><br><span class="line">    <span class="comment">// 获得文件目录</span></span><br><span class="line">    <span class="keyword">const</span> dirname = path.dirname(asset.filePath)</span><br><span class="line">    <span class="comment">// 遍历当前文件依赖关系</span></span><br><span class="line">    asset.dependencies.forEach(<span class="function"><span class="params">relativePath</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 获得绝对路径</span></span><br><span class="line">      <span class="keyword">const</span> absolutePath = path.join(dirname, relativePath)</span><br><span class="line">      <span class="comment">// CSS 文件逻辑就是将代码插入到 `style` 标签中</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="regexp">/\.css$/</span>.test(absolutePath)) &#123;</span><br><span class="line">        <span class="keyword">const</span> content = fs.readFileSync(absolutePath, <span class="string">'utf-8'</span>)</span><br><span class="line">        <span class="keyword">const</span> code = <span class="string">`</span></span><br><span class="line"><span class="string">          const style = document.createElement('style')</span></span><br><span class="line"><span class="string">          style.innerText = <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(content).replace(<span class="regexp">/\\r\\n/g</span>, <span class="string">''</span>)&#125;</span></span></span><br><span class="line"><span class="string">          document.head.appendChild(style)</span></span><br><span class="line"><span class="string">        `</span></span><br><span class="line">        dependencies.push(&#123;</span><br><span class="line">          filePath: absolutePath,</span><br><span class="line">          relativePath,</span><br><span class="line">          dependencies: [],</span><br><span class="line">          code</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// JS 代码需要继续查找是否有依赖关系</span></span><br><span class="line">        <span class="keyword">const</span> child = readCode(absolutePath)</span><br><span class="line">        child.relativePath = relativePath</span><br><span class="line">        dependencies.push(child)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dependencies</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先我们读取入口文件，然后创建一个数组，该数组的目的是存储代码中涉及到的所有文件</li><li>接下来我们遍历这个数组，一开始这个数组中只有入口文件，在遍历的过程中，如果入口文件有依赖其他的文件，那么就会被 <code>push</code> 到这个数组中</li><li>在遍历的过程中，我们先获得该文件对应的目录，然后遍历当前文件的依赖关系</li><li>在遍历当前文件依赖关系的过程中，首先生成依赖文件的绝对路径，然后判断当前文件是 <code>CSS</code> 文件还是 <code>JS</code> 文件</li><li>如果是 <code>CSS</code> 文件的话，我们就不能用 <code>Babel</code> 去编译了，只需要读取 <code>CSS</code> 文件中的代码，然后创建一个 <code>style</code> 标签，将代码插入进标签并且放入 <code>head</code> 中即可</li><li>如果是 <code>JS</code> 文件的话，我们还需要分析 <code>JS</code> 文件是否还有别的依赖关系</li><li>最后将读取文件后的对象 <code>push</code> 进数组中</li><li>现在我们已经获取到了所有的依赖文件，接下来就是实现打包的功能了</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bundle</span>(<span class="params">dependencies, entry</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> modules = <span class="string">''</span></span><br><span class="line">  <span class="comment">// 构建函数参数，生成的结构为</span></span><br><span class="line">  <span class="comment">// &#123; './entry.js': function(module, exports, require) &#123; 代码 &#125; &#125;</span></span><br><span class="line">  dependencies.forEach(<span class="function"><span class="params">dep</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> filePath = dep.relativePath || entry</span><br><span class="line">    modules += <span class="string">`'<span class="subst">$&#123;filePath&#125;</span>': (</span></span><br><span class="line"><span class="string">      function (module, exports, require) &#123; <span class="subst">$&#123;dep.code&#125;</span> &#125;</span></span><br><span class="line"><span class="string">    ),`</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 构建 require 函数，目的是为了获取模块暴露出来的内容</span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="string">`</span></span><br><span class="line"><span class="string">    (function(modules) &#123;</span></span><br><span class="line"><span class="string">      function require(id) &#123;</span></span><br><span class="line"><span class="string">        const module = &#123; exports : &#123;&#125; &#125;</span></span><br><span class="line"><span class="string">        modules[id](module, module.exports, require)</span></span><br><span class="line"><span class="string">        return module.exports</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">      require('<span class="subst">$&#123;entry&#125;</span>')</span></span><br><span class="line"><span class="string">    &#125;)(&#123;<span class="subst">$&#123;modules&#125;</span>&#125;)</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">  <span class="comment">// 当生成的内容写入到文件中</span></span><br><span class="line">  fs.writeFileSync(<span class="string">'./bundle.js'</span>, result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这段代码需要结合着 <code>Babel</code> 转换后的代码来看，这样大家就能理解为什么需要这样写了</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// entry.js</span></span><br><span class="line"><span class="keyword">var</span> _a = <span class="built_in">require</span>(<span class="string">'./a.js'</span>)</span><br><span class="line"><span class="keyword">var</span> _a2 = _interopRequireDefault(_a)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_interopRequireDefault</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj &amp;&amp; obj.__esModule ? obj : &#123; <span class="attr">default</span>: obj &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(_a2.default)</span><br><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(exports, <span class="string">'__esModule'</span>, &#123;</span><br><span class="line">    value: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">exports.default = a</span><br></pre></td></tr></table></figure><blockquote><p><code>Babel</code> 将我们 <code>ES6</code>的模块化代码转换为了 <code>CommonJS</code>的代码，但是浏览器是不支持 <code>CommonJS</code> 的，所以如果这段代码需要在浏览器环境下运行的话，我们需要自己实现 <code>CommonJS</code> 相关的代码，这就是 <code>bundle</code> 函数做的大部分事情。</p></blockquote><p><strong>接下来我们再来逐行解析 bundle 函数</strong></p><ul><li>首先遍历所有依赖文件，构建出一个函数参数对象</li><li>对象的属性就是当前文件的相对路径，属性值是一个函数，函数体是当前文件下的代码，函数接受三个参数 <code>module</code>、<code>exports</code>、 <code>require</code><ul><li><code>module</code> 参数对应 <code>CommonJS</code> 中的 <code>module</code></li><li><code>exports</code> 参数对应 <code>CommonJS</code> 中的 <code>module.export</code></li><li><code>require</code> 参数对应我们自己创建的 <code>require</code> 函数</li></ul></li><li>接下来就是构造一个使用参数的函数了，函数做的事情很简单，就是内部创建一个 <code>require</code>函数，然后调用 <code>require(entry)</code>，也就是 <code>require(&#39;./entry.js&#39;)</code>，这样就会从函数参数中找到 <code>./entry.js</code> 对应的函数并执行，最后将导出的内容通过 <code>module.export</code> 的方式让外部获取到</li><li>最后再将打包出来的内容写入到单独的文件中</li></ul><blockquote><p>如果你对于上面的实现还有疑惑的话，可以阅读下打包后的部分简化代码</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params">modules</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">require</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 构造一个 CommonJS 导出代码</span></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">module</span> = &#123; <span class="attr">exports</span>: &#123;&#125; &#125;</span><br><span class="line">    <span class="comment">// 去参数中获取文件对应的函数并执行</span></span><br><span class="line">    modules[id](<span class="built_in">module</span>, <span class="built_in">module</span>.exports, <span class="built_in">require</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">module</span>.exports</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">require</span>(<span class="string">'./entry.js'</span>)</span><br><span class="line">&#125;)(&#123;</span><br><span class="line">  <span class="string">'./entry.js'</span>: <span class="function"><span class="keyword">function</span>(<span class="params">module, exports, require</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这里继续通过构造的 require 去找到 a.js 文件对应的函数</span></span><br><span class="line">    <span class="keyword">var</span> _a = <span class="built_in">require</span>(<span class="string">'./a.js'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(_a2.default)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">'./a.js'</span>: <span class="function"><span class="keyword">function</span>(<span class="params">module, exports, require</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">    <span class="comment">// 将 require 函数中的变量 module 变成了这样的结构</span></span><br><span class="line">    <span class="comment">// module.exports = 1</span></span><br><span class="line">    <span class="comment">// 这样就能在外部取到导出的内容了</span></span><br><span class="line">    exports.default = a</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 省略</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>虽然实现这个工具只写了不到 <code>100</code> 行的代码，但是打包工具的核心原理就是这些了</p></blockquote><ul><li>找出入口文件所有的依赖关系</li><li>然后通过构建 <code>CommonJS</code> 代码来获取 <code>exports</code> 导出的内容</li></ul><h2 id="27-MVVM-虚拟DOM-前端路由"><a href="#27-MVVM-虚拟DOM-前端路由" class="headerlink" title="27 MVVM/虚拟DOM/前端路由"></a>27 MVVM/虚拟DOM/前端路由</h2><h3 id="27-1-MVVM"><a href="#27-1-MVVM" class="headerlink" title="27.1 MVVM"></a>27.1 MVVM</h3><blockquote><p>涉及面试题：什么是 <code>MVVM</code>？比之 <code>MVC</code> 有什么区别？</p></blockquote><p><strong>首先先来说下 View 和 Model</strong></p><ul><li><code>View</code> 很简单，就是用户看到的视图</li><li><code>Model</code> 同样很简单，一般就是本地数据和数据库中的数据</li></ul><blockquote><p>基本上，我们写的产品就是通过接口从数据库中读取数据，然后将数据经过处理展现到用户看到的视图上。当然我们还可以从视图上读取用户的输入，然后又将用户的输入通过接口写入到数据库中。但是，如何将数据展示到视图上，然后又如何将用户的输入写入到数据中，不同的人就产生了不同的看法，从此出现了很多种架构设计。</p></blockquote><blockquote><p>传统的 <code>MVC</code> 架构通常是使用控制器更新模型，视图从模型中获取数据去渲染。当用户有输入时，会通过控制器去更新模型，并且通知视图进行更新</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/12/20/167cad938817eb7e" alt=""></p><ul><li>但是 <code>MVC</code> 有一个巨大的缺陷就是控制器承担的责任太大了，随着项目愈加复杂，控制器中的代码会越来越臃肿，导致出现不利于维护的情况。</li><li>在 <code>MVVM</code> 架构中，引入了 <code>ViewModel</code> 的概念。<code>ViewModel</code> 只关心数据和业务的处理，不关心 <code>View</code> 如何处理数据，在这种情况下，<code>View</code>和 <code>Model</code> 都可以独立出来，任何一方改变了也不一定需要改变另一方，并且可以将一些可复用的逻辑放在一个 <code>ViewModel</code> 中，让多个 <code>View</code> 复用这个 <code>ViewModel</code>。</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/12/21/167ced454926a458" alt=""></p><ul><li>以 <code>Vue</code> 框架来举例，<code>ViewModel</code> 就是组件的实例。<code>View</code> 就是模板，<code>Model</code> 的话在引入 <code>Vuex</code> 的情况下是完全可以和组件分离的。</li><li>除了以上三个部分，其实在 <code>MVVM</code> 中还引入了一个隐式的 <code>Binder</code> 层，实现了 <code>View</code> 和 <code>ViewModel</code> 的绑定</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/12/21/167cf01bd8430243" alt=""></p><ul><li>同样以 <code>Vue</code> 框架来举例，这个隐式的 <code>Binder</code> 层就是 <code>Vue</code> 通过解析模板中的插值和指令从而实现 <code>View</code> 与 <code>ViewModel</code> 的绑定。</li><li>对于 <code>MVVM</code>来说，其实最重要的并不是通过双向绑定或者其他的方式将 <code>View</code> 与 <code>ViewModel</code> 绑定起来，而是通过 <code>ViewModel</code> 将视图中的状态和用户的行为分离出一个抽象，这才是 <code>MVVM</code> 的精髓</li></ul><h3 id="27-2-Virtual-DOM"><a href="#27-2-Virtual-DOM" class="headerlink" title="27.2 Virtual DOM"></a>27.2 Virtual DOM</h3><blockquote><p>涉及面试题：什么是 <code>Virtual DOM</code>？为什么 <code>Virtual DOM</code>比原生 <code>DOM</code> 快？</p></blockquote><ul><li>大家都知道操作 <code>DOM</code> 是很慢的，为什么慢的原因以及在「浏览器渲染原理」章节中说过，这里就不再赘述了- 那么相较于 <code>DOM</code>来说，操作 <code>JS</code> 对象会快很多，并且我们也可以通过 <code>JS</code>来模拟 <code>DOM</code></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ul = &#123;</span><br><span class="line">  tag: <span class="string">'ul'</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    class: 'list'</span><br><span class="line">  &#125;,</span><br><span class="line">  children: &#123;</span><br><span class="line">    tag: <span class="string">'li'</span>,</span><br><span class="line">    children: <span class="string">'1'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码对应的 <code>DOM</code> 就是</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">'list'</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>那么既然 <code>DOM</code> 可以通过 <code>JS</code> 对象来模拟，反之也可以通过 <code>JS</code> 对象来渲染出对应的 <code>DOM</code>。当然了，通过 <code>JS</code> 来模拟 <code>DOM</code> 并且渲染对应的 <code>DOM</code> 只是第一步，难点在于如何判断新旧两个 <code>JS</code> 对象的最小差异并且实现局部更新 <code>DOM</code></li></ul><blockquote><p>首先 <code>DOM</code> 是一个多叉树的结构，如果需要完整的对比两颗树的差异，那么需要的时间复杂度会是 <code>O(n ^ 3)</code>，这个复杂度肯定是不能接受的。于是 <code>React</code> 团队优化了算法，实现了 <code>O(n)</code> 的复杂度来对比差异。 实现 <code>O(n)</code> 复杂度的关键就是只对比同层的节点，而不是跨层对比，这也是考虑到在实际业务中很少会去跨层的移动 <code>DOM</code> 元素。 所以判断差异的算法就分为了两步</p></blockquote><ul><li>首先从上至下，从左往右遍历对象，也就是树的深度遍历，这一步中会给每个节点添加索引，便于最后渲染差异</li><li>一旦节点有子元素，就去判断子元素是否有不同</li></ul><blockquote><p>在第一步算法中我们需要判断新旧节点的 <code>tagName</code> 是否相同，如果不相同的话就代表节点被替换了。如果没有更改 <code>tagName</code> 的话，就需要判断是否有子元素，有的话就进行第二步算法。</p></blockquote><blockquote><p>在第二步算法中，我们需要判断原本的列表中是否有节点被移除，在新的列表中需要判断是否有新的节点加入，还需要判断节点是否有移动。</p></blockquote><p>举个例子来说，假设页面中只有一个列表，我们对列表中的元素进行了变更</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设这里模拟一个 ul，其中包含了 5 个 li</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="comment">// 这里替换上面的 li</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure><blockquote><p>从上述例子中，我们一眼就可以看出先前的 <code>ul</code> 中的第三个<code>li</code>被移除了，四五替换了位置。</p></blockquote><blockquote><p>那么在实际的算法中，我们如何去识别改动的是哪个节点呢？这就引入了 <code>key</code> 这个属性，想必大家在 <code>Vue</code> 或者 <code>React</code> 的列表中都用过这个属性。这个属性是用来给每一个节点打标志的，用于判断是否是同一个节点。</p></blockquote><ul><li>当然在判断以上差异的过程中，我们还需要判断节点的属性是否有变化等等。</li><li>当我们判断出以上的差异后，就可以把这些差异记录下来。当对比完两棵树以后，就可以通过差异去局部更新 <code>DOM</code>，实现性能的最优化。</li></ul><blockquote><p>当然了 <code>Virtual DOM</code> 提高性能是其中一个优势，其实最大的优势还是在于：</p></blockquote><ul><li>将 <code>Virtual DOM</code>作为一个兼容层，让我们还能对接非 <code>Web</code> 端的系统，实现跨端开发。</li><li>同样的，通过 <code>Virtual DOM</code>我们可以渲染到其他的平台，比如实现 <code>SSR</code>、同构渲染等等。</li><li>实现组件的高度抽象化</li></ul><h3 id="27-3-路由原理"><a href="#27-3-路由原理" class="headerlink" title="27.3 路由原理"></a>27.3 路由原理</h3><blockquote><p>涉及面试题：前端路由原理？两种实现方式有什么区别？</p></blockquote><blockquote><p>前端路由实现起来其实很简单，本质就是监听 <code>URL</code> 的变化，然后匹配路由规则，显示相应的页面，并且无须刷新页面。目前前端使用的路由就只有两种实现方式</p></blockquote><ul><li><code>Hash</code> 模式</li><li><code>History</code> 模式</li></ul><p><strong>1. Hash 模式</strong></p><blockquote><p><code>www.test.com/#/</code> 就是 <code>Hash URL</code>，当 <code>#</code> 后面的哈希值发生变化时，可以通过 <code>hashchange</code> 事件来监听到 <code>URL</code> 的变化，从而进行跳转页面，并且无论哈希值如何变化，服务端接收到的 <code>URL</code> 请求永远是 <code>www.test.com</code></p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'hashchange'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// ... 具体逻辑</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p><code>Hash</code> 模式相对来说更简单，并且兼容性也更好</p></blockquote><p><strong>2. History 模式</strong></p><blockquote><p><code>History</code> 模式是 <code>HTML5</code> 新推出的功能，主要使用 <code>history.pushState</code> 和 <code>history.replaceState</code> 改变 <code>URL</code></p></blockquote><ul><li>通过 <code>History</code> 模式改变 <code>URL</code> 同样不会引起页面的刷新，只会更新浏览器的历史记录。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 新增历史记录</span></span><br><span class="line">history.pushState(stateObject, title, URL)</span><br><span class="line"><span class="comment">// 替换当前历史记录</span></span><br><span class="line">history.replaceState(stateObject, title, URL)</span><br></pre></td></tr></table></figure><blockquote><p>当用户做出浏览器动作时，比如点击后退按钮时会触发 <code>popState</code> 事件</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'popstate'</span>, e =&gt; &#123;</span><br><span class="line">  <span class="comment">// e.state 就是 pushState(stateObject) 中的 stateObject</span></span><br><span class="line">  <span class="built_in">console</span>.log(e.state)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>两种模式对比</strong></p><ul><li><code>Hash</code>模式只可以更改 <code>#</code> 后面的内容，<code>History</code> 模式可以通过 <code>API</code> 设置任意的同源 <code>URL</code></li><li><code>History</code> 模式可以通过 <code>API</code> 添加任意类型的数据到历史记录中，<code>Hash</code> 模式只能更改哈希值，也就是字符串</li><li><code>Hash</code> 模式无需后端配置，并且兼容性好。<code>History</code> 模式在用户手动输入地址或者刷新页面的时候会发起 <code>URL</code> 请求，后端需要配置 <code>index.html</code> 页面用于匹配不到静态资源的时候</li></ul><h3 id="27-4-Vue-和-React-之间的区别"><a href="#27-4-Vue-和-React-之间的区别" class="headerlink" title="27.4 Vue 和 React 之间的区别"></a>27.4 Vue 和 React 之间的区别</h3><ul><li><code>Vue</code> 的表单可以使用 <code>v-model</code> 支持双向绑定，相比于 <code>React</code> 来说开发上更加方便，当然了 <code>v-model</code> 其实就是个语法糖，本质上和 <code>React</code> 写表单的方式没什么区别</li><li>改变数据方式不同，<code>Vue</code> 修改状态相比来说要简单许多，<code>React</code> 需要使用 <code>setState</code> 来改变状态，并且使用这个 <code>API</code> 也有一些坑点。并且 <code>Vue</code> 的底层使用了依赖追踪，页面更新渲染已经是最优的了，但是 <code>React</code> 还是需要用户手动去优化这方面的问题。</li><li><code>React 16</code>以后，有些钩子函数会执行多次，这是因为引入 <code>Fiber</code> 的原因</li><li><code>React</code> 需要使用 <code>JSX</code>，有一定的上手成本，并且需要一整套的工具链支持，但是完全可以通过 <code>JS</code> 来控制页面，更加的灵活。<code>Vue</code> 使用了模板语法，相比于 <code>JSX</code> 来说没有那么灵活，但是完全可以脱离工具链，通过直接编写 <code>render</code> 函数就能在浏览器中运行。</li><li>在生态上来说，两者其实没多大的差距，当然 <code>React</code>的用户是远远高于<code>Vue</code> 的</li></ul><h2 id="28-Vue常考知识点"><a href="#28-Vue常考知识点" class="headerlink" title="28 Vue常考知识点"></a>28 Vue常考知识点</h2><h3 id="28-1-生命周期钩子函数"><a href="#28-1-生命周期钩子函数" class="headerlink" title="28.1 生命周期钩子函数"></a>28.1 生命周期钩子函数</h3><ul><li>在 <code>beforeCreate</code> 钩子函数调用的时候，是获取不到 <code>props</code> 或者 <code>data</code> 中的数据的，因为这些数据的初始化都在 <code>initState</code> 中。</li><li>然后会执行 <code>created</code> 钩子函数，在这一步的时候已经可以访问到之前不能访问到的数据，但是这时候组件还没被挂载，所以是看不到的。</li><li>接下来会先执行 <code>beforeMount</code> 钩子函数，开始创建 <code>VDOM</code>，最后执行 <code>mounted</code> 钩子，并将 <code>VDOM</code>渲染为真实 <code>DOM</code> 并且渲染数据。组件中如果有子组件的话，会递归挂载子组件，只有当所有子组件全部挂载完毕，才会执行根组件的挂载钩子。</li><li>接下来是数据更新时会调用的钩子函数 <code>beforeUpdate</code> 和 <code>updated</code>，这两个钩子函数没什么好说的，就是分别在数据更新前和更新后会调用。</li><li>另外还有 <code>keep-alive</code> 独有的生命周期，分别为 <code>activated</code> 和 <code>deactivated</code>。用 <code>keep-alive</code> 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 <code>deactivated</code> 钩子函数，命中缓存渲染后会执行 <code>actived</code> 钩子函数。</li><li>最后就是销毁组件的钩子函数 <code>beforeDestroy</code> 和 <code>destroyed</code>。前者适合移除事件、定时器等等，否则可能会引起内存泄露的问题。然后进行一系列的销毁操作，如果有子组件的话，也会递归销毁子组件，所有子组件都销毁完毕后才会执行根组件的 <code>destroyed</code> 钩子函数</li></ul><h3 id="28-2-组件通信"><a href="#28-2-组件通信" class="headerlink" title="28.2 组件通信"></a>28.2 组件通信</h3><blockquote><p>组件通信一般分为以下几种情况：</p></blockquote><ul><li>父子组件通信</li><li>兄弟组件通信</li><li>跨多层级组件通信</li></ul><blockquote><p>对于以上每种情况都有多种方式去实现，接下来就来学习下如何实现。</p></blockquote><p><strong>1. 父子通信</strong></p><ul><li>父组件通过 <code>props</code> 传递数据给子组件，子组件通过 <code>emit</code> 发送事件传递数据给父组件，这两种方式是最常用的父子通信实现办法。</li><li>这种父子通信方式也就是典型的单向数据流，父组件通过 <code>props</code> 传递数据，子组件不能直接修改 <code>props</code>，而是必须通过发送事件的方式告知父组件修改数据。</li><li>另外这两种方式还可以使用语法糖 <code>v-model</code> 来直接实现，因为 <code>v-model</code> 默认会解析成名为 <code>value</code> 的 <code>prop</code> 和名为 <code>input</code> 的事件。这种语法糖的方式是典型的双向绑定，常用于 <code>UI</code> 控件上，但是究其根本，还是通过事件的方法让父组件修改数据。</li><li>当然我们还可以通过访问 <code>$parent</code> 或者 <code>$children</code> 对象来访问组件实例中的方法和数据。</li><li>另外如果你使用 Vue 2.3 及以上版本的话还可以使用 <code>$listeners</code> 和 <code>.sync</code> 这两个属性。</li><li><code>$listeners</code> 属性会将父组件中的 (不含 <code>.native</code> 修饰器的) <code>v-on</code> 事件监听器传递给子组件，子组件可以通过访问 <code>$listeners</code> 来自定义监听器。</li><li><code>.sync</code> 属性是个语法糖，可以很简单的实现子组件与父组件通信</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--父组件中--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">:value.sync</span>=<span class="string">"value"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!--以上写法等同于--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">:value</span>=<span class="string">"value"</span> @<span class="attr">update:value</span>=<span class="string">"v =&gt; value = v"</span>&gt;</span><span class="tag">&lt;/<span class="name">comp</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--子组件中--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">  <span class="keyword">this</span>.$emit(<span class="string">'update:value'</span>, <span class="number">1</span>)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>2. 兄弟组件通信</strong></p><blockquote><p>对于这种情况可以通过查找父组件中的子组件实现，也就是 <code>this.$parent.$children</code>，在 <code>$children</code> 中可以通过组件 <code>name</code> 查询到需要的组件实例，然后进行通信。</p></blockquote><p><strong>3. 跨多层次组件通信</strong></p><blockquote><p>对于这种情况可以使用 <code>Vue 2.2</code> 新增的 <code>API provide / inject</code>，虽然文档中不推荐直接使用在业务中，但是如果用得好的话还是很有用的。</p></blockquote><p>假设有父组件 <code>A</code>，然后有一个跨多层级的子组件 <code>B</code></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父组件 A</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  provide: &#123;</span><br><span class="line">    data: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子组件 B</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  inject: [<span class="string">'data'</span>],</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    <span class="comment">// 无论跨几层都能获得父组件的 data 属性</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.data) <span class="comment">// =&gt; 1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>终极办法解决一切通信问题</strong></p><blockquote><p>只要你不怕麻烦，可以使用 <code>Vuex</code> 或者 <code>Event Bus</code> 解决上述所有的通信情况。</p></blockquote><h3 id="28-3-extend-能做什么"><a href="#28-3-extend-能做什么" class="headerlink" title="28.3 extend 能做什么"></a>28.3 extend 能做什么</h3><blockquote><p>这个 <code>API</code> 很少用到，作用是扩展组件生成一个构造器，通常会与 <code>$mount</code> 一起使用。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建组件构造器</span></span><br><span class="line"><span class="keyword">let</span> Component = Vue.extend(&#123;</span><br><span class="line">  template: <span class="string">'&lt;div&gt;test&lt;/div&gt;'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 挂载到 #app 上</span></span><br><span class="line"><span class="keyword">new</span> Component().$mount(<span class="string">'#app'</span>)</span><br><span class="line"><span class="comment">// 除了上面的方式，还可以用来扩展已有的组件</span></span><br><span class="line"><span class="keyword">let</span> SuperComponent = Vue.extend(Component)</span><br><span class="line"><span class="keyword">new</span> SuperComponent(&#123;</span><br><span class="line">    created() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> SuperComponent().$mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure><h3 id="28-4-mixin-和-mixins-区别"><a href="#28-4-mixin-和-mixins-区别" class="headerlink" title="28.4 mixin 和 mixins 区别"></a>28.4 mixin 和 mixins 区别</h3><blockquote><p><code>mixin</code> 用于全局混入，会影响到每个组件实例，通常插件都是这样做初始化的</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.mixin(&#123;</span><br><span class="line">    beforeCreate() &#123;</span><br><span class="line">        <span class="comment">// ...逻辑</span></span><br><span class="line">        <span class="comment">// 这种方式会影响到每个组件的 beforeCreate 钩子函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>虽然文档不建议我们在应用中直接使用 <code>mixin</code>，但是如果不滥用的话也是很有帮助的，比如可以全局混入封装好的 <code>ajax</code> 或者一些工具函数等等。</li><li><code>mixins</code> 应该是我们最常使用的扩展组件的方式了。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过 <code>mixins</code> 混入代码，比如上拉下拉加载数据这种逻辑等等。</li><li>另外需要注意的是 <code>mixins</code> 混入的钩子函数会先于组件内的钩子函数执行，并且在遇到同名选项的时候也会有选择性的进行合并，具体可以阅读 文档。</li></ul><h3 id="28-5-computed-和-watch-区别"><a href="#28-5-computed-和-watch-区别" class="headerlink" title="28.5 computed 和 watch 区别"></a>28.5 computed 和 watch 区别</h3><ul><li><code>computed</code> 是计算属性，依赖其他属性计算值，并且 <code>computed</code> 的值有缓存，只有当计算值变化才会返回内容。</li><li><code>watch</code> 监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。</li><li>所以一般来说需要依赖别的属性来动态获得值的时候可以使用 <code>computed</code>，对于监听到值的变化需要做一些复杂业务逻辑的情况可以使用 <code>watch</code>。</li><li>另外 <code>computer</code> 和 <code>watch</code> 还都支持对象的写法，这种方式知道的人并不多。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vm.$watch(<span class="string">'obj'</span>, &#123;</span><br><span class="line">    <span class="comment">// 深度遍历</span></span><br><span class="line">    deep: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 立即触发</span></span><br><span class="line">    immediate: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 执行的函数</span></span><br><span class="line">    handler: <span class="function"><span class="keyword">function</span>(<span class="params">val, oldVal</span>) </span>&#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    aPlus: &#123;</span><br><span class="line">      <span class="comment">// this.aPlus 时触发</span></span><br><span class="line">      <span class="keyword">get</span>: function () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.a + <span class="number">1</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// this.aPlus = 1 时触发</span></span><br><span class="line">      <span class="keyword">set</span>: function (v) &#123;</span><br><span class="line">        <span class="keyword">this</span>.a = v - <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="28-6-keep-alive-组件有什么作用"><a href="#28-6-keep-alive-组件有什么作用" class="headerlink" title="28.6 keep-alive 组件有什么作用"></a>28.6 keep-alive 组件有什么作用</h3><ul><li>如果你需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用 <code>keep-alive</code> 组件包裹需要保存的组件。</li><li>对于 <code>keep-alive</code> 组件来说，它拥有两个独有的生命周期钩子函数，分别为 <code>activated</code> 和 <code>deactivated</code> 。用 <code>keep-alive</code> 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 <code>deactivated</code> 钩子函数，命中缓存渲染后会执行 <code>actived</code> 钩子函数。</li></ul><h3 id="28-7-v-show-与-v-if-区别"><a href="#28-7-v-show-与-v-if-区别" class="headerlink" title="28.7 v-show 与 v-if 区别"></a>28.7 v-show 与 v-if 区别</h3><ul><li><code>v-show</code> 只是在 <code>display: none</code> 和 <code>display: block</code> 之间切换。无论初始条件是什么都会被渲染出来，后面只需要切换 <code>CSS</code>，<code>DOM</code> 还是一直保留着的。所以总的来说 <code>v-show</code> 在初始渲染时有更高的开销，但是切换开销很小，更适合于频繁切换的场景。</li><li><code>v-if</code> 的话就得说到 <code>Vue</code> 底层的编译了。当属性初始为 <code>false</code> 时，组件就不会被渲染，直到条件为 <code>true</code>，并且切换条件时会触发销毁/挂载组件，所以总的来说在切换时开销更高，更适合不经常切换的场景。</li><li>并且基于 <code>v-if</code> 的这种惰性渲染机制，可以在必要的时候才去渲染组件，减少整个页面的初始渲染开销。</li></ul><h3 id="28-8-组件中-data-什么时候可以使用对象"><a href="#28-8-组件中-data-什么时候可以使用对象" class="headerlink" title="28.8 组件中 data 什么时候可以使用对象"></a>28.8 组件中 data 什么时候可以使用对象</h3><blockquote><p>这道题目其实更多考的是 JS 功底。</p></blockquote><ul><li>组件复用时所有组件实例都会共享 <code>data</code>，如果 <code>data</code> 是对象的话，就会造成一个组件修改 <code>data</code> 以后会影响到其他所有组件，所以需要将 <code>data</code> 写成函数，每次用到就调用一次函数获得新的数据。</li><li>当我们使用 <code>new Vue()</code> 的方式的时候，无论我们将 <code>data</code> 设置为对象还是函数都是可以的，因为 <code>new Vue()</code> 的方式是生成一个根组件，该组件不会复用，也就不存在共享 <code>data</code> 的情况了</li></ul><blockquote><p>以下是进阶部分</p></blockquote><h3 id="28-9-响应式原理"><a href="#28-9-响应式原理" class="headerlink" title="28.9 响应式原理"></a>28.9 响应式原理</h3><blockquote><p><code>Vue</code> 内部使用了 <code>Object.defineProperty()</code> 来实现数据响应式，通过这个函数可以监听到 <code>set</code> 和 <code>get</code> 的事件</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123; <span class="attr">name</span>: <span class="string">'poetries'</span> &#125;</span><br><span class="line">observe(data)</span><br><span class="line"><span class="keyword">let</span> name = data.name <span class="comment">// -&gt; get value</span></span><br><span class="line">data.name = <span class="string">'yyy'</span> <span class="comment">// -&gt; change value</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断类型</span></span><br><span class="line">  <span class="keyword">if</span> (!obj || <span class="keyword">typeof</span> obj !== <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Object</span>.keys(obj).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    defineReactive(obj, key, obj[key])</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj, key, val</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 递归子属性</span></span><br><span class="line">  observe(val)</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    <span class="comment">// 可枚举</span></span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 可配置</span></span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 自定义函数</span></span><br><span class="line">    <span class="keyword">get</span>: function reactiveGetter() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'get value'</span>)</span><br><span class="line">      <span class="keyword">return</span> val</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function reactiveSetter(newVal) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'change value'</span>)</span><br><span class="line">      val = newVal</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以上代码简单的实现了如何监听数据的 <code>set</code> 和 <code>get</code> 的事件，但是仅仅如此是不够的，因为自定义的函数一开始是不会执行的。只有先执行了依赖收集，从能在属性更新的时候派发更新，所以接下来我们需要先触发依赖收集</p></blockquote><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    &#123;&#123;name&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>在解析如上模板代码时，遇到 <code></code> 就会进行依赖收集。</li><li>接下来我们先来实现一个 <code>Dep</code> 类，用于解耦属性的依赖收集和派发更新操作</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过 Dep 解耦属性的依赖和更新操作</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs = []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加依赖</span></span><br><span class="line">  addSub(sub) &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs.push(sub)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 更新</span></span><br><span class="line">  notify() &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs.forEach(<span class="function"><span class="params">sub</span> =&gt;</span> &#123;</span><br><span class="line">      sub.update()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 全局属性，通过该属性配置 Watcher</span></span><br><span class="line">Dep.target = <span class="literal">null</span></span><br></pre></td></tr></table></figure><blockquote><p>以上的代码实现很简单，当需要依赖收集的时候调用 <code>addSub</code>，当需要派发更新的时候调用 <code>notify</code>。</p></blockquote><blockquote><p>接下来我们先来简单的了解下 <code>Vue</code>组件挂载时添加响应式的过程。在组件挂载时，会先对所有需要的属性调用 <code>Object.defineProperty()</code>，然后实例化 <code>Watcher</code>，传入组件更新的回调。在实例化过程中，会对模板中的属性进行求值，触发依赖收集。</p></blockquote><p>因为这一小节主要目的是学习响应式原理的细节，所以接下来的代码会简略的表达触发依赖收集时的操作。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(obj, key, cb) &#123;</span><br><span class="line">    <span class="comment">// 将 Dep.target 指向自己</span></span><br><span class="line">    <span class="comment">// 然后触发属性的 getter 添加监听</span></span><br><span class="line">    <span class="comment">// 最后将 Dep.target 置空</span></span><br><span class="line">    Dep.target = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">this</span>.cb = cb</span><br><span class="line">    <span class="keyword">this</span>.obj = obj</span><br><span class="line">    <span class="keyword">this</span>.key = key</span><br><span class="line">    <span class="keyword">this</span>.value = obj[key]</span><br><span class="line">    Dep.target = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  update() &#123;</span><br><span class="line">    <span class="comment">// 获得新值</span></span><br><span class="line">    <span class="keyword">this</span>.value = <span class="keyword">this</span>.obj[<span class="keyword">this</span>.key]</span><br><span class="line">    <span class="comment">// 调用 update 方法更新 Dom</span></span><br><span class="line">    <span class="keyword">this</span>.cb(<span class="keyword">this</span>.value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以上就是 <code>Watcher</code>的简单实现，在执行构造函数的时候将 <code>Dep.target</code>指向自身，从而使得收集到了对应的 <code>Watcher</code>，在派发更新的时候取出对应的 <code>Watcher</code> 然后执行 <code>update</code> 函数。</p></blockquote><p>接下来，需要对<code>defineReactive</code> 函数进行改造，在自定义函数中添加依赖收集和派发更新相关的代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj, key, val</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 递归子属性</span></span><br><span class="line">  observe(val)</span><br><span class="line">  <span class="keyword">let</span> dp = <span class="keyword">new</span> Dep()</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    <span class="keyword">get</span>: function reactiveGetter() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'get value'</span>)</span><br><span class="line">      <span class="comment">// 将 Watcher 添加到订阅</span></span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        dp.addSub(Dep.target)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> val</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function reactiveSetter(newVal) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'change value'</span>)</span><br><span class="line">      val = newVal</span><br><span class="line">      <span class="comment">// 执行 watcher 的 update 方法</span></span><br><span class="line">      dp.notify()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以上所有代码实现了一个简易的数据响应式，核心思路就是手动触发一次属性的 <code>getter</code> 来实现依赖收集。</p></blockquote><p>现在我们就来测试下代码的效果，只需要把所有的代码复制到浏览器中执行，就会发现页面的内容全部被替换了</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123; <span class="attr">name</span>: <span class="string">'poetries'</span> &#125;</span><br><span class="line">observe(data)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.querySelector(<span class="string">'div'</span>).innerText = value</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 模拟解析到 `&#123;&#123;name&#125;&#125;` 触发的操作</span></span><br><span class="line"><span class="keyword">new</span> Watcher(data, <span class="string">'name'</span>, update)</span><br><span class="line"><span class="comment">// update Dom innerText</span></span><br><span class="line">data.name = <span class="string">'yyy'</span></span><br></pre></td></tr></table></figure><h4 id="28-9-1-Object-defineProperty-的缺陷"><a href="#28-9-1-Object-defineProperty-的缺陷" class="headerlink" title="28.9.1 Object.defineProperty 的缺陷"></a>28.9.1 Object.defineProperty 的缺陷</h4><ul><li>以上已经分析完了 <code>Vue</code> 的响应式原理，接下来说一点 <code>Object.defineProperty</code> 中的缺陷。</li><li>如果通过下标方式修改数组数据或者给对象新增属性并不会触发组件的重新渲染，因为<code>Object.defineProperty</code> 不能拦截到这些操作，更精确的来说，对于数组而言，大部分操作都是拦截不到的，只是 <code>Vue</code> 内部通过重写函数的方式解决了这个问题。</li><li>对于第一个问题，<code>Vue</code> 提供了一个 <code>API</code> 解决</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">set</span> (<span class="params">target: Array&lt;any&gt; | Object, key: any, val: any</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 判断是否为数组且下标是否有效</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123;</span><br><span class="line">    <span class="comment">// 调用 splice 函数触发派发更新</span></span><br><span class="line">    <span class="comment">// 该函数已被重写</span></span><br><span class="line">    target.length = <span class="built_in">Math</span>.max(target.length, key)</span><br><span class="line">    target.splice(key, <span class="number">1</span>, val)</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断 key 是否已经存在</span></span><br><span class="line">  <span class="keyword">if</span> (key <span class="keyword">in</span> target &amp;&amp; !(key <span class="keyword">in</span> <span class="built_in">Object</span>.prototype)) &#123;</span><br><span class="line">    target[key] = val</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> ob = (target: any).__ob__</span><br><span class="line">  <span class="comment">// 如果对象不是响应式对象，就赋值返回</span></span><br><span class="line">  <span class="keyword">if</span> (!ob) &#123;</span><br><span class="line">    target[key] = val</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 进行双向绑定</span></span><br><span class="line">  defineReactive(ob.value, key, val)</span><br><span class="line">  <span class="comment">// 手动派发更新</span></span><br><span class="line">  ob.dep.notify()</span><br><span class="line">  <span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对于数组而言，<code>Vue</code>内部重写了以下函数实现派发更新</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获得数组原型</span></span><br><span class="line"><span class="keyword">const</span> arrayProto = <span class="built_in">Array</span>.prototype</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> arrayMethods = <span class="built_in">Object</span>.create(arrayProto)</span><br><span class="line"><span class="comment">// 重写以下函数</span></span><br><span class="line"><span class="keyword">const</span> methodsToPatch = [</span><br><span class="line">  <span class="string">'push'</span>,</span><br><span class="line">  <span class="string">'pop'</span>,</span><br><span class="line">  <span class="string">'shift'</span>,</span><br><span class="line">  <span class="string">'unshift'</span>,</span><br><span class="line">  <span class="string">'splice'</span>,</span><br><span class="line">  <span class="string">'sort'</span>,</span><br><span class="line">  <span class="string">'reverse'</span></span><br><span class="line">]</span><br><span class="line">methodsToPatch.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">method</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 缓存原生函数</span></span><br><span class="line">  <span class="keyword">const</span> original = arrayProto[method]</span><br><span class="line">  <span class="comment">// 重写函数</span></span><br><span class="line">  def(arrayMethods, method, <span class="function"><span class="keyword">function</span> <span class="title">mutator</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 先调用原生函数获得结果</span></span><br><span class="line">    <span class="keyword">const</span> result = original.apply(<span class="keyword">this</span>, args)</span><br><span class="line">    <span class="keyword">const</span> ob = <span class="keyword">this</span>.__ob__</span><br><span class="line">    <span class="keyword">let</span> inserted</span><br><span class="line">    <span class="comment">// 调用以下几个函数时，监听新数据</span></span><br><span class="line">    <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'push'</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'unshift'</span>:</span><br><span class="line">        inserted = args</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'splice'</span>:</span><br><span class="line">        inserted = args.slice(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (inserted) ob.observeArray(inserted)</span><br><span class="line">    <span class="comment">// 手动派发更新</span></span><br><span class="line">    ob.dep.notify()</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="28-9-2-编译过程"><a href="#28-9-2-编译过程" class="headerlink" title="28.9.2 编译过程"></a>28.9.2 编译过程</h4><blockquote><p>想必大家在使用 Vue 开发的过程中，基本都是使用模板的方式。那么你有过「模板是怎么在浏览器中运行的」这种疑虑嘛？</p></blockquote><ul><li>首先直接把模板丢到浏览器中肯定是不能运行的，模板只是为了方便开发者进行开发。<code>Vue</code> 会通过编译器将模板通过几个阶段最终编译为 <code>render</code> 函数，然后通过执行 <code>render</code> 函数生成 <code>Virtual DOM</code> 最终映射为真实 <code>DOM</code>。</li><li>接下来我们就来学习这个编译的过程，了解这个过程中大概发生了什么事情。<strong>这个过程其中又分为三个阶段</strong>，分别为：</li></ul><blockquote><ul><li>将模板解析为 <code>AST</code></li><li>优化 <code>AST</code></li><li>将 <code>AST</code>转换为 <code>render</code>函数</li></ul></blockquote><p>在第一个阶段中，最主要的事情还是通过各种各样的正则表达式去匹配模板中的内容，然后将内容提取出来做各种逻辑操作，接下来会生成一个最基本的 <code>AST</code>对象</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 类型</span></span><br><span class="line">    type: <span class="number">1</span>,</span><br><span class="line">    <span class="comment">// 标签</span></span><br><span class="line">    tag,</span><br><span class="line">    <span class="comment">// 属性列表</span></span><br><span class="line">    attrsList: attrs,</span><br><span class="line">    <span class="comment">// 属性映射</span></span><br><span class="line">    attrsMap: makeAttrsMap(attrs),</span><br><span class="line">    <span class="comment">// 父节点</span></span><br><span class="line">    parent,</span><br><span class="line">    <span class="comment">// 子节点</span></span><br><span class="line">    children: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>然后会根据这个最基本的 AST 对象中的属性，进一步扩展 <code>AST</code>。</li><li>当然在这一阶段中，还会进行其他的一些判断逻辑。比如说对比前后开闭标签是否一致，判断根组件是否只存在一个，判断是否符合 <code>HTML5 Content Model</code>规范等等问题。</li><li>接下来就是优化 AST 的阶段。在当前版本下，<code>Vue</code> 进行的优化内容其实还是不多的。只是对节点进行了静态内容提取，也就是将永远不会变动的节点提取了出来，实现复用 <code>Virtual DOM</code>，跳过对比算法的功能。在下一个大版本中，<code>Vue</code> 会在优化 <code>AST</code> 的阶段继续发力，实现更多的优化功能，尽可能的在编译阶段压榨更多的性能，比如说提取静态的属性等等优化行为。</li><li>最后一个阶段就是通过 <code>AST</code> 生成 <code>render</code> 函数了。其实这一阶段虽然分支有很多，但是最主要的目的就是遍历整个 <code>AST</code>，根据不同的条件生成不同的代码罢了。</li></ul><h4 id="28-9-3-NextTick-原理分析"><a href="#28-9-3-NextTick-原理分析" class="headerlink" title="28.9.3 NextTick 原理分析"></a>28.9.3 NextTick 原理分析</h4><blockquote><p><code>nextTick</code> 可以让我们在下次 <code>DOM</code> 更新循环结束之后执行延迟回调，用于获得更新后的 <code>DOM</code>。</p></blockquote><ul><li>在 <code>Vue 2.4</code> 之前都是使用的 <code>microtasks</code>，但是<code>microtasks</code> 的优先级过高，在某些情况下可能会出现比事件冒泡更快的情况，但如果都使用 <code>macrotasks</code> 又可能会出现渲染的性能问题。所以在新版本中，会默认使用 <code>microtasks</code>，但在特殊情况下会使用 <code>macrotasks</code>，比如 <code>v-on</code>。</li><li>对于实现 <code>macrotasks</code> ，会先判断是否能使用 <code>setImmediate</code> ，不能的话降级为 <code>MessageChannel</code> ，以上都不行的话就使用 <code>setTimeout</code></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> setImmediate !== <span class="string">'undefined'</span> &amp;&amp; isNative(setImmediate)) &#123;</span><br><span class="line">  macroTimerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setImmediate(flushCallbacks)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">  <span class="keyword">typeof</span> MessageChannel !== <span class="string">'undefined'</span> &amp;&amp;</span><br><span class="line">  (isNative(MessageChannel) ||</span><br><span class="line">    <span class="comment">// PhantomJS</span></span><br><span class="line">    MessageChannel.toString() === <span class="string">'[object MessageChannelConstructor]'</span>)</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">const</span> channel = <span class="keyword">new</span> MessageChannel()</span><br><span class="line">  <span class="keyword">const</span> port = channel.port2</span><br><span class="line">  channel.port1.onmessage = flushCallbacks</span><br><span class="line">  macroTimerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    port.postMessage(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  macroTimerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(flushCallbacks, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以上代码很简单，就是判断能不能使用相应的<code>API</code></p></blockquote><h2 id="29-React常考知识点"><a href="#29-React常考知识点" class="headerlink" title="29 React常考知识点"></a>29 React常考知识点</h2><h3 id="29-1-生命周期"><a href="#29-1-生命周期" class="headerlink" title="29.1 生命周期"></a>29.1 生命周期</h3><blockquote><p>在 <code>V16</code> 版本中引入了 <code>Fiber</code> 机制。这个机制一定程度上的影响了部分生命周期的调用，并且也引入了新的 <code>2</code> 个 <code>API</code> 来解决问题</p></blockquote><blockquote><p>在之前的版本中，如果你拥有一个很复杂的复合组件，然后改动了最上层组件的 <code>state</code>，那么调用栈可能会很长</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/6/25/164358b0310f476c" alt=""></p><ul><li>调用栈过长，再加上中间进行了复杂的操作，就可能导致长时间阻塞主线程，带来不好的用户体验。<code>Fiber</code> 就是为了解决该问题而生</li><li><code>Fiber</code> 本质上是一个虚拟的堆栈帧，新的调度器会按照优先级自由调度这些帧，从而将之前的同步渲染改成了异步渲染，在不影响体验的情况下去分段计算更新</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/6/25/164358f89595d56f" alt=""></p><ul><li>对于如何区别优先级，<code>React</code> 有自己的一套逻辑。对于动画这种实时性很高的东西，也就是 <code>16 ms</code> 必须渲染一次保证不卡顿的情况下，<code>React</code> 会每 <code>16 ms</code>（以内） 暂停一下更新，返回来继续渲染动画</li><li>对于异步渲染，现在渲染有两个阶段：<code>reconciliation</code> 和 <code>commit</code> 。前者过程是可以打断的，后者不能暂停，会一直更新界面直到完成。</li></ul><p><strong>1. Reconciliation 阶段</strong></p><ul><li><code>componentWillMount</code></li><li><code>componentWillReceiveProps</code></li><li><code>shouldComponentUpdate</code></li><li><code>componentWillUpdate</code></li></ul><p><strong>2. Commit 阶段</strong></p><ul><li><code>componentDidMount</code></li><li><code>componentDidUpdate</code></li><li><code>componentWillUnmount</code></li></ul><blockquote><p>因为 <code>Reconciliation</code> 阶段是可以被打断的，所以 <code>Reconciliation</code> 阶段会执行的生命周期函数就可能会出现调用多次的情况，从而引起 <code>Bug</code>。由此对于 <code>Reconciliation</code> 阶段调用的几个函数，除了 <code>shouldComponentUpdate</code> 以外，其他都应该避免去使用，并且 <code>V16</code> 中也引入了新的 <code>API</code> 来解决这个问题。</p></blockquote><blockquote><p><code>getDerivedStateFromProps</code> 用于替换 <code>componentWillReceiveProps</code> ，该函数会在初始化和 <code>update</code> 时被调用</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Initialize state in constructor,</span></span><br><span class="line">  <span class="comment">// Or with a property initializer.</span></span><br><span class="line">  state = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> getDerivedStateFromProps(nextProps, prevState) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prevState.someMirroredValue !== nextProps.someValue) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        derivedData: computeDerivedState(nextProps),</span><br><span class="line">        someMirroredValue: nextProps.someValue</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return null to indicate no change to state.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>getSnapshotBeforeUpdate</code> 用于替换 <code>componentWillUpdate</code> ，该函数会在 <code>update</code> 后 <code>DOM</code> 更新前被调用，用于读取最新的 <code>DOM</code> 数据</p></blockquote><blockquote><p>更多详情 <a href="http://blog.poetries.top/2018/11/18/react-lifecircle" target="_blank" rel="noopener">http://blog.poetries.top/2018/11/18/react-lifecircle</a></p></blockquote><h3 id="29-2-setState"><a href="#29-2-setState" class="headerlink" title="29.2 setState"></a>29.2 setState</h3><ul><li><code>setState</code> 在 <code>React</code> 中是经常使用的一个 <code>API</code>，但是它存在一些的问题经常会导致初学者出错，核心原因就是因为这个 <code>API</code> 是异步的。</li><li>首先  <code>setState</code>   的调用并不会马上引起   <code>state</code>  的改变，并且如果你一次调用了多个   <code>setState</code>   ，那么结果可能并不如你期待的一样。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">handle() &#123;</span><br><span class="line">  <span class="comment">// 初始化 `count` 为 0</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.count) <span class="comment">// -&gt; 0</span></span><br><span class="line">  <span class="keyword">this</span>.setState(&#123; <span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span> &#125;)</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123; <span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span> &#125;)</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123; <span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span> &#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.count) <span class="comment">// -&gt; 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第一，两次的打印都为 <code>0</code>，因为 <code>setState</code> 是个异步 <code>API</code>，只有同步代码运行完毕才会执行。<code>setState</code> 异步的原因我认为在于，<code>setState</code> 可能会导致 <code>DOM</code> 的重绘，如果调用一次就马上去进行重绘，那么调用多次就会造成不必要的性能损失。设计成异步的话，就可以将多次调用放入一个队列中，在恰当的时候统一进行更新过程。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(  </span><br><span class="line">  &#123;&#125;,</span><br><span class="line">  &#123; <span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">count</span>: <span class="keyword">this</span>.state.count + <span class="number">1</span> &#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><blockquote><p>当然你也可以通过以下方式来实现调用三次 <code>setState</code>使得 <code>count</code> 为 <code>3</code></p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">handle() &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState</span>) =&gt;</span> (&#123; <span class="attr">count</span>: prevState.count + <span class="number">1</span> &#125;))</span><br><span class="line">  <span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState</span>) =&gt;</span> (&#123; <span class="attr">count</span>: prevState.count + <span class="number">1</span> &#125;))</span><br><span class="line">  <span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState</span>) =&gt;</span> (&#123; <span class="attr">count</span>: prevState.count + <span class="number">1</span> &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果你想在每次调用 <code>setState</code> 后获得正确的 <code>state</code>，可以通过如下代码实现</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">handle() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState</span>) =&gt;</span> <span class="function">(<span class="params">&#123; count: prevState.count + <span class="number">1</span> &#125;</span>), <span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.state)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>更多详情 <a href="http://blog.poetries.top/2018/12/20/react-setState" target="_blank" rel="noopener">http://blog.poetries.top/2018/12/20/react-setState</a></p></blockquote><h3 id="29-3-性能优化"><a href="#29-3-性能优化" class="headerlink" title="29.3 性能优化"></a>29.3 性能优化</h3><ul><li>在 <code>shouldComponentUpdate</code> 函数中我们可以通过返回布尔值来决定当前组件是否需要更新。这层代码逻辑可以是简单地浅比较一下当前 <code>state</code> 和之前的 <code>state</code> 是否相同，也可以是判断某个值更新了才触发组件更新。一般来说不推荐完整地对比当前 <code>state</code> 和之前的 <code>state</code> 是否相同，因为组件更新触发可能会很频繁，这样的完整对比性能开销会有点大，可能会造成得不偿失的情况。</li><li>当然如果真的想完整对比当前 <code>state</code> 和之前的 <code>state</code> 是否相同，并且不影响性能也是行得通的，可以通过 <code>immutable</code> 或者 <code>immer</code> 这些库来生成不可变对象。这类库对于操作大规模的数据来说会提升不错的性能，并且一旦改变数据就会生成一个新的对象，对比前后 <code>state</code> 是否一致也就方便多了，同时也很推荐阅读下 <code>immer</code> 的源码实现</li><li>另外如果只是单纯的浅比较一下，可以直接使用 <code>PureComponent</code>，底层就是实现了浅比较 <code>state</code></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">PureComponent</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        PureComponent</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>这时候你可能会考虑到函数组件就不能使用这种方式了，如果你使用 <code>16.6.0</code> 之后的版本的话，可以使用 <code>React.memo</code> 来实现相同的功能</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Test = React.memo(<span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        PureComponent</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">))</span></span><br></pre></td></tr></table></figure><blockquote><p>通过这种方式我们就可以既实现了 <code>shouldComponentUpdate</code> 的浅比较，又能够使用函数组件</p></blockquote><h3 id="29-4-通信"><a href="#29-4-通信" class="headerlink" title="29.4 通信"></a>29.4 通信</h3><p><strong>1. 父子通信</strong></p><ul><li>父组件通过 <code>props</code> 传递数据给子组件，子组件通过调用父组件传来的函数传递数据给父组件，这两种方式是最常用的父子通信实现办法。</li><li>这种父子通信方式也就是典型的单向数据流，父组件通过 <code>props</code> 传递数据，子组件不能直接修改 <code>props</code>， 而是必须通过调用父组件函数的方式告知父组件修改数据。</li></ul><p><strong>2. 兄弟组件通信</strong></p><blockquote><p>对于这种情况可以通过共同的父组件来管理状态和事件函数。比如说其中一个兄弟组件调用父组件传递过来的事件函数修改父组件中的状态，然后父组件将状态传递给另一个兄弟组件</p></blockquote><p><strong>3. 跨多层次组件通信</strong></p><blockquote><p>如果你使用 <code>16.3</code> 以上版本的话，对于这种情况可以使用 <code>Context API</code></p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建 Context，可以在开始就传入值</span></span><br><span class="line"><span class="keyword">const</span> StateContext = React.createContext()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="comment">// value 就是传入 Context 中的值</span></span><br><span class="line">      &lt;StateContext.Provider value=<span class="string">'yck'</span>&gt;</span><br><span class="line">        &lt;Child /&gt;</span><br><span class="line">      &lt;<span class="regexp">/StateContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">class Child extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">  render () &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;ThemeContext.Consumer&gt;</span></span><br><span class="line"><span class="regexp">        /</span><span class="regexp">/ 取出值</span></span><br><span class="line"><span class="regexp">        &#123;context =&gt; (</span></span><br><span class="line"><span class="regexp">          name is &#123; context &#125;</span></span><br><span class="line"><span class="regexp">        )&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>ThemeContext.Consumer&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4. 任意组件</strong></p><blockquote><p>这种方式可以通过 <code>Redux</code> 或者 <code>Event Bus</code> 解决，另外如果你不怕麻烦的话，可以使用这种方式解决上述所有的通信情况</p></blockquote><h3 id="29-5-HOC-是什么？相比-mixins-有什么优点？"><a href="#29-5-HOC-是什么？相比-mixins-有什么优点？" class="headerlink" title="29.5 HOC 是什么？相比 mixins 有什么优点？"></a>29.5 HOC 是什么？相比 mixins 有什么优点？</h3><blockquote><p>很多人看到高阶组件（<code>HOC</code>）这个概念就被吓到了，认为这东西很难，其实这东西概念真的很简单，我们先来看一个例子。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>现在如果我想给这个 <code>add</code> 函数添加一个输出结果的功能，那么你可能会考虑我直接使用 <code>console.log</code> 不就实现了么。说的没错，但是如果我们想做的更加优雅并且容易复用和扩展，我们可以这样去做</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withLog</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">wrapper</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> result = fn(a, b)</span><br><span class="line">        <span class="built_in">console</span>.log(result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> withLogAdd = withLog(add)</span><br><span class="line">withLogAdd(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><ul><li>其实这个做法在函数式编程里称之为高阶函数，大家都知道 <code>React</code> 的思想中是存在函数式编程的，高阶组件和高阶函数就是同一个东西。我们实现一个函数，传入一个组件，然后在函数内部再实现一个函数去扩展传入的组件，最后返回一个新的组件，这就是高阶组件的概念，作用就是为了更好的复用代码。</li><li>其实 <code>HOC</code> 和 <code>Vue</code> 中的 <code>mixins</code> 作用是一致的，并且在早期 <code>React</code> 也是使用 <code>mixins</code> 的方式。但是在使用 <code>class</code> 的方式创建组件以后，<code>mixins</code> 的方式就不能使用了，并且其实 <code>mixins</code> 也是存在一些问题的，比如</li></ul><ol><li>隐含了一些依赖，比如我在组件中写了某个 <code>state</code> 并且在 <code>mixin</code> 中使用了，就这存在了一个依赖关系。万一下次别人要移除它，就得去 <code>mixin</code> 中查找依赖</li><li>多个 <code>mixin</code> 中可能存在相同命名的函数，同时代码组件中也不能出现相同命名的函数，否则就是重写了，其实我一直觉得命名真的是一件麻烦事。。</li><li>雪球效应，虽然我一个组件还是使用着同一个 <code>mixin</code>，但是一个 <code>mixin</code> 会被多个组件使用，可能会存在需求使得 <code>mixin</code> 修改原本的函数或者新增更多的函数，这样可能就会产生一个维护成本</li></ol><blockquote><p><code>HOC</code> 解决了这些问题，并且它们达成的效果也是一致的，同时也更加的政治正确（毕竟更加函数式了）</p></blockquote><h3 id="29-6-事件机制"><a href="#29-6-事件机制" class="headerlink" title="29.6 事件机制"></a>29.6 事件机制</h3><blockquote><p><code>React</code> 其实自己实现了一套事件机制，首先我们考虑一下以下代码：</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Test = <span class="function">(<span class="params">&#123; list, handleClick &#125;</span>) =&gt;</span> (&#123;</span><br><span class="line">    list.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> (</span><br><span class="line">        &lt;span onClick=&#123;handleClick&#125; key=&#123;index&#125;&gt;&#123;index&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">    ))</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br></pre></td></tr></table></figure><ul><li>以上类似代码想必大家经常会写到，但是你是否考虑过点击事件是否绑定在了每一个标签上？事实当然不是，<code>JSX</code> 上写的事件并没有绑定在对应的真实 <code>DOM</code> 上，而是通过事件代理的方式，将所有的事件都统一绑定在了 <code>document</code> 上。这样的方式不仅减少了内存消耗，还能在组件挂载销毁时统一订阅和移除事件。</li><li>另外冒泡到 <code>document</code> 上的事件也不是原生浏览器事件，而是 <code>React</code> 自己实现的合成事件（<code>SyntheticEvent</code>）。因此我们如果不想要事件冒泡的话，调用 <code>event.stopPropagation</code> 是无效的，而应该调用 <code>event.preventDefault</code></li></ul><blockquote><p>那么实现合成事件的目的是什么呢？总的来说在我看来好处有两点，分别是：</p></blockquote><ol><li>合成事件首先抹平了浏览器之间的兼容问题，另外这是一个跨浏览器原生事件包装器，赋予了跨浏览器开发的能力</li><li>对于原生浏览器事件来说，浏览器会给监听器创建一个事件对象。如果你有很多的事件监听，那么就需要分配很多的事件对象，造成高额的内存分配问题。但是对于合成事件来说，有一个事件池专门来管理它们的创建和销毁，当事件需要被使用时，就会从池子中复用对象，事件回调结束后，就会销毁事件对象上的属性，从而便于下次复用事件对象。</li></ol><h2 id="30-监控"><a href="#30-监控" class="headerlink" title="30 监控"></a>30 监控</h2><blockquote><p>前端监控一般分为三种，分别为页面埋点、性能监控以及异常监控。</p></blockquote><p>这一章节我们将来学习这些监控相关的内容，但是基本不会涉及到代码，只是让大家了解下前端监控该用什么方式实现。毕竟大部分公司都只是使用到了第三方的监控工具，而不是选择自己造轮子</p><h3 id="30-1-页面埋点"><a href="#30-1-页面埋点" class="headerlink" title="30.1 页面埋点"></a>30.1 页面埋点</h3><blockquote><p>页面埋点应该是大家最常写的监控了，一般起码会监控以下几个数据：</p></blockquote><ul><li><code>PV</code> / <code>UV</code></li><li>停留时长</li><li>流量来源</li><li>用户交互</li></ul><blockquote><p>对于这几类统计，一般的实现思路大致可以分为两种，分别为手写埋点和无埋点的方式。</p></blockquote><p>相信第一种方式也是大家最常用的方式，可以自主选择需要监控的数据然后在相应的地方写入代码。这种方式的灵活性很大，但是唯一的缺点就是工作量较大，每个需要监控的地方都得插入代码。</p><p>另一种无埋点的方式基本不需要开发者手写埋点了，而是统计所有的事件并且定时上报。这种方式虽然没有前一种方式繁琐了，但是因为统计的是所有事件，所以还需要后期过滤出需要的数据。</p><h3 id="30-2-性能监控"><a href="#30-2-性能监控" class="headerlink" title="30.2 性能监控"></a>30.2 性能监控</h3><ul><li>性能监控可以很好的帮助开发者了解在各种真实环境下，页面的性能情况是如何的。</li><li>对于性能监控来说，我们可以直接使用浏览器自带的 <code>Performance API</code> 来实现这个功能。</li><li>对于性能监控来说，其实我们只需要调用 <code>performance.getEntriesByType(&#39;navigation&#39;)</code> 这行代码就行了。对，你没看错，一行代码我们就可以获得页面中各种详细的性能相关信息</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/2/7/168c82d1976cc115" alt=""></p><blockquote><p>我们可以发现这行代码返回了一个数组，内部包含了相当多的信息，从数据开始在网络中传输到页面加载完成都提供了相应的数据</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2019/2/7/168c82e5cc721387" alt=""></p><h3 id="30-3-异常监控"><a href="#30-3-异常监控" class="headerlink" title="30.3 异常监控"></a>30.3 异常监控</h3><ul><li>对于异常监控来说，以下两种监控是必不可少的，分别是代码报错以及接口异常上报。</li><li>对于代码运行错误，通常的办法是使用 <code>window.onerror</code> 拦截报错。该方法能拦截到大部分的详细报错信息，但是也有例外</li></ul><ol><li>对于跨域的代码运行错误会显示 <code>Script error</code>. 对于这种情况我们需要给 <code>script</code>标签添加 <code>crossorigin</code> 属性</li><li>对于某些浏览器可能不会显示调用栈信息，这种情况可以通过 <code>arguments.callee.caller</code> 来做栈递归</li></ol><ul><li>对于异步代码来说，可以使用 <code>catch</code> 的方式捕获错误。比如 <code>Promise</code> 可以直接使用 <code>catch</code> 函数，<code>async await</code> 可以使用 <code>try catch</code></li><li>但是要注意线上运行的代码都是压缩过的，需要在打包时生成 <code>sourceMap</code> 文件便于 <code>debug</code></li><li>对于捕获的错误需要上传给服务器，通常可以通过 <code>img</code> 标签的 <code>src</code> 发起一个请求。</li><li>另外接口异常就相对来说简单了，可以列举出出错的状态码。一旦出现此类的状态码就可以立即上报出错。接口异常上报可以让开发人员迅速知道有哪些接口出现了大面积的报错，以便迅速修复问题。</li></ul><h2 id="31-TCP-UDP"><a href="#31-TCP-UDP" class="headerlink" title="31 TCP/UDP"></a>31 TCP/UDP</h2><h3 id="31-1-UDP"><a href="#31-1-UDP" class="headerlink" title="31.1 UDP"></a>31.1 UDP</h3><blockquote><p>网络协议是每个前端工程师都必须要掌握的知识，我们将先来学习传输层中的两个协议：<code>UDP</code> 以及<code>TCP</code>。对于大部分工程师来说最常用的协议也就是这两个了，并且面试中经常会提问的也是关于这两个协议的区别</p></blockquote><blockquote><p>常考面试题：<code>UDP</code> 与 <code>TCP</code> 的区别是什么？</p></blockquote><p>首先 <code>UDP</code> 协议是面向无连接的，也就是说不需要在正式传递数据之前先连接起双方。然后 <code>UDP</code>协议只是数据报文的搬运工，不保证有序且不丢失的传递到对端，并且<code>UDP</code> 协议也没有任何控制流量的算法，总的来说 <code>UDP</code> 相较于 <code>TCP</code> 更加的轻便</p><p><strong>1. 面向无连接</strong></p><ul><li>首先<code>UDP</code> 是不需要和 <code>TCP</code> 一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。</li><li>并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。</li></ul><blockquote><p>具体来说就是：</p></blockquote><ul><li>在发送端，应用层将数据传递给传输层的 <code>UDP</code> 协议，<code>UDP</code> 只会给数据增加一个 <code>UDP</code> 头标识下是 <code>UDP</code> 协议，然后就传递给网络层了<br>在接收端，网络层将数据传递给传输层，<code>UDP</code> 只去除 <code>IP</code> 报文头就传递给应用层，不会任何拼接操作</li></ul><p><strong>2. 不可靠性</strong></p><ul><li>首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。</li><li>并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。</li><li>再者网络环境时好时坏，但是 <code>UDP</code> 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 <code>UDP</code> 而不是 <code>TCP</code></li></ul><p><strong>3. 高效</strong></p><ul><li>虽然 <code>UDP</code> 协议不是那么的可靠，但是正是因为它不是那么的可靠，所以也就没有 <code>TCP</code> 那么复杂了，需要保证数据不丢失且有序到达。</li><li>因此 <code>UDP</code> 的头部开销小，只有八字节，相比 <code>TCP</code> 的至少二十字节要少得多，在传输数据报文时是很高效的。</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/5/1/163195b245ceb89c" alt=""></p><blockquote><p><code>UDP</code> 头部包含了以下几个数据</p></blockquote><ul><li>两个十六位的端口号，分别为源端口（可选字段）和目标端口<br>整个数据报文的长度</li><li>整个数据报文的检验和（<code>IPv4</code> 可选 字段），该字段用于发现头部信息和数据中的错误</li></ul><p><strong>4. 传输方式</strong></p><blockquote><p><code>UDP</code> 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 <code>UDP</code> 提供了单播，多播，广播的功能。</p></blockquote><p><strong>5. 适合使用的场景</strong></p><blockquote><p><code>UDP</code>虽然对比 <code>TCP</code> 有很多缺点，但是正是因为这些缺点造就了它高效的特性，在很多实时性要求高的地方都可以看到 <code>UDP</code> 的身影。</p></blockquote><p><strong>5.1 直播</strong></p><ul><li>想必大家都看过直播吧，大家可以考虑下如果直播使用了基于 TCP 的协议会发生什么事情？</li></ul><blockquote><ul><li><code>TCP</code> 会严格控制传输的正确性，一旦有某一个数据对端没有收到，就会停止下来直到对端收到这个数据。这种问题在网络条件不错的情况下可能并不会发生什么事情，但是在网络情况差的时候就会变成画面卡住，然后再继续播放下一帧的情况。</li><li>但是对于直播来说，用户肯定关注的是最新的画面，而不是因为网络条件差而丢失的老旧画面，所以 <code>TCP</code> 在这种情况下无用武之地，只会降低用户体验。</li></ul></blockquote><p><strong>5.2 王者荣耀</strong></p><ul><li>首先对于王者荣耀来说，用户体量是相当大的，如果使用 <code>TCP</code> 连接的话，就可能会出现服务器不够用的情况，因为每台服务器可供支撑的 <code>TCP</code> 连接数量是有限制的。</li><li>再者，因为 <code>TCP</code> 会严格控制传输的正确性，如果因为用户网络条件不好就造成页面卡顿然后再传输旧的游戏画面是肯定不能接受的，毕竟对于这类实时性要求很高的游戏来说，最新的游戏画面才是最需要的，而不是老旧的画面，否则角色都不知道死多少次了。</li></ul><h3 id="31-2-TCP"><a href="#31-2-TCP" class="headerlink" title="31.2 TCP"></a>31.2 TCP</h3><blockquote><p>常考面试题：<code>UDP</code> 与 <code>TCP</code> 的区别是什么？</p></blockquote><blockquote><p><code>TCP</code> 基本是和 <code>UDP</code> 反着来，建立连接断开连接都需要先需要进行握手。在传输数据的过程中，通过各种算法保证数据的可靠性，当然带来的问题就是相比 <code>UDP</code> 来说不那么的高效</p></blockquote><p><strong>1. 头部</strong></p><blockquote><p>从这个图上我们就可以发现 <code>TCP</code> 头部比 <code>UDP</code> 头部复杂的多</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/5/1/1631be45b084e4bc" alt=""></p><blockquote><p>对于 <code>TCP</code> 头部来说，以下几个字段是很重要的</p></blockquote><ul><li><code>Sequence number</code>，这个序号保证了 TCP 传输的报文都是有序的，对端可以通过序号顺序的拼接报文</li><li><code>Acknowledgement Number</code>，这个序号表示数据接收端期望接收的下一个字节的编号是多少，同时也表示上一个序号的数据已经收到</li><li><code>Window Size</code>，窗口大小，表示还能接收多少字节的数据，用于流量控制</li><li><strong>标识符</strong><ul><li><code>URG=1</code>：该字段为一表示本数据报的数据部分包含紧急信息，是一个高优先级数据报文，此时紧急指针有效。紧急数据一定位于当前数据包数据部分的最前面，紧急指针标明了紧急数据的尾部。</li><li><code>ACK=1</code>：该字段为一表示确认号字段有效。此外，<code>TCP</code> 还规定在连接建立后传送的所有报文段都必须把 <code>ACK</code> 置为一。</li><li><code>PSH=1</code>：该字段为一表示接收端应该立即将数据 <code>push</code> 给应用层，而不是等到缓冲区满后再提交。</li><li><code>RST=1</code>：该字段为一表示当前 <code>TCP</code> 连接出现严重问题，可能需要重新建立 TCP 连接，也可以用于拒绝非法的报文段和拒绝连接请求。</li><li><code>SYN=1</code>：当<code>SYN=1</code>，<code>ACK=0</code>时，表示当前报文段是一个连接请求报文。当  <code>SYN=1</code>，<code>ACK=1</code>时，表示当前报文段是一个同意建立连接的应答报文。</li><li><code>FIN=1</code>：该字段为一表示此报文段是一个释放连接的请求报文。</li></ul></li></ul><p><strong>2. 状态机</strong></p><blockquote><p><code>TCP</code> 的状态机是很复杂的，并且与建立断开连接时的握手息息相关，接下来就来详细描述下两种握手</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/5/1/1631bef9e3c60035" alt=""></p><blockquote><p>在这之前需要了解一个重要的性能指标 <code>RTT</code>。该指标表示发送端发送数据到接收到对端数据所需的往返时间</p></blockquote><p><strong>2.1. 建立连接三次握手</strong></p><p><img src="https://user-gold-cdn.xitu.io/2018/5/1/1631bf1e79b3cd42" alt=""></p><ul><li>首先假设主动发起请求的一端称为客户端，被动连接的一端称为服务端。不管是客户端还是服务端，<code>TCP</code> 连接建立完后都能发送和接收数据，所以 <code>TCP</code> 是一个全双工的协议。</li><li>起初，两端都为 <code>CLOSED</code> 状态。在通信开始前，双方都会创建 <code>TCB</code>。 服务器创建完 <code>TCB</code> 后便进入 <code>LISTEN</code> 状态，此时开始等待客户端发送数据</li></ul><p><strong>第一次握手</strong></p><blockquote><p>客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 <code>SYN-SENT</code> 状态</p></blockquote><p><strong>第二次握手</strong></p><blockquote><p>服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 <code>SYN-RECEIVED</code> 状态</p></blockquote><p><strong>第三次握手</strong></p><ul><li>当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 <code>ESTABLISHED</code> 状态，服务端收到这个应答后也进入 <code>ESTABLISHED</code> 状态，此时连接建立成功。</li><li>PS：第三次握手中可以包含数据，通过快速打开（<code>TFO</code>）技术就可以实现这一功能。其实只要涉及到握手的协议，都可以使用类似 <code>TFO</code> 的方式，客户端和服务端存储相同的 <code>cookie</code>，下次握手时发出 <code>cookie</code> 达到减少 <code>RTT</code> 的目的。</li></ul><blockquote><p>常考面试题：为什么 <code>TCP</code> 建立连接需要三次握手，明明两次就可以建立起连接</p></blockquote><ul><li>因为这是为了防止出现失效的连接请求报文段被服务端接收的情况，从而产生错误。</li><li>可以想象如下场景。客户端发送了一个连接请求 <code>A</code>，但是因为网络原因造成了超时，这时 <code>TCP</code> 会启动超时重传的机制再次发送一个连接请求 <code>B</code>。此时请求顺利到达服务端，服务端应答完就建立了请求，然后接收数据后释放了连接。</li></ul><blockquote><p>假设这时候连接请求 <code>A</code> 在两端关闭后终于抵达了服务端，那么此时服务端会认为客户端又需要建立 <code>TCP</code> 连接，从而应答了该请求并进入 <code>ESTABLISHED</code> 状态。但是客户端其实是 <code>CLOSED</code> 的状态，那么就会导致服务端一直等待，造成资源的浪费。</p></blockquote><blockquote><p>PS：在建立连接中，任意一端掉线，<code>TCP</code> 都会重发 <code>SYN</code> 包，一般会重试五次，在建立连接中可能会遇到 <code>SYN Flood</code> 攻击。遇到这种情况你可以选择调低重试次数或者干脆在不能处理的情况下拒绝请求</p></blockquote><p><strong>2.2. 断开链接四次握手</strong></p><p><img src="https://user-gold-cdn.xitu.io/2018/5/2/1631fb807f2c6c1b" alt=""></p><blockquote><p><code>TCP</code> 是全双工的，在断开连接时两端都需要发送 <code>FIN</code> 和 <code>ACK</code></p></blockquote><p><strong>第一次握手</strong></p><blockquote><p>若客户端 <code>A</code> 认为数据发送完成，则它需要向服务端 <code>B</code> 发送连接释放请求。</p></blockquote><p><strong>第二次握手</strong></p><blockquote><p><code>B</code> 收到连接释放请求后，会告诉应用层要释放 <code>TCP</code> 链接。然后会发送 <code>ACK</code> 包，并进入 <code>CLOSE_WAIT</code>状态，此时表明 <code>A</code> 到 <code>B</code> 的连接已经释放，不再接收 <code>A</code> 发的数据了。但是因为 <code>TCP</code> 连接是双向的，所以 <code>B</code> 仍旧可以发送数据给 <code>A</code></p></blockquote><p><strong>3. ARQ 协议</strong></p><blockquote><p><code>ARQ</code> 协议也就是超时重传机制。通过确认和超时机制保证了数据的正确送达，<code>ARQ</code> 协议包含停止等待 <code>ARQ</code> 和连续 <code>ARQ</code> 两种协议。</p></blockquote><p><strong>停止等待 ARQ</strong></p><p><strong>正常传输过程</strong></p><blockquote><p>只要 A 向 B 发送一段报文，都要停止发送并启动一个定时器，等待对端回应，在定时器时间内接收到对端应答就取消定时器并发送下一段报文。</p></blockquote><p><strong>报文丢失或出错</strong></p><ul><li>在报文传输的过程中可能会出现丢包。这时候超过定时器设定的时间就会再次发送丢失的数据直到对端响应，所以需要每次都备份发送的数据。</li><li>即使报文正常的传输到对端，也可能出现在传输过程中报文出错的问题。这时候对端会抛弃该报文并等待 <code>A</code> 端重传。</li><li>PS：一般定时器设定的时间都会大于一个 <code>RTT</code> 的平均时间。</li></ul><p><strong>第三次握手</strong></p><ul><li><code>B</code> 如果此时还有没发完的数据会继续发送，完毕后会向 <code>A</code> 发送连接释放请求，然后 <code>B</code> 便进入 <code>LAST-ACK</code> 状态。</li><li>PS：通过延迟确认的技术（通常有时间限制，否则对方会误认为需要重传），可以将第二次和第三次握手合并，延迟 <code>ACK</code> 包的发送。</li></ul><p><strong>第四次握手</strong></p><blockquote><p>A 收到释放请求后，向 B 发送确认应答，此时 A 进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有 B 的重发请求的话，就进入 CLOSED 状态。当 B 收到确认应答后，也便进入 CLOSED 状态。</p></blockquote><ul><li>为什么 A 要进入 TIME-WAIT 状态，等待 2MSL 时间后才进入 CLOSED 状态？</li><li>为了保证 B 能收到 A 的确认应答。若 A 发完确认应答后直接进入 CLOSED 状态，如果确认应答因为网络问题一直没有到达，那么会造成 B 不能正常关闭。</li></ul><p><strong>ACK 超时或丢失</strong></p><ul><li>对端传输的应答也可能出现丢失或超时的情况。那么超过定时器时间 A 端照样会重传报文。这时候 B 端收到相同序号的报文会丢弃该报文并重传应答，直到 A 端发送下一个序号的报文。</li><li>在超时的情况下也可能出现应答很迟到达，这时 A 端会判断该序号是否已经接收过，如果接收过只需要丢弃应答即可。</li><li>从上面的描述中大家肯定可以发现这肯定不是一个高效的方式。假设在良好的网络环境中，每次发送数据都需要等待片刻肯定是不能接受的。那么既然我们不能接受这个不那么高效的协议，就来继续学习相对高效的协议吧。</li></ul><p><strong>连续 ARQ</strong></p><blockquote><p>在连续 ARQ 中，发送端拥有一个发送窗口，可以在没有收到应答的情况下持续发送窗口内的数据，这样相比停止等待 ARQ 协议来说减少了等待时间，提高了效率。</p></blockquote><p><strong>累计确认</strong></p><blockquote><p>连续 ARQ 中，接收端会持续不断收到报文。如果和停止等待 ARQ 中接收一个报文就发送一个应答一样，就太浪费资源了。通过累计确认，可以在收到多个报文以后统一回复一个应答报文。报文中的 ACK 标志位可以用来告诉发送端这个序号之前的数据已经全部接收到了，下次请发送这个序号后的数据。</p></blockquote><blockquote><p>但是累计确认也有一个弊端。在连续接收报文时，可能会遇到接收到序号 5 的报文后，并未接收到序号 6 的报文，然而序号 7 以后的报文已经接收。遇到这种情况时，ACK 只能回复 6，这样就会造成发送端重复发送数据的情况</p></blockquote><p><strong>4. 滑动窗口</strong></p><ul><li>上面小节中讲到了发送窗口。在 <code>TCP</code> 中，两端其实都维护着窗口：分别为发送端窗口和接收端窗口。</li><li>发送端窗口包含已发送但未收到应答的数据和可以发送但是未发送的数据。</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/5/5/1632f25c587ffd54" alt=""></p><ul><li>发送端窗口是由接收窗口剩余大小决定的。接收方会把当前接收窗口的剩余大小写入应答报文，发送端收到应答后根据该值和当前网络拥塞情况设置发送窗口的大小，所以发送窗口的大小是不断变化的。</li><li>当发送端接收到应答报文后，会随之将窗口进行滑动</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/5/5/1632f25cca99c8f4" alt=""></p><blockquote><p>滑动窗口是一个很重要的概念，它帮助 TCP 实现了流量控制的功能。接收方通过报文告知发送方还可以发送多少数据，从而保证接收方能够来得及接收数据，防止出现接收方带宽已满，但是发送方还一直发送数据的情况</p></blockquote><p><strong>Zero 窗口</strong></p><blockquote><p>在发送报文的过程中，可能会遇到对端出现零窗口的情况。在该情况下，发送端会停止发送数据，并启动 <code>persistent timer</code> 。该定时器会定时发送请求给对端，让对端告知窗口大小。在重试次数超过一定次数后，可能会中断 <code>TCP</code> 链接</p></blockquote><p><strong>5. 拥塞处理</strong></p><ul><li>拥塞处理和流量控制不同，后者是作用于接收方，保证接收方来得及接受数据。而前者是作用于网络，防止过多的数据拥塞网络，避免出现网络负载过大的情况。</li><li>拥塞处理包括了四个算法，分别为：慢开始，拥塞避免，快速重传，快速恢复</li></ul><p><strong>慢开始算法</strong></p><blockquote><p>慢开始算法，顾名思义，就是在传输开始时将发送窗口慢慢指数级扩大，从而避免一开始就传输大量数据导致网络拥塞。想必大家都下载过资源，每当我们开始下载的时候都会发现下载速度是慢慢提升的，而不是一蹴而就直接拉满带宽</p></blockquote><p><strong>慢开始算法步骤具体如下</strong></p><ul><li>连接初始设置拥塞窗口（Congestion Window） 为 <code>1 MSS</code>（一个分段的最大数据量）</li><li>每过一个 <code>RTT</code> 就将窗口大小乘二</li><li>指数级增长肯定不能没有限制的，所以有一个阈值限制，当窗口大小大于阈值时就会启动拥塞避免算法。</li></ul><p><strong>拥塞避免算法</strong></p><ul><li>拥塞避免算法相比简单点，每过一个 <code>RTT</code> 窗口大小只加一，这样能够避免指数级增长导致网络拥塞，慢慢将大小调整到最佳值。</li><li>在传输过程中可能定时器超时的情况，这时候 <code>TCP</code> 会认为网络拥塞了，会马上进行以下步骤：</li></ul><ol><li>将阈值设为当前拥塞窗口的一半</li><li>将拥塞窗口设为 <code>1 MSS</code></li><li>启动拥塞避免算法</li></ol><p><strong>快速重传</strong></p><blockquote><p>快速重传一般和快恢复一起出现。一旦接收端收到的报文出现失序的情况，接收端只会回复最后一个顺序正确的报文序号。如果发送端收到三个重复的 <code>ACK</code>，无需等待定时器超时而是直接启动快速重传算法。具体算法分为两种：</p></blockquote><p><strong>TCP Taho 实现如下</strong></p><ul><li>将阈值设为当前拥塞窗口的一半</li><li>将拥塞窗口设为 1 MSS</li><li>重新开始慢开始算法</li><li><code>TCP Reno</code> 实现如下</li></ul><p><strong>拥塞窗口减半</strong></p><ul><li>将阈值设为当前拥塞窗口</li><li>进入快恢复阶段（重发对端需要的包，一旦收到一个新的 ACK 答复就退出该阶段），这种方式在丢失多个包的情况下就不那么好了</li><li>使用拥塞避免算法</li></ul><p><strong>TCP New Ren 改进后的快恢复</strong></p><ul><li>TCP New Reno 算法改进了之前 TCP Reno 算法的缺陷。在之前，快恢复中只要收到一个新的 ACK 包，就会退出快恢复。</li><li>在 TCP New Reno 中，TCP 发送方先记下三个重复 ACK 的分段的最大序号。</li></ul><blockquote><p>假如我有一个分段数据是 <code>1 ~ 10</code> 这十个序号的报文，其中丢失了序号为 3 和 7 的报文，那么该分段的最大序号就是 10。发送端只会收到 ACK 序号为 3 的应答。这时候重发序号为 3 的报文，接收方顺利接收的话就会发送 ACK 序号为 7 的应答。这时候 TCP 知道对端是有多个包未收到，会继续发送序号为 7 的报文，接收方顺利接收并会发送 ACK 序号为 11 的应答，这时发送端认为这个分段接收端已经顺利接收，接下来会退出快恢复阶段。</p></blockquote><h2 id="32-HTTP-TLS"><a href="#32-HTTP-TLS" class="headerlink" title="32 HTTP/TLS"></a>32 HTTP/TLS</h2><h3 id="32-1-HTTP-请求中的内容"><a href="#32-1-HTTP-请求中的内容" class="headerlink" title="32.1 HTTP 请求中的内容"></a>32.1 HTTP 请求中的内容</h3><blockquote><p><code>HTTP</code> 请求由三部分构成，分别为：</p></blockquote><ul><li>请求行</li><li>首部</li><li>实体</li></ul><blockquote><ul><li>请求行大概长这样 <code>GET /images/logo.gif HTTP/1.1</code>，基本由请求方法、<code>URL</code>、协议版本组成，这其中值得一说的就是请求方法了。</li><li>请求方法分为很多种，最常用的也就是 <code>Get</code> 和 <code>Post</code> 了。虽然请求方法有很多，但是更多的是传达一个语义，而不是说 <code>Post</code> 能做的事情 <code>Get</code> 就不能做了。如果你愿意，都使用 <code>Get</code> 请求或者 <code>Post</code> 请求都是可以的</li></ul></blockquote><blockquote><p>常考面试题：Post 和 Get 的区别？</p></blockquote><ul><li>首先先引入副作用和幂等的概念。</li><li>副作用指对服务器上的资源做改变，搜索是无副作用的，注册是副作用的。</li><li>幂等指发送 M 和 N 次请求（两者不相同且都大于 1），服务器上资源的状态一致，比如注册 10 个和 11 个帐号是不幂等的，对文章进行更改 10 次和 11 次是幂等的。因为前者是多了一个账号（资源），后者只是更新同一个资源。</li><li>在规范的应用场景上说，Get 多用于无副作用，幂等的场景，例如搜索关键字。Post 多用于副作用，不幂等的场景，例如注册。</li></ul><blockquote><ul><li><code>Get</code> 请求能缓存，<code>Post</code> 不能</li><li><code>Post</code> 相对 <code>Get</code> 安全一点点，因为<code>Get</code> 请求都包含在 <code>URL</code> 里（当然你想写到 <code>body</code> 里也是可以的），且会被浏览器保存历史纪录。<code>Post</code> 不会，但是在抓包的情况下都是一样的。</li><li><code>URL</code>有长度限制，会影响 <code>Get</code> 请求，但是这个长度限制是浏览器规定的，不是 <code>RFC</code> 规定的</li><li><code>Post</code> 支持更多的编码类型且不对数据类型限制</li></ul></blockquote><p><strong>1. 首部</strong></p><blockquote><p>首部分为请求首部和响应首部，并且部分首部两种通用，接下来我们就来学习一部分的常用首部。</p></blockquote><p><strong>1.1 通用首部</strong></p><table><thead><tr><th>通用字段</th><th>作用</th></tr></thead><tbody><tr><td><code>Cache-Control</code></td><td>控制缓存的行为</td></tr><tr><td><code>Connection</code></td><td>浏览器想要优先使用的连接类型，比如 <code>keep-alive</code></td></tr><tr><td><code>Date</code></td><td>创建报文时间</td></tr><tr><td><code>Pragma</code></td><td>报文指令</td></tr><tr><td><code>Via</code></td><td>代理服务器相关信息</td></tr><tr><td><code>Transfer-Encoding</code></td><td>传输编码方式</td></tr><tr><td><code>Upgrade</code></td><td>要求客户端升级协议</td></tr><tr><td><code>Warning</code></td><td>在内容中可能存在错误</td></tr></tbody></table><p><strong>1.2 请求首部</strong></p><table><thead><tr><th>请求首部</th><th>作用</th></tr></thead><tbody><tr><td><code>Accept</code></td><td>能正确接收的媒体类型</td></tr><tr><td><code>Accept-Charset</code></td><td>能正确接收的字符集</td></tr><tr><td><code>Accept-Encoding</code></td><td>能正确接收的编码格式列表</td></tr><tr><td><code>Accept-Language</code></td><td>能正确接收的语言列表</td></tr><tr><td><code>Expect</code></td><td>期待服务端的指定行为</td></tr><tr><td><code>From</code></td><td>请求方邮箱地址</td></tr><tr><td><code>Host</code></td><td>服务器的域名</td></tr><tr><td><code>If-Match</code></td><td>两端资源标记比较</td></tr><tr><td><code>If-Modified-Since</code></td><td>本地资源未修改返回 <code>304</code>（比较时间）</td></tr><tr><td><code>If-None-Match</code></td><td>本地资源未修改返回 <code>304</code>（比较标记）</td></tr><tr><td><code>User-Agent</code></td><td>客户端信息</td></tr><tr><td><code>Max-Forwards</code></td><td>限制可被代理及网关转发的次数</td></tr><tr><td><code>Proxy-Authorization</code></td><td>向代理服务器发送验证信息</td></tr><tr><td><code>Range</code></td><td>请求某个内容的一部分</td></tr><tr><td><code>Referer</code></td><td>表示浏览器所访问的前一个页面</td></tr><tr><td><code>TE</code></td><td>传输编码方式</td></tr></tbody></table><p><strong>1.3 响应首部</strong></p><table><thead><tr><th>响应首部</th><th>作用</th></tr></thead><tbody><tr><td><code>Accept-Ranges</code></td><td>是否支持某些种类的范围</td></tr><tr><td><code>Age</code></td><td>资源在代理缓存中存在的时间</td></tr><tr><td><code>ETag</code></td><td>资源标识</td></tr><tr><td><code>Location</code></td><td>客户端重定向到某个 <code>URL</code></td></tr><tr><td><code>Proxy-Authenticate</code></td><td>向代理服务器发送验证信息</td></tr><tr><td><code>Server</code></td><td>服务器名字</td></tr><tr><td><code>WWW-Authenticate</code></td><td>获取资源需要的验证信息</td></tr></tbody></table><p><strong>1.4 实体首部</strong></p><table><thead><tr><th>实体首部</th><th>作用</th></tr></thead><tbody><tr><td><code>Allow</code></td><td>资源的正确请求方式</td></tr><tr><td><code>Content-Encoding</code></td><td>内容的编码格式</td></tr><tr><td><code>Content-Language</code></td><td>内容使用的语言</td></tr><tr><td><code>Content-Length</code></td><td><code>request body</code> 长度</td></tr><tr><td><code>Content-Location</code></td><td>返回数据的备用地址</td></tr><tr><td><code>Content-MD5</code></td><td><code>Base64</code>加密格式的内容 <code>MD5</code>检验值</td></tr><tr><td><code>Content-Range</code></td><td>内容的位置范围</td></tr><tr><td><code>Content-Type</code></td><td>内容的媒体类型</td></tr><tr><td><code>Expires</code></td><td>内容的过期时间</td></tr><tr><td><code>Last_modified</code></td><td>内容的最后修改时间</td></tr></tbody></table><p><strong>2. 常见状态码</strong></p><blockquote><p>状态码表示了响应的一个状态，可以让我们清晰的了解到这一次请求是成功还是失败，如果失败的话，是什么原因导致的，当然状态码也是用于传达语义的。如果胡乱使用状态码，那么它存在的意义就没有了</p></blockquote><p><strong>2XX 成功</strong></p><ul><li><code>200 OK</code>，表示从客户端发来的请求在服务器端被正确处理</li><li><code>204 No content</code>，表示请求成功，但响应报文不含实体的主体部分</li><li><code>205 Reset Content</code>，表示请求成功，但响应报文不含实体的主体部分，但是与 <code>204</code> 响应不同在于要求请求方重置内容</li><li><code>206 Partial Content</code>，进行范围请求</li></ul><p><strong>3XX 重定向</strong></p><ul><li><code>301 moved permanently</code>，永久性重定向，表示资源已被分配了新的 URL</li><li><code>302 found</code>，临时性重定向，表示资源临时被分配了新的 <code>URL</code></li><li><code>303 see other</code>，表示资源存在着另一个 <code>URL</code>，应使用 <code>GET</code> 方法获取资源</li><li><code>304 not modified</code>，表示服务器允许访问资源，但因发生请求未满足条件的情况</li><li><code>307 temporary redirect</code>，临时重定向，和<code>302</code>含义类似，但是期望客户端保持请求方法不变向新的地址发出请求</li></ul><p><strong>4XX 客户端错误</strong></p><ul><li><code>400 bad request</code>，请求报文存在语法错误</li><li><code>401 unauthorized</code>，表示发送的请求需要有通过 HTTP 认证的认证信息</li><li><code>403 forbidden</code>，表示对请求资源的访问被服务器拒绝</li><li><code>404 not found</code>，表示在服务器上没有找到请求的资源</li></ul><p><strong>5XX 服务器错误</strong></p><ul><li><code>500 internal sever error</code>，表示服务器端在执行请求时发生了错误</li><li><code>501 Not Implemented</code>，表示服务器不支持当前请求所需要的某个功能</li><li><code>503 service unavailable</code>，表明服务器暂时处于超负载或正在停机维护，无法处理请求</li></ul><h3 id="32-2-TLS"><a href="#32-2-TLS" class="headerlink" title="32.2 TLS"></a>32.2 TLS</h3><ul><li><code>HTTPS</code> 还是通过了 <code>HTTP</code> 来传输信息，但是信息通过 <code>TLS</code> 协议进行了加密。</li><li><code>TLS</code> 协议位于传输层之上，应用层之下。首次进行 <code>TLS</code> 协议传输需要两个 <code>RTT</code> ，接下来可以通过 <code>Session Resumption</code> 减少到一个 <code>RTT</code>。</li><li>在 <code>TLS</code> 中使用了两种加密技术，分别为：对称加密和非对称加密。</li></ul><p><strong>对称加密</strong></p><ul><li>对称加密就是两边拥有相同的秘钥，两边都知道如何将密文加密解密。</li><li>这种加密方式固然很好，但是问题就在于如何让双方知道秘钥。因为传输数据都是走的网络，如果将秘钥通过网络的方式传递的话，一旦秘钥被截获就没有加密的意义的。</li></ul><p><strong>非对称加密</strong></p><ul><li>有公钥私钥之分，公钥所有人都可以知道，可以将数据用公钥加密，但是将数据解密必须使用私钥解密，私钥只有分发公钥的一方才知道。</li><li>这种加密方式就可以完美解决对称加密存在的问题。假设现在两端需要使用对称加密，那么在这之前，可以先使用非对称加密交换秘钥。</li></ul><blockquote><p>简单流程如下：首先服务端将公钥公布出去，那么客户端也就知道公钥了。接下来客户端创建一个秘钥，然后通过公钥加密并发送给服务端，服务端接收到密文以后通过私钥解密出正确的秘钥，这时候两端就都知道秘钥是什么了。</p></blockquote><p>TLS 握手过程如下图：</p><p><img src="https://user-gold-cdn.xitu.io/2018/5/12/1635260126b3a10c" alt=""></p><ul><li>客户端发送一个随机值以及需要的协议和加密方式。</li><li>服务端收到客户端的随机值，自己也产生一个随机值，并根据客户端需求的协议和加密方式来使用对应的方式，并且发送自己的证书（如果需要验证客户端证书需要说明）</li><li>客户端收到服务端的证书并验证是否有效，验证通过会再生成一个随机值，通过服务端证书的公钥去加密这个随机值并发送给服务端，如果服务端需要验证客户端证书的话会附带证书</li><li>服务端收到加密过的随机值并使用私钥解密获得第三个随机值，这时候两端都拥有了三个随机值，可以通过这三个随机值按照之前约定的加密方式生成密钥，接下来的通信就可以通过该密钥来加密解密</li><li>通过以上步骤可知，在 TLS 握手阶段，两端使用非对称加密的方式来通信，但是因为非对称加密损耗的性能比对称加密大，所以在正式传输数据时，两端使用对称加密的方式通信。</li></ul><blockquote><p>PS：以上说明的都是 <code>TLS 1.2</code> 协议的握手情况，在 1.3 协议中，首次建立连接只需要一个 RTT，后面恢复连接不需要 RTT 了</p></blockquote><h2 id="33-HTTP2-0"><a href="#33-HTTP2-0" class="headerlink" title="33 HTTP2.0"></a>33 HTTP2.0</h2><blockquote><ul><li><code>HTTP/2</code> 很好的解决了当下最常用的 <code>HTTP/1</code> 所存在的一些性能问题，只需要升级到该协议就可以减少很多之前需要做的性能优化工作，当然兼容问题以及如何优雅降级应该是国内还不普遍使用的原因之一。</li><li>虽然 <code>HTTP/2</code> 已经解决了很多问题，但是并不代表它已经是完美的了，<code>HTTP/3</code> 就是为了解决 <code>HTTP/2</code> 所存在的一些问题而被推出来的。</li></ul></blockquote><h3 id="33-1-HTTP-2"><a href="#33-1-HTTP-2" class="headerlink" title="33.1 HTTP/2"></a>33.1 HTTP/2</h3><ul><li><code>HTTP/2</code> 相比于 <code>HTTP/1</code>，可以说是大幅度提高了网页的性能。</li><li>在 <code>HTTP/1</code> 中，为了性能考虑，我们会引入雪碧图、将小图内联、使用多个域名等等的方式。这一切都是因为浏览器限制了同一个域名下的请求数量（Chrome 下一般是限制六个连接），当页面中需要请求很多资源的时候，队头阻塞（Head of line blocking）会导致在达到最大请求数量时，剩余的资源需要等待其他资源请求完成后才能发起请求。</li><li>在 <code>HTTP/2</code> 中引入了多路复用的技术，这个技术可以只通过一个 <code>TCP</code> 连接就可以传输所有的请求数据。多路复用很好的解决了浏览器限制同一个域名下的请求数量的问题，同时也接更容易实现全速传输，毕竟新开一个 <code>TCP</code> 连接都需要慢慢提升传输速度。</li></ul><blockquote><p>大家可以通过 <a href="https://http2.akamai.com/demo" target="_blank" rel="noopener">该链接</a> 感受下 HTTP/2 比 HTTP/1 到底快了多少</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/5/12/163542ca61eaff17" alt=""></p><blockquote><p>在 <code>HTTP/1</code> 中，因为队头阻塞的原因，你会发现发送请求是长这样的</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/5/12/163542c96df8563d" alt=""></p><blockquote><p>在 <code>HTTP/2</code> 中，因为可以复用同一个 <code>TCP</code> 连接，你会发现发送请求是长这样的</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/5/12/163542c9d3128c7a" alt=""></p><h3 id="33-2-二进制传输"><a href="#33-2-二进制传输" class="headerlink" title="33.2 二进制传输"></a>33.2 二进制传输</h3><blockquote><p><code>HTTP/2</code> 中所有加强性能的核心点在于此。在之前的 <code>HTTP</code> 版本中，我们是通过文本的方式传输数据。在 <code>HTTP/2</code> 中引入了新的编码机制，所有传输的数据都会被分割，并采用二进制格式编码。</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/5/12/163543c25e5e9f23" alt=""></p><h3 id="33-3-多路复用"><a href="#33-3-多路复用" class="headerlink" title="33.3 多路复用"></a>33.3 多路复用</h3><ul><li>在 <code>HTTP/2</code> 中，有两个非常重要的概念，分别是帧（frame）和流（stream）。</li><li>帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。</li><li>多路复用，就是在一个 <code>TCP</code> 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 <code>HTTP</code> 旧版本中的队头阻塞问题，极大的提高传输性能。</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/5/12/1635442531d3e5ee" alt=""></p><h3 id="33-4-Header-压缩"><a href="#33-4-Header-压缩" class="headerlink" title="33.4 Header 压缩"></a>33.4 Header 压缩</h3><ul><li>在 <code>HTTP/1</code> 中，我们使用文本的形式传输 <code>header</code>，在 <code>header</code> 携带 cookie 的情况下，可能每次都需要重复传输几百到几千的字节。</li><li>在 <code>HTTP / 2</code>中，使用了 <code>HPACK</code> 压缩格式对传输的 <code>header</code> 进行编码，减少了 <code>header</code> 的大小。并在两端维护了索引表，用于记录出现过的 <code>header</code> ，后面在传输过程中就可以传输已经记录过的 <code>header</code> 的键名，对端收到数据后就可以通过键名找到对应的值。</li></ul><h3 id="33-5-服务端-Push"><a href="#33-5-服务端-Push" class="headerlink" title="33.5 服务端 Push"></a>33.5 服务端 Push</h3><ul><li>在 <code>HTTP/2</code> 中，服务端可以在客户端某个请求后，主动推送其他资源。</li><li>可以想象以下情况，某些资源客户端是一定会请求的，这时就可以采取服务端 <code>push</code> 的技术，提前给客户端推送必要的资源，这样就可以相对减少一点延迟时间。当然在浏览器兼容的情况下你也可以使用 <code>prefetch</code></li></ul><h3 id="33-6-HTTP-3"><a href="#33-6-HTTP-3" class="headerlink" title="33.6  HTTP/3"></a>33.6  HTTP/3</h3><ul><li>虽然 <code>HTTP/2</code> 解决了很多之前旧版本的问题，但是它还是存在一个巨大的问题，虽然这个问题并不是它本身造成的，而是底层支撑的 <code>TCP</code> 协议的问题。</li><li>因为 <code>HTTP/2</code> 使用了多路复用，一般来说同一域名下只需要使用一个 <code>TCP</code> 连接。当这个连接中出现了丢包的情况，那就会导致 <code>HTTP/2</code> 的表现情况反倒不如 <code>HTTP/1</code> 了。</li><li>因为在出现丢包的情况下，整个 <code>TCP</code> 都要开始等待重传，也就导致了后面的所有数据都被阻塞了。但是对于 <code>HTTP/1</code> 来说，可以开启多个 <code>TCP</code> 连接，出现这种情况反到只会影响其中一个连接，剩余的 <code>TCP</code> 连接还可以正常传输数据。</li><li>那么可能就会有人考虑到去修改 TCP 协议，其实这已经是一件不可能完成的任务了。因为 TCP 存在的时间实在太长，已经充斥在各种设备中，并且这个协议是由操作系统实现的，更新起来不大现实。</li><li>基于这个原因，Google 就更起炉灶搞了一个基于 <code>UDP</code> 协议的 <code>QUIC</code> 协议，并且使用在了 <code>HTTP/3</code> 上，当然 <code>HTTP/3</code> 之前名为 <code>HTTP-over-QUIC</code>，从这个名字中我们也可以发现，HTTP/3 最大的改造就是使用了 <code>QUIC</code>，接下来我们就来学习关于这个协议的内容。</li></ul><p><strong>QUIC</strong></p><blockquote><p>之前我们学习过 UDP 协议的内容，知道这个协议虽然效率很高，但是并不是那么的可靠。QUIC 虽然基于 UDP，但是在原本的基础上新增了很多功能，比如多路复用、0-RTT、使用 TLS1.3 加密、流量控制、有序交付、重传等等功能。这里我们就挑选几个重要的功能学习下这个协议的内容。</p></blockquote><p><strong>多路复用</strong></p><blockquote><p>虽然 HTTP/2 支持了多路复用，但是 TCP 协议终究是没有这个功能的。QUIC 原生就实现了这个功能，并且传输的单个数据流可以保证有序交付且不会影响其他的数据流，这样的技术就解决了之前 TCP 存在的问题。</p></blockquote><ul><li>并且 <code>QUIC</code> 在移动端的表现也会比 <code>TCP</code> 好。因为 <code>TCP</code> 是基于 <code>IP</code> 和端口去识别连接的，这种方式在多变的移动端网络环境下是很脆弱的。但是 <code>QUIC</code> 是通过 <code>ID</code>** 的方式去识别一个连接，不管你网络环境如何变化，只要 <code>ID</code> 不变，就能迅速重连上。</li></ul><p><strong>0-RTT</strong></p><blockquote><p>通过使用类似 TCP 快速打开的技术，缓存当前会话的上下文，在下次恢复会话的时候，只需要将之前的缓存传递给服务端验证通过就可以进行传输了。</p></blockquote><p><strong>纠错机制</strong></p><ul><li>假如说这次我要发送三个包，那么协议会算出这三个包的异或值并单独发出一个校验包，也就是总共发出了四个包。</li><li>当出现其中的非校验包丢包的情况时，可以通过另外三个包计算出丢失的数据包的内容。</li><li>当然这种技术只能使用在丢失一个包的情况下，如果出现丢失多个包就不能使用纠错机制了，只能使用重传的方式了</li></ul><h2 id="34-设计模式"><a href="#34-设计模式" class="headerlink" title="34 设计模式"></a>34 设计模式</h2><blockquote><p>设计模式总的来说是一个抽象的概念，前人通过无数次的实践总结出的一套写代码的方式，通过这种方式写的代码可以让别人更加容易阅读、维护以及复用。</p></blockquote><h3 id="34-1-工厂模式"><a href="#34-1-工厂模式" class="headerlink" title="34.1 工厂模式"></a>34.1 工厂模式</h3><blockquote><p>工厂模式分为好几种，这里就不一一讲解了，以下是一个简单工厂模式的例子</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  alertName() &#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> create(name) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Man(name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Factory.create(<span class="string">'yck'</span>).alertName()</span><br></pre></td></tr></table></figure><ul><li>当然工厂模式并不仅仅是用来 <code>new</code> 出实例。</li><li>可以想象一个场景。假设有一份很复杂的代码需要用户去调用，但是用户并不关心这些复杂的代码，只需要你提供给我一个接口去调用，用户只负责传递需要的参数，至于这些参数怎么使用，内部有什么逻辑是不关心的，只需要你最后返回我一个实例。这个构造过程就是工厂。</li><li>工厂起到的作用就是隐藏了创建实例的复杂度，只需要提供一个接口，简单清晰。</li><li>在 <code>Vue</code> 源码中，你也可以看到工厂模式的使用，比如创建异步组件</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createComponent</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  Ctor: Class&lt;Component&gt; | Function | Object | void,</span></span></span><br><span class="line"><span class="function"><span class="params">  data: ?VNodeData,</span></span></span><br><span class="line"><span class="function"><span class="params">  context: Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  children: ?Array&lt;VNode&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  tag?: string</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">VNode</span> | <span class="title">Array</span>&lt;<span class="title">VNode</span>&gt; | <span class="title">void</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 逻辑处理...</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> vnode = <span class="keyword">new</span> VNode(</span><br><span class="line">    <span class="string">`vue-component-<span class="subst">$&#123;Ctor.cid&#125;</span><span class="subst">$&#123;name ? <span class="string">`-<span class="subst">$&#123;name&#125;</span>`</span> : <span class="string">''</span>&#125;</span>`</span>,</span><br><span class="line">    data, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, context,</span><br><span class="line">    &#123; Ctor, propsData, listeners, tag, children &#125;,</span><br><span class="line">    asyncFactory</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> vnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在上述代码中，我们可以看到我们只需要调用 <code>createComponent</code> 传入参数就能创建一个组件实例，但是创建这个实例是很复杂的一个过程，工厂帮助我们隐藏了这个复杂的过程，只需要一句代码调用就能实现功能</p></blockquote><h3 id="34-2-单例模式"><a href="#34-2-单例模式" class="headerlink" title="34.2 单例模式"></a>34.2 单例模式</h3><ul><li>单例模式很常用，比如全局缓存、全局状态管理等等这些只需要一个对象，就可以使用单例模式。</li><li>单例模式的核心就是保证全局只有一个对象可以访问。因为 <code>JS</code> 是门无类的语言，所以别的语言实现单例的方式并不能套入 <code>JS</code> 中，我们只需要用一个变量确保实例只创建一次就行，以下是如何实现单例模式的例子</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Singleton.getInstance = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> instance</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">      instance = <span class="keyword">new</span> Singleton()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s1 = Singleton.getInstance()</span><br><span class="line"><span class="keyword">let</span> s2 = Singleton.getInstance()</span><br><span class="line"><span class="built_in">console</span>.log(s1 === s2) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><blockquote><p>在 <code>Vuex</code> 源码中，你也可以看到单例模式的使用，虽然它的实现方式不大一样，通过一个外部变量来控制只安装一次 <code>Vuex</code></p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> Vue <span class="comment">// bind on install</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">install</span> (<span class="params">_Vue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (Vue &amp;&amp; _Vue === Vue) &#123;</span><br><span class="line">    <span class="comment">// 如果发现 Vue 有值，就不重新创建实例了</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  Vue = _Vue</span><br><span class="line">  applyMixin(Vue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="34-3-适配器模式"><a href="#34-3-适配器模式" class="headerlink" title="34.3 适配器模式"></a>34.3 适配器模式</h3><ul><li>适配器用来解决两个接口不兼容的情况，不需要改变已有的接口，通过包装一层的方式实现两个接口的正常协作。</li><li>以下是如何实现适配器模式的例子</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plug</span> </span>&#123;</span><br><span class="line">  getName() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'港版插头'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.plug = <span class="keyword">new</span> Plug()</span><br><span class="line">  &#125;</span><br><span class="line">  getName() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.plug.getName() + <span class="string">' 适配器转二脚插头'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> target = <span class="keyword">new</span> Target()</span><br><span class="line">target.getName() <span class="comment">// 港版插头 适配器转二脚插头</span></span><br></pre></td></tr></table></figure><blockquote><p>在 <code>Vue</code> 中，我们其实经常使用到适配器模式。比如父组件传递给子组件一个时间戳属性，组件内部需要将时间戳转为正常的日期显示，一般会使用 <code>computed</code> 来做转换这件事情，这个过程就使用到了适配器模式</p></blockquote><h3 id="34-4-装饰模式"><a href="#34-4-装饰模式" class="headerlink" title="34.4 装饰模式"></a>34.4 装饰模式</h3><ul><li>装饰模式不需要改变已有的接口，作用是给对象添加功能。就像我们经常需要给手机戴个保护套防摔一样，不改变手机自身，给手机添加了保护套提供防摔功能。</li><li>以下是如何实现装饰模式的例子，使用了 ES7 中的装饰器语法</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readonly</span>(<span class="params">target, key, descriptor</span>) </span>&#123;</span><br><span class="line">  descriptor.writable = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">return</span> descriptor</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  @readonly</span><br><span class="line">  name = <span class="string">'yck'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> t = <span class="keyword">new</span> Test()</span><br><span class="line"></span><br><span class="line">t.yck = <span class="string">'111'</span> <span class="comment">// 不可修改</span></span><br></pre></td></tr></table></figure><blockquote><p>在 <code>React</code> 中，装饰模式其实随处可见</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps)(MyComponent)</span><br></pre></td></tr></table></figure><h3 id="34-5-代理模式"><a href="#34-5-代理模式" class="headerlink" title="34.5 代理模式"></a>34.5 代理模式</h3><ul><li>代理是为了控制对对象的访问，不让外部直接访问到对象。在现实生活中，也有很多代理的场景。比如你需要买一件国外的产品，这时候你可以通过代购来购买产品。</li><li>在实际代码中其实代理的场景很多，也就不举框架中的例子了，比如事件代理就用到了代理模式</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"ul"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">'#ul'</span>)</span></span><br><span class="line"><span class="actionscript">    ul.addEventListener(<span class="string">'click'</span>, (event) =&gt; &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(event.target);</span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>因为存在太多的 li，不可能每个都去绑定事件。这时候可以通过给父节点绑定一个事件，让父节点作为代理去拿到真实点击的节点。</p></blockquote><h3 id="34-6-发布-订阅模式"><a href="#34-6-发布-订阅模式" class="headerlink" title="34.6 发布-订阅模式"></a>34.6 发布-订阅模式</h3><ul><li>发布-订阅模式也叫做观察者模式。通过一对一或者一对多的依赖关系，当对象发生改变时，订阅方都会收到通知。在现实生活中，也有很多类似场景，比如我需要在购物网站上购买一个产品，但是发现该产品目前处于缺货状态，这时候我可以点击有货通知的按钮，让网站在产品有货的时候通过短信通知我。</li><li>在实际代码中其实发布-订阅模式也很常见，比如我们点击一个按钮触发了点击事件就是使用了该模式</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"ul"</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">'#ul'</span>)</span></span><br><span class="line"><span class="actionscript">    ul.addEventListener(<span class="string">'click'</span>, (event) =&gt; &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(event.target);</span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>在 <code>Vue</code> 中，如何实现响应式也是使用了该模式。对于需要实现响应式的对象来说，在 <code>get</code> 的时候会进行依赖收集，当改变了对象的属性时，就会触发派发更新。</p></blockquote><h3 id="34-7-外观模式"><a href="#34-7-外观模式" class="headerlink" title="34.7 外观模式"></a>34.7 外观模式</h3><ul><li>外观模式提供了一个接口，隐藏了内部的逻辑，更加方便外部调用。</li><li>个例子来说，我们现在需要实现一个兼容多种浏览器的添加事件方法</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addEvent</span>(<span class="params">elm, evType, fn, useCapture</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (elm.addEventListener) &#123;</span><br><span class="line">    elm.addEventListener(evType, fn, useCapture)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (elm.attachEvent) &#123;</span><br><span class="line">    <span class="keyword">var</span> r = elm.attachEvent(<span class="string">"on"</span> + evType, fn)</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    elm[<span class="string">"on"</span> + evType] = fn</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对于不同的浏览器，添加事件的方式可能会存在兼容问题。如果每次都需要去这样写一遍的话肯定是不能接受的，所以我们将这些判断逻辑统一封装在一个接口中，外部需要添加事件只需要调用 <code>addEvent</code> 即可。</p></blockquote><h2 id="35-常见数据结构"><a href="#35-常见数据结构" class="headerlink" title="35 常见数据结构"></a>35 常见数据结构</h2><h3 id="35-1-时间复杂度"><a href="#35-1-时间复杂度" class="headerlink" title="35.1 时间复杂度"></a>35.1 时间复杂度</h3><p>在进入正题之前，我们先来了解下什么是时间复杂度。</p><ul><li>通常使用最差的时间复杂度来衡量一个算法的好坏。</li><li>常数时间 <code>O(1)</code> 代表这个操作和数据量没关系，是一个固定时间的操作，比如说四则运算。</li><li>对于一个算法来说，可能会计算出操作次数为 <code>aN + 1</code>，<code>N</code> 代表数据量。那么该算法的时间复杂度就是 <code>O(N)</code>。因为我们在计算时间复杂度的时候，数据量通常是非常大的，这时候低阶项和常数项可以忽略不计。</li><li>当然可能会出现两个算法都是 <code>O(N)</code> 的时间复杂度，那么对比两个算法的好坏就要通过对比低阶项和常数项了</li></ul><h3 id="35-2-栈"><a href="#35-2-栈" class="headerlink" title="35.2 栈"></a>35.2 栈</h3><p><strong>概念</strong></p><ul><li>栈是一个线性结构，在计算机中是一个相当常见的数据结构。</li><li>栈的特点是只能在某一端添加或删除数据，遵循先进后出的原则</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/5/20/1637b785d2d68735" alt=""></p><p><strong>实现</strong></p><blockquote><p>每种数据结构都可以用很多种方式来实现，其实可以把栈看成是数组的一个子集，所以这里使用数组来实现</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.stack = []</span><br><span class="line">  &#125;</span><br><span class="line">  push(item) &#123;</span><br><span class="line">    <span class="keyword">this</span>.stack.push(item)</span><br><span class="line">  &#125;</span><br><span class="line">  pop() &#123;</span><br><span class="line">    <span class="keyword">this</span>.stack.pop()</span><br><span class="line">  &#125;</span><br><span class="line">  peek() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.stack[<span class="keyword">this</span>.getCount() - <span class="number">1</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  getCount() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.stack.length</span><br><span class="line">  &#125;</span><br><span class="line">  isEmpty() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.getCount() === <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="35-3-应用"><a href="#35-3-应用" class="headerlink" title="35.3 应用"></a>35.3 应用</h3><blockquote><p>选取了 LeetCode 上序号为 <a href="https://leetcode.com/problems/valid-parentheses/submissions/1" target="_blank" rel="noopener">20 的题</a>题意是匹配括号，可以通过栈的特性来完成这道题目</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isValid = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> map = &#123;</span><br><span class="line">    <span class="string">'('</span>: <span class="number">-1</span>,</span><br><span class="line">    <span class="string">')'</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">'['</span>: <span class="number">-2</span>,</span><br><span class="line">    <span class="string">']'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'&#123;'</span>: <span class="number">-3</span>,</span><br><span class="line">    <span class="string">'&#125;'</span>: <span class="number">3</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> stack = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (map[s[i]] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      stack.push(s[i])</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> last = stack.pop()</span><br><span class="line">      <span class="keyword">if</span> (map[last] + map[s[i]] != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (stack.length &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>其实在 <code>Vue</code> 中关于模板解析的代码，就有应用到匹配尖括号的内容</p></blockquote><h3 id="35-4-队列"><a href="#35-4-队列" class="headerlink" title="35.4 队列"></a>35.4 队列</h3><p><strong>概念</strong></p><blockquote><p>队列是一个线性结构，特点是在某一端添加数据，在另一端删除数据，遵循先进先出的原则</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/5/20/1637cba2a6155793" alt=""></p><p><strong>实现</strong></p><blockquote><p>这里会讲解两种实现队列的方式，分别是单链队列和循环队列。</p></blockquote><p><strong>单链队列</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.queue = []</span><br><span class="line">  &#125;</span><br><span class="line">  enQueue(item) &#123;</span><br><span class="line">    <span class="keyword">this</span>.queue.push(item)</span><br><span class="line">  &#125;</span><br><span class="line">  deQueue() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.queue.shift()</span><br><span class="line">  &#125;</span><br><span class="line">  getHeader() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.queue[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  getLength() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.queue.length</span><br><span class="line">  &#125;</span><br><span class="line">  isEmpty() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.getLength() === <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>因为单链队列在出队操作的时候需要 <code>O(n)</code> 的时间复杂度，所以引入了循环队列。循环队列的出队操作平均是 <code>O(1)</code> 的时间复杂度。</p></blockquote><p><strong>循环队列</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SqQueue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">    <span class="keyword">this</span>.queue = <span class="keyword">new</span> <span class="built_in">Array</span>(length + <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 队头</span></span><br><span class="line">    <span class="keyword">this</span>.first = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 队尾</span></span><br><span class="line">    <span class="keyword">this</span>.last = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 当前队列大小</span></span><br><span class="line">    <span class="keyword">this</span>.size = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  enQueue(item) &#123;</span><br><span class="line">    <span class="comment">// 判断队尾 + 1 是否为队头</span></span><br><span class="line">    <span class="comment">// 如果是就代表需要扩容数组</span></span><br><span class="line">    <span class="comment">// % this.queue.length 是为了防止数组越界</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.first === (<span class="keyword">this</span>.last + <span class="number">1</span>) % <span class="keyword">this</span>.queue.length) &#123;</span><br><span class="line">      <span class="keyword">this</span>.resize(<span class="keyword">this</span>.getLength() * <span class="number">2</span> + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.queue[<span class="keyword">this</span>.last] = item</span><br><span class="line">    <span class="keyword">this</span>.size++</span><br><span class="line">    <span class="keyword">this</span>.last = (<span class="keyword">this</span>.last + <span class="number">1</span>) % <span class="keyword">this</span>.queue.length</span><br><span class="line">  &#125;</span><br><span class="line">  deQueue() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'Queue is empty'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> r = <span class="keyword">this</span>.queue[<span class="keyword">this</span>.first]</span><br><span class="line">    <span class="keyword">this</span>.queue[<span class="keyword">this</span>.first] = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">this</span>.first = (<span class="keyword">this</span>.first + <span class="number">1</span>) % <span class="keyword">this</span>.queue.length</span><br><span class="line">    <span class="keyword">this</span>.size--</span><br><span class="line">    <span class="comment">// 判断当前队列大小是否过小</span></span><br><span class="line">    <span class="comment">// 为了保证不浪费空间，在队列空间等于总长度四分之一时</span></span><br><span class="line">    <span class="comment">// 且不为 2 时缩小总长度为当前的一半</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.size === <span class="keyword">this</span>.getLength() / <span class="number">4</span> &amp;&amp; <span class="keyword">this</span>.getLength() / <span class="number">2</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.resize(<span class="keyword">this</span>.getLength() / <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r</span><br><span class="line">  &#125;</span><br><span class="line">  getHeader() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'Queue is empty'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.queue[<span class="keyword">this</span>.first]</span><br><span class="line">  &#125;</span><br><span class="line">  getLength() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.queue.length - <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  isEmpty() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.first === <span class="keyword">this</span>.last</span><br><span class="line">  &#125;</span><br><span class="line">  resize(length) &#123;</span><br><span class="line">    <span class="keyword">let</span> q = <span class="keyword">new</span> <span class="built_in">Array</span>(length)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">      q[i] = <span class="keyword">this</span>.queue[(i + <span class="keyword">this</span>.first) % <span class="keyword">this</span>.queue.length]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.queue = q</span><br><span class="line">    <span class="keyword">this</span>.first = <span class="number">0</span></span><br><span class="line">    <span class="keyword">this</span>.last = <span class="keyword">this</span>.size</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="35-5-链表"><a href="#35-5-链表" class="headerlink" title="35.5 链表"></a>35.5 链表</h3><p><strong>概念</strong></p><blockquote><p>链表是一个线性结构，同时也是一个天然的递归结构。链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。</p></blockquote><p><strong>概念</strong></p><blockquote><p>链表是一个线性结构，同时也是一个天然的递归结构。链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/5/22/16388487759b1152" alt=""></p><p><strong>实现</strong></p><p><strong>单向链表</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(v, next) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = v</span><br><span class="line">    <span class="keyword">this</span>.next = next</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkList</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// 链表长度</span></span><br><span class="line">    <span class="keyword">this</span>.size = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 虚拟头部</span></span><br><span class="line">    <span class="keyword">this</span>.dummyNode = <span class="keyword">new</span> Node(<span class="literal">null</span>, <span class="literal">null</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  find(header, index, currentIndex) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index === currentIndex) <span class="keyword">return</span> header</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.find(header.next, index, currentIndex + <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  addNode(v, index) &#123;</span><br><span class="line">    <span class="keyword">this</span>.checkIndex(index)</span><br><span class="line">    <span class="comment">// 当往链表末尾插入时，prev.next 为空</span></span><br><span class="line">    <span class="comment">// 其他情况时，因为要插入节点，所以插入的节点</span></span><br><span class="line">    <span class="comment">// 的 next 应该是 prev.next</span></span><br><span class="line">    <span class="comment">// 然后设置 prev.next 为插入的节点</span></span><br><span class="line">    <span class="keyword">let</span> prev = <span class="keyword">this</span>.find(<span class="keyword">this</span>.dummyNode, index, <span class="number">0</span>)</span><br><span class="line">    prev.next = <span class="keyword">new</span> Node(v, prev.next)</span><br><span class="line">    <span class="keyword">this</span>.size++</span><br><span class="line">    <span class="keyword">return</span> prev.next</span><br><span class="line">  &#125;</span><br><span class="line">  insertNode(v, index) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.addNode(v, index)</span><br><span class="line">  &#125;</span><br><span class="line">  addToFirst(v) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.addNode(v, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  addToLast(v) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.addNode(v, <span class="keyword">this</span>.size)</span><br><span class="line">  &#125;</span><br><span class="line">  removeNode(index, isLast) &#123;</span><br><span class="line">    <span class="keyword">this</span>.checkIndex(index)</span><br><span class="line">    index = isLast ? index - <span class="number">1</span> : index</span><br><span class="line">    <span class="keyword">let</span> prev = <span class="keyword">this</span>.find(<span class="keyword">this</span>.dummyNode, index, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">let</span> node = prev.next</span><br><span class="line">    prev.next = node.next</span><br><span class="line">    node.next = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">this</span>.size--</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">  &#125;</span><br><span class="line">  removeFirstNode() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.removeNode(<span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  removeLastNode() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.removeNode(<span class="keyword">this</span>.size, <span class="literal">true</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  checkIndex(index) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; <span class="keyword">this</span>.size) <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'Index error'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  getNode(index) &#123;</span><br><span class="line">    <span class="keyword">this</span>.checkIndex(index)</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.find(<span class="keyword">this</span>.dummyNode, index, <span class="number">0</span>).next</span><br><span class="line">  &#125;</span><br><span class="line">  isEmpty() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size === <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  getSize() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="35-6-树"><a href="#35-6-树" class="headerlink" title="35.6 树"></a>35.6 树</h3><p><strong>二叉树</strong></p><ul><li>树拥有很多种结构，二叉树是树中最常用的结构，同时也是一个天然的递归结构。</li><li>二叉树拥有一个根节点，每个节点至多拥有两个子节点，分别为：左节点和右节点。树的最底部节点称之为叶节点，当一颗树的叶数量数量为满时，该树可以称之为满二叉树。</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/5/22/163884f74c9f4e4d" alt=""></p><p><strong>二分搜索树</strong></p><ul><li>二分搜索树也是二叉树，拥有二叉树的特性。但是区别在于二分搜索树每个节点的值都比他的左子树的值大，比右子树的值小。</li><li>这种存储方式很适合于数据搜索。如下图所示，当需要查找 6 的时候，因为需要查找的值比根节点的值大，所以只需要在根节点的右子树上寻找，大大提高了搜索效率。</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/5/22/1638850ba7458208" alt=""></p><p><strong>实现</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value</span><br><span class="line">    <span class="keyword">this</span>.left = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">this</span>.right = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BST</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.root = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">this</span>.size = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  getSize() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size</span><br><span class="line">  &#125;</span><br><span class="line">  isEmpty() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size === <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  addNode(v) &#123;</span><br><span class="line">    <span class="keyword">this</span>.root = <span class="keyword">this</span>._addChild(<span class="keyword">this</span>.root, v)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加节点时，需要比较添加的节点值和当前</span></span><br><span class="line">  <span class="comment">// 节点值的大小</span></span><br><span class="line">  _addChild(node, v) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">      <span class="keyword">this</span>.size++</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Node(v)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.value &gt; v) &#123;</span><br><span class="line">      node.left = <span class="keyword">this</span>._addChild(node.left, v)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.value &lt; v) &#123;</span><br><span class="line">      node.right = <span class="keyword">this</span>._addChild(node.right, v)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>以上是最基本的二分搜索树实现，接下来实现树的遍历。</li><li>对于树的遍历来说，有三种遍历方法，分别是先序遍历、中序遍历、后序遍历。三种遍历的区别在于何时访问节点。在遍历树的过程中，每个节点都会遍历三次，分别是遍历到自己，遍历左子树和遍历右子树。如果需要实现先序遍历，那么只需要第一次遍历到节点时进行操作即可。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先序遍历可用于打印树的结构</span></span><br><span class="line"><span class="comment">// 先序遍历先访问根节点，然后访问左节点，最后访问右节点。</span></span><br><span class="line">preTraversal() &#123;</span><br><span class="line">  <span class="keyword">this</span>._pre(<span class="keyword">this</span>.root)</span><br><span class="line">&#125;</span><br><span class="line">_pre(node) &#123;</span><br><span class="line">  <span class="keyword">if</span> (node) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(node.value)</span><br><span class="line">    <span class="keyword">this</span>._pre(node.left)</span><br><span class="line">    <span class="keyword">this</span>._pre(node.right)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中序遍历可用于排序</span></span><br><span class="line"><span class="comment">// 对于 BST 来说，中序遍历可以实现一次遍历就</span></span><br><span class="line"><span class="comment">// 得到有序的值</span></span><br><span class="line"><span class="comment">// 中序遍历表示先访问左节点，然后访问根节点，最后访问右节点。</span></span><br><span class="line">midTraversal() &#123;</span><br><span class="line">  <span class="keyword">this</span>._mid(<span class="keyword">this</span>.root)</span><br><span class="line">&#125;</span><br><span class="line">_mid(node) &#123;</span><br><span class="line">  <span class="keyword">if</span> (node) &#123;</span><br><span class="line">    <span class="keyword">this</span>._mid(node.left)</span><br><span class="line">    <span class="built_in">console</span>.log(node.value)</span><br><span class="line">    <span class="keyword">this</span>._mid(node.right)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 后序遍历可用于先操作子节点</span></span><br><span class="line"><span class="comment">// 再操作父节点的场景</span></span><br><span class="line"><span class="comment">// 后序遍历表示先访问左节点，然后访问右节点，最后访问根节点。</span></span><br><span class="line">backTraversal() &#123;</span><br><span class="line">  <span class="keyword">this</span>._back(<span class="keyword">this</span>.root)</span><br><span class="line">&#125;</span><br><span class="line">_back(node) &#123;</span><br><span class="line">  <span class="keyword">if</span> (node) &#123;</span><br><span class="line">    <span class="keyword">this</span>._back(node.left)</span><br><span class="line">    <span class="keyword">this</span>._back(node.right)</span><br><span class="line">    <span class="built_in">console</span>.log(node.value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以上的这几种遍历都可以称之为深度遍历，对应的还有种遍历叫做广度遍历，也就是一层层地遍历树。对于广度遍历来说，我们需要利用之前讲过的队列结构来完成。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">breadthTraversal() &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.root) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  <span class="keyword">let</span> q = <span class="keyword">new</span> Queue()</span><br><span class="line">  <span class="comment">// 将根节点入队</span></span><br><span class="line">  q.enQueue(<span class="keyword">this</span>.root)</span><br><span class="line">  <span class="comment">// 循环判断队列是否为空，为空</span></span><br><span class="line">  <span class="comment">// 代表树遍历完毕</span></span><br><span class="line">  <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">    <span class="comment">// 将队首出队，判断是否有左右子树</span></span><br><span class="line">    <span class="comment">// 有的话，就先左后右入队</span></span><br><span class="line">    <span class="keyword">let</span> n = q.deQueue()</span><br><span class="line">    <span class="built_in">console</span>.log(n.value)</span><br><span class="line">    <span class="keyword">if</span> (n.left) q.enQueue(n.left)</span><br><span class="line">    <span class="keyword">if</span> (n.right) q.enQueue(n.right)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>接下来先介绍如何在树中寻找最小值或最大数。因为二分搜索树的特性，所以最小值一定在根节点的最左边，最大值相反</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getMin() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>._getMin(<span class="keyword">this</span>.root).value</span><br><span class="line">&#125;</span><br><span class="line">_getMin(node) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!node.left) <span class="keyword">return</span> node</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>._getMin(node.left)</span><br><span class="line">&#125;</span><br><span class="line">getMax() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>._getMax(<span class="keyword">this</span>.root).value</span><br><span class="line">&#125;</span><br><span class="line">_getMax(node) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!node.right) <span class="keyword">return</span> node</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>._getMin(node.right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>向上取整和向下取整，这两个操作是相反的，所以代码也是类似的，这里只介绍如何向下取整。既然是向下取整，那么根据二分搜索树的特性，值一定在根节点的左侧。只需要一直遍历左子树直到当前节点的值不再大于等于需要的值，然后判断节点是否还拥有右子树。如果有的话，继续上面的递归判断。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">floor(v) &#123;</span><br><span class="line">  <span class="keyword">let</span> node = <span class="keyword">this</span>._floor(<span class="keyword">this</span>.root, v)</span><br><span class="line">  <span class="keyword">return</span> node ? node.value : <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line">_floor(node, v) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  <span class="keyword">if</span> (node.value === v) <span class="keyword">return</span> v</span><br><span class="line">  <span class="comment">// 如果当前节点值还比需要的值大，就继续递归</span></span><br><span class="line">  <span class="keyword">if</span> (node.value &gt; v) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._floor(node.left, v)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断当前节点是否拥有右子树</span></span><br><span class="line">  <span class="keyword">let</span> right = <span class="keyword">this</span>._floor(node.right, v)</span><br><span class="line">  <span class="keyword">if</span> (right) <span class="keyword">return</span> right</span><br><span class="line">  <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>排名，这是用于获取给定值的排名或者排名第几的节点的值，这两个操作也是相反的，所以这个只介绍如何获取排名第几的节点的值。对于这个操作而言，我们需要略微的改造点代码，让每个节点拥有一个 size 属性。该属性表示该节点下有多少子节点（包含自身）</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value</span><br><span class="line">    <span class="keyword">this</span>.left = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">this</span>.right = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// 修改代码</span></span><br><span class="line">    <span class="keyword">this</span>.size = <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 新增代码</span></span><br><span class="line">_getSize(node) &#123;</span><br><span class="line">  <span class="keyword">return</span> node ? node.size : <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">_addChild(node, v) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Node(v)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (node.value &gt; v) &#123;</span><br><span class="line">    <span class="comment">// 修改代码</span></span><br><span class="line">    node.size++</span><br><span class="line">    node.left = <span class="keyword">this</span>._addChild(node.left, v)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.value &lt; v) &#123;</span><br><span class="line">    <span class="comment">// 修改代码</span></span><br><span class="line">    node.size++</span><br><span class="line">    node.right = <span class="keyword">this</span>._addChild(node.right, v)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line">select(k) &#123;</span><br><span class="line">  <span class="keyword">let</span> node = <span class="keyword">this</span>._select(<span class="keyword">this</span>.root, k)</span><br><span class="line">  <span class="keyword">return</span> node ? node.value : <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line">_select(node, k) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  <span class="comment">// 先获取左子树下有几个节点</span></span><br><span class="line">  <span class="keyword">let</span> size = node.left ? node.left.size : <span class="number">0</span></span><br><span class="line">  <span class="comment">// 判断 size 是否大于 k</span></span><br><span class="line">  <span class="comment">// 如果大于 k，代表所需要的节点在左节点</span></span><br><span class="line">  <span class="keyword">if</span> (size &gt; k) <span class="keyword">return</span> <span class="keyword">this</span>._select(node.left, k)</span><br><span class="line">  <span class="comment">// 如果小于 k，代表所需要的节点在右节点</span></span><br><span class="line">  <span class="comment">// 注意这里需要重新计算 k，减去根节点除了右子树的节点数量</span></span><br><span class="line">  <span class="keyword">if</span> (size &lt; k) <span class="keyword">return</span> <span class="keyword">this</span>._select(node.right, k - size - <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>接下来讲解的是二分搜索树中最难实现的部分：删除节点。因为对于删除节点来说，会存在以下几种情况</p></blockquote><ul><li>需要删除的节点没有子树</li><li>需要删除的节点只有一条子树</li><li>需要删除的节点有左右两条树</li></ul><blockquote><p>对于前两种情况很好解决，但是第三种情况就有难度了，所以先来实现相对简单的操作：删除最小节点，对于删除最小节点来说，是不存在第三种情况的，删除最大节点操作是和删除最小节点相反的，所以这里也就不再赘述。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">delectMin() &#123;</span><br><span class="line">  <span class="keyword">this</span>.root = <span class="keyword">this</span>._delectMin(<span class="keyword">this</span>.root)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.root)</span><br><span class="line">&#125;</span><br><span class="line">_delectMin(node) &#123;</span><br><span class="line">  <span class="comment">// 一直递归左子树</span></span><br><span class="line">  <span class="comment">// 如果左子树为空，就判断节点是否拥有右子树</span></span><br><span class="line">  <span class="comment">// 有右子树的话就把需要删除的节点替换为右子树</span></span><br><span class="line">  <span class="keyword">if</span> ((node != <span class="literal">null</span>) &amp; !node.left) <span class="keyword">return</span> node.right</span><br><span class="line">  node.left = <span class="keyword">this</span>._delectMin(node.left)</span><br><span class="line">  <span class="comment">// 最后需要重新维护下节点的 `size`</span></span><br><span class="line">  node.size = <span class="keyword">this</span>._getSize(node.left) + <span class="keyword">this</span>._getSize(node.right) + <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>最后讲解的就是如何删除任意节点了。对于这个操作，T.Hibbard 在 1962 年提出了解决这个难题的办法，也就是如何解决第三种情况。</li><li>当遇到这种情况时，需要取出当前节点的后继节点（也就是当前节点右子树的最小节点）来替换需要删除的节点。然后将需要删除节点的左子树赋值给后继结点，右子树删除后继结点后赋值给他。</li><li>你如果对于这个解决办法有疑问的话，可以这样考虑。因为二分搜索树的特性，父节点一定比所有左子节点大，比所有右子节点小。那么当需要删除父节点时，势必需要拿出一个比父节点大的节点来替换父节点。这个节点肯定不存在于左子树，必然存在于右子树。然后又需要保持父节点都是比右子节点小的，那么就可以取出右子树中最小的那个节点来替换父节点。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">delect(v) &#123;</span><br><span class="line">  <span class="keyword">this</span>.root = <span class="keyword">this</span>._delect(<span class="keyword">this</span>.root, v)</span><br><span class="line">&#125;</span><br><span class="line">_delect(node, v) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  <span class="comment">// 寻找的节点比当前节点小，去左子树找</span></span><br><span class="line">  <span class="keyword">if</span> (node.value &lt; v) &#123;</span><br><span class="line">    node.right = <span class="keyword">this</span>._delect(node.right, v)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.value &gt; v) &#123;</span><br><span class="line">    <span class="comment">// 寻找的节点比当前节点大，去右子树找</span></span><br><span class="line">    node.left = <span class="keyword">this</span>._delect(node.left, v)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 进入这个条件说明已经找到节点</span></span><br><span class="line">    <span class="comment">// 先判断节点是否拥有拥有左右子树中的一个</span></span><br><span class="line">    <span class="comment">// 是的话，将子树返回出去，这里和 `_delectMin` 的操作一样</span></span><br><span class="line">    <span class="keyword">if</span> (!node.left) <span class="keyword">return</span> node.right</span><br><span class="line">    <span class="keyword">if</span> (!node.right) <span class="keyword">return</span> node.left</span><br><span class="line">    <span class="comment">// 进入这里，代表节点拥有左右子树</span></span><br><span class="line">    <span class="comment">// 先取出当前节点的后继结点，也就是取当前节点右子树的最小值</span></span><br><span class="line">    <span class="keyword">let</span> min = <span class="keyword">this</span>._getMin(node.right)</span><br><span class="line">    <span class="comment">// 取出最小值后，删除最小值</span></span><br><span class="line">    <span class="comment">// 然后把删除节点后的子树赋值给最小值节点</span></span><br><span class="line">    min.right = <span class="keyword">this</span>._delectMin(node.right)</span><br><span class="line">    <span class="comment">// 左子树不动</span></span><br><span class="line">    min.left = node.left</span><br><span class="line">    node = min</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 维护 size</span></span><br><span class="line">  node.size = <span class="keyword">this</span>._getSize(node.left) + <span class="keyword">this</span>._getSize(node.right) + <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="35-7-AVL-树"><a href="#35-7-AVL-树" class="headerlink" title="35.7 AVL 树"></a>35.7 AVL 树</h3><p><strong>概念</strong></p><blockquote><p>二分搜索树实际在业务中是受到限制的，因为并不是严格的 O(logN)，在极端情况下会退化成链表，比如加入一组升序的数字就会造成这种情况。</p></blockquote><blockquote><p>AVL 树改进了二分搜索树，在 AVL 树中任意节点的左右子树的高度差都不大于 1，这样保证了时间复杂度是严格的 O(logN)。基于此，对 AVL 树增加或删除节点时可能需要旋转树来达到高度的平衡。</p></blockquote><p><strong>实现</strong></p><ul><li>因为 <code>AVL</code> 树是改进了二分搜索树，所以部分代码是于二分搜索树重复的，对于重复内容不作再次解析。</li><li>对于 AVL 树来说，添加节点会有四种情况</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/6/23/1642cc145a0cfb26" alt=""></p><ul><li>对于左左情况来说，新增加的节点位于节点 <code>2</code> 的左侧，这时树已经不平衡，需要旋转。因为搜索树的特性，节点比左节点大，比右节点小，所以旋转以后也要实现这个特性。</li><li>旋转之前：<code>new &lt; 2 &lt; C &lt; 3 &lt; B &lt; 5 &lt; A</code>，右旋之后节点 <code>3</code> 为根节点，这时候需要将节点 3 的右节点加到节点 5 的左边，最后还需要更新节点的高度。</li><li>对于右右情况来说，相反于左左情况，所以不再赘述。</li><li>对于左右情况来说，新增加的节点位于节点 4 的右侧。对于这种情况，需要通过两次旋转来达到目的。</li><li>首先对节点的左节点左旋，这时树满足左左的情况，再对节点进行一次右旋就可以达到目的。</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value</span><br><span class="line">    <span class="keyword">this</span>.left = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">this</span>.right = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">this</span>.height = <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AVL</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.root = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  addNode(v) &#123;</span><br><span class="line">    <span class="keyword">this</span>.root = <span class="keyword">this</span>._addChild(<span class="keyword">this</span>.root, v)</span><br><span class="line">  &#125;</span><br><span class="line">  _addChild(node, v) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Node(v)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.value &gt; v) &#123;</span><br><span class="line">      node.left = <span class="keyword">this</span>._addChild(node.left, v)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.value &lt; v) &#123;</span><br><span class="line">      node.right = <span class="keyword">this</span>._addChild(node.right, v)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      node.value = v</span><br><span class="line">    &#125;</span><br><span class="line">    node.height =</span><br><span class="line">      <span class="number">1</span> + <span class="built_in">Math</span>.max(<span class="keyword">this</span>._getHeight(node.left), <span class="keyword">this</span>._getHeight(node.right))</span><br><span class="line">    <span class="keyword">let</span> factor = <span class="keyword">this</span>._getBalanceFactor(node)</span><br><span class="line">    <span class="comment">// 当需要右旋时，根节点的左树一定比右树高度高</span></span><br><span class="line">    <span class="keyword">if</span> (factor &gt; <span class="number">1</span> &amp;&amp; <span class="keyword">this</span>._getBalanceFactor(node.left) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>._rightRotate(node)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当需要左旋时，根节点的左树一定比右树高度矮</span></span><br><span class="line">    <span class="keyword">if</span> (factor &lt; <span class="number">-1</span> &amp;&amp; <span class="keyword">this</span>._getBalanceFactor(node.right) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>._leftRotate(node)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 左右情况</span></span><br><span class="line">    <span class="comment">// 节点的左树比右树高，且节点的左树的右树比节点的左树的左树高</span></span><br><span class="line">    <span class="keyword">if</span> (factor &gt; <span class="number">1</span> &amp;&amp; <span class="keyword">this</span>._getBalanceFactor(node.left) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      node.left = <span class="keyword">this</span>._leftRotate(node.left)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>._rightRotate(node)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 右左情况</span></span><br><span class="line">    <span class="comment">// 节点的左树比右树矮，且节点的右树的右树比节点的右树的左树矮</span></span><br><span class="line">    <span class="keyword">if</span> (factor &lt; <span class="number">-1</span> &amp;&amp; <span class="keyword">this</span>._getBalanceFactor(node.right) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      node.right = <span class="keyword">this</span>._rightRotate(node.right)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>._leftRotate(node)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">  &#125;</span><br><span class="line">  _getHeight(node) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!node) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> node.height</span><br><span class="line">  &#125;</span><br><span class="line">  _getBalanceFactor(node) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._getHeight(node.left) - <span class="keyword">this</span>._getHeight(node.right)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 节点右旋</span></span><br><span class="line">  <span class="comment">//           5                    2</span></span><br><span class="line">  <span class="comment">//         /   \                /   \</span></span><br><span class="line">  <span class="comment">//        2     6   ==&gt;       1      5</span></span><br><span class="line">  <span class="comment">//       /  \               /       /  \</span></span><br><span class="line">  <span class="comment">//      1    3             new     3    6</span></span><br><span class="line">  <span class="comment">//     /</span></span><br><span class="line">  <span class="comment">//    new</span></span><br><span class="line">  _rightRotate(node) &#123;</span><br><span class="line">    <span class="comment">// 旋转后新根节点</span></span><br><span class="line">    <span class="keyword">let</span> newRoot = node.left</span><br><span class="line">    <span class="comment">// 需要移动的节点</span></span><br><span class="line">    <span class="keyword">let</span> moveNode = newRoot.right</span><br><span class="line">    <span class="comment">// 节点 2 的右节点改为节点 5</span></span><br><span class="line">    newRoot.right = node</span><br><span class="line">    <span class="comment">// 节点 5 左节点改为节点 3</span></span><br><span class="line">    node.left = moveNode</span><br><span class="line">    <span class="comment">// 更新树的高度</span></span><br><span class="line">    node.height =</span><br><span class="line">      <span class="number">1</span> + <span class="built_in">Math</span>.max(<span class="keyword">this</span>._getHeight(node.left), <span class="keyword">this</span>._getHeight(node.right))</span><br><span class="line">    newRoot.height =</span><br><span class="line">      <span class="number">1</span> +</span><br><span class="line">      <span class="built_in">Math</span>.max(<span class="keyword">this</span>._getHeight(newRoot.left), <span class="keyword">this</span>._getHeight(newRoot.right))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newRoot</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 节点左旋</span></span><br><span class="line">  <span class="comment">//           4                    6</span></span><br><span class="line">  <span class="comment">//         /   \                /   \</span></span><br><span class="line">  <span class="comment">//        2     6   ==&gt;       4      7</span></span><br><span class="line">  <span class="comment">//             /  \         /   \      \</span></span><br><span class="line">  <span class="comment">//            5     7      2     5      new</span></span><br><span class="line">  <span class="comment">//                   \</span></span><br><span class="line">  <span class="comment">//                    new</span></span><br><span class="line">  _leftRotate(node) &#123;</span><br><span class="line">    <span class="comment">// 旋转后新根节点</span></span><br><span class="line">    <span class="keyword">let</span> newRoot = node.right</span><br><span class="line">    <span class="comment">// 需要移动的节点</span></span><br><span class="line">    <span class="keyword">let</span> moveNode = newRoot.left</span><br><span class="line">    <span class="comment">// 节点 6 的左节点改为节点 4</span></span><br><span class="line">    newRoot.left = node</span><br><span class="line">    <span class="comment">// 节点 4 右节点改为节点 5</span></span><br><span class="line">    node.right = moveNode</span><br><span class="line">    <span class="comment">// 更新树的高度</span></span><br><span class="line">    node.height =</span><br><span class="line">      <span class="number">1</span> + <span class="built_in">Math</span>.max(<span class="keyword">this</span>._getHeight(node.left), <span class="keyword">this</span>._getHeight(node.right))</span><br><span class="line">    newRoot.height =</span><br><span class="line">      <span class="number">1</span> +</span><br><span class="line">      <span class="built_in">Math</span>.max(<span class="keyword">this</span>._getHeight(newRoot.left), <span class="keyword">this</span>._getHeight(newRoot.right))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newRoot</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="35-8-Trie"><a href="#35-8-Trie" class="headerlink" title="35.8 Trie"></a>35.8 Trie</h3><p><strong>概念</strong></p><ul><li>在计算机科学，trie，又称前缀树或字典树，是一种有序树，用于保存关联数组，其中的键通常是字符串。</li></ul><blockquote><p>简单点来说，这个结构的作用大多是为了方便搜索字符串，该树有以下几个特点</p></blockquote><ul><li>根节点代表空字符串，每个节点都有 N（假如搜索英文字符，就有 26 条） 条链接，每条链接代表一个字符</li><li>节点不存储字符，只有路径才存储，这点和其他的树结构不同</li><li>从根节点开始到任意一个节点，将沿途经过的字符连接起来就是该节点对应的字符串</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/6/9/163e1d2f6cec3348" alt=""></p><p><strong>实现</strong></p><blockquote><p>总得来说 <code>Trie</code> 的实现相比别的树结构来说简单的很多，实现就以搜索英文字符为例。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// 代表每个字符经过节点的次数</span></span><br><span class="line">    <span class="keyword">this</span>.path = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 代表到该节点的字符串有几个</span></span><br><span class="line">    <span class="keyword">this</span>.end = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 链接</span></span><br><span class="line">    <span class="keyword">this</span>.next = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">26</span>).fill(<span class="literal">null</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// 根节点，代表空字符</span></span><br><span class="line">    <span class="keyword">this</span>.root = <span class="keyword">new</span> TrieNode()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 插入字符串</span></span><br><span class="line">  insert(str) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!str) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">let</span> node = <span class="keyword">this</span>.root</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">      <span class="comment">// 获得字符先对应的索引</span></span><br><span class="line">      <span class="keyword">let</span> index = str[i].charCodeAt() - <span class="string">'a'</span>.charCodeAt()</span><br><span class="line">      <span class="comment">// 如果索引对应没有值，就创建</span></span><br><span class="line">      <span class="keyword">if</span> (!node.next[index]) &#123;</span><br><span class="line">        node.next[index] = <span class="keyword">new</span> TrieNode()</span><br><span class="line">      &#125;</span><br><span class="line">      node.path += <span class="number">1</span></span><br><span class="line">      node = node.next[index]</span><br><span class="line">    &#125;</span><br><span class="line">    node.end += <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 搜索字符串出现的次数</span></span><br><span class="line">  search(str) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!str) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">let</span> node = <span class="keyword">this</span>.root</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> index = str[i].charCodeAt() - <span class="string">'a'</span>.charCodeAt()</span><br><span class="line">      <span class="comment">// 如果索引对应没有值，代表没有需要搜素的字符串</span></span><br><span class="line">      <span class="keyword">if</span> (!node.next[index]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">      node = node.next[index]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node.end</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 删除字符串</span></span><br><span class="line">  <span class="keyword">delete</span>(str) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.search(str)) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">let</span> node = <span class="keyword">this</span>.root</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> index = str[i].charCodeAt() - <span class="string">'a'</span>.charCodeAt()</span><br><span class="line">      <span class="comment">// 如果索引对应的节点的 Path 为 0，代表经过该节点的字符串</span></span><br><span class="line">      <span class="comment">// 已经一个，直接删除即可</span></span><br><span class="line">      <span class="keyword">if</span> (--node.next[index].path == <span class="number">0</span>) &#123;</span><br><span class="line">        node.next[index] = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      node = node.next[index]</span><br><span class="line">    &#125;</span><br><span class="line">    node.end -= <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="35-9-并查集"><a href="#35-9-并查集" class="headerlink" title="35.9 并查集"></a>35.9 并查集</h3><p><strong>概念</strong></p><ul><li>并查集是一种特殊的树结构，用于处理一些不交集的合并及查询问题。该结构中每个节点都有一个父节点，如果只有当前一个节点，那么该节点的父节点指向自己。</li></ul><blockquote><p>这个结构中有两个重要的操作，分别是：</p></blockquote><ul><li><code>Find</code>：确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一子集。</li><li><code>Union</code>：将两个子集合并成同一个集合。</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/6/9/163e45b56fd25172" alt=""></p><p><strong>实现</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DisjointSet</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化样本</span></span><br><span class="line">  <span class="keyword">constructor</span>(count) &#123;</span><br><span class="line">    <span class="comment">// 初始化时，每个节点的父节点都是自己</span></span><br><span class="line">    <span class="keyword">this</span>.parent = <span class="keyword">new</span> <span class="built_in">Array</span>(count)</span><br><span class="line">    <span class="comment">// 用于记录树的深度，优化搜索复杂度</span></span><br><span class="line">    <span class="keyword">this</span>.rank = <span class="keyword">new</span> <span class="built_in">Array</span>(count)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">      <span class="keyword">this</span>.parent[i] = i</span><br><span class="line">      <span class="keyword">this</span>.rank[i] = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  find(p) &#123;</span><br><span class="line">    <span class="comment">// 寻找当前节点的父节点是否为自己，不是的话表示还没找到</span></span><br><span class="line">    <span class="comment">// 开始进行路径压缩优化</span></span><br><span class="line">    <span class="comment">// 假设当前节点父节点为 A</span></span><br><span class="line">    <span class="comment">// 将当前节点挂载到 A 节点的父节点上，达到压缩深度的目的</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">this</span>.parent[p]) &#123;</span><br><span class="line">      <span class="keyword">this</span>.parent[p] = <span class="keyword">this</span>.parent[<span class="keyword">this</span>.parent[p]]</span><br><span class="line">      p = <span class="keyword">this</span>.parent[p]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line">  &#125;</span><br><span class="line">  isConnected(p, q) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.find(p) === <span class="keyword">this</span>.find(q)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 合并</span></span><br><span class="line">  union(p, q) &#123;</span><br><span class="line">    <span class="comment">// 找到两个数字的父节点</span></span><br><span class="line">    <span class="keyword">let</span> i = <span class="keyword">this</span>.find(p)</span><br><span class="line">    <span class="keyword">let</span> j = <span class="keyword">this</span>.find(q)</span><br><span class="line">    <span class="keyword">if</span> (i === j) <span class="keyword">return</span></span><br><span class="line">    <span class="comment">// 判断两棵树的深度，深度小的加到深度大的树下面</span></span><br><span class="line">    <span class="comment">// 如果两棵树深度相等，那就无所谓怎么加</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.rank[i] &lt; <span class="keyword">this</span>.rank[j]) &#123;</span><br><span class="line">      <span class="keyword">this</span>.parent[i] = j</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.rank[i] &gt; <span class="keyword">this</span>.rank[j]) &#123;</span><br><span class="line">      <span class="keyword">this</span>.parent[j] = i</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.parent[i] = j</span><br><span class="line">      <span class="keyword">this</span>.rank[j] += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="35-10-堆"><a href="#35-10-堆" class="headerlink" title="35.10 堆"></a>35.10 堆</h3><p><strong>概念</strong></p><ul><li>堆通常是一个可以被看做一棵树的数组对象。</li></ul><blockquote><p>堆的实现通过构造二叉堆，实为二叉树的一种。这种数据结构具有以下性质。</p></blockquote><ol><li>任意节点小于（或大于）它的所有子节点</li><li>堆总是一棵完全树。即除了最底层，其他层的节点都被元素填满，且最底层从左到右填入。</li></ol><ul><li>将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。</li><li>优先队列也完全可以用堆来实现，操作是一模一样的。</li></ul><p><strong>实现大根堆</strong></p><ul><li>堆的每个节点的左边子节点索引是 <code>i * 2 + 1</code>，右边是 <code>i * 2 + 2</code>，父节点是 <code>(i - 1) /2</code>。</li><li>堆有两个核心的操作，分别是 <code>shiftUp</code> 和 <code>shiftDown</code> 。前者用于添加元素，后者用于删除根节点。</li><li><code>shiftUp</code> 的核心思路是一路将节点与父节点对比大小，如果比父节点大，就和父节点交换位置。</li><li><code>shiftDown</code> 的核心思路是先将根节点和末尾交换位置，然后移除末尾元素。接下来循环判断父节点和两个子节点的大小，如果子节点大，就把最大的子节点和父节点交换。</li></ul><p><img src="https://user-gold-cdn.xitu.io/2018/6/15/164009e58a5a21f8" alt=""></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxHeap</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.heap = []</span><br><span class="line">  &#125;</span><br><span class="line">  size() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.heap.length</span><br><span class="line">  &#125;</span><br><span class="line">  empty() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size() == <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  add(item) &#123;</span><br><span class="line">    <span class="keyword">this</span>.heap.push(item)</span><br><span class="line">    <span class="keyword">this</span>._shiftUp(<span class="keyword">this</span>.size() - <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  removeMax() &#123;</span><br><span class="line">    <span class="keyword">this</span>._shiftDown(<span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  getParentIndex(k) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parseInt</span>((k - <span class="number">1</span>) / <span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  getLeftIndex(k) &#123;</span><br><span class="line">    <span class="keyword">return</span> k * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  _shiftUp(k) &#123;</span><br><span class="line">    <span class="comment">// 如果当前节点比父节点大，就交换</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>.heap[k] &gt; <span class="keyword">this</span>.heap[<span class="keyword">this</span>.getParentIndex(k)]) &#123;</span><br><span class="line">      <span class="keyword">this</span>._swap(k, <span class="keyword">this</span>.getParentIndex(k))</span><br><span class="line">      <span class="comment">// 将索引变成父节点</span></span><br><span class="line">      k = <span class="keyword">this</span>.getParentIndex(k)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  _shiftDown(k) &#123;</span><br><span class="line">    <span class="comment">// 交换首位并删除末尾</span></span><br><span class="line">    <span class="keyword">this</span>._swap(k, <span class="keyword">this</span>.size() - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">this</span>.heap.splice(<span class="keyword">this</span>.size() - <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 判断节点是否有左孩子，因为二叉堆的特性，有右必有左</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">this</span>.getLeftIndex(k) &lt; <span class="keyword">this</span>.size()) &#123;</span><br><span class="line">      <span class="keyword">let</span> j = <span class="keyword">this</span>.getLeftIndex(k)</span><br><span class="line">      <span class="comment">// 判断是否有右孩子，并且右孩子是否大于左孩子</span></span><br><span class="line">      <span class="keyword">if</span> (j + <span class="number">1</span> &lt; <span class="keyword">this</span>.size() &amp;&amp; <span class="keyword">this</span>.heap[j + <span class="number">1</span>] &gt; <span class="keyword">this</span>.heap[j]) j++</span><br><span class="line">      <span class="comment">// 判断父节点是否已经比子节点都大</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.heap[k] &gt;= <span class="keyword">this</span>.heap[j]) <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">this</span>._swap(k, j)</span><br><span class="line">      k = j</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  _swap(left, right) &#123;</span><br><span class="line">    <span class="keyword">let</span> rightValue = <span class="keyword">this</span>.heap[right]</span><br><span class="line">    <span class="keyword">this</span>.heap[right] = <span class="keyword">this</span>.heap[left]</span><br><span class="line">    <span class="keyword">this</span>.heap[left] = rightValue</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="36-常考算法题解析"><a href="#36-常考算法题解析" class="headerlink" title="36 常考算法题解析"></a>36 常考算法题解析</h2><blockquote><p>对于大部分公司的面试来说，排序的内容已经足以应付了，由此为了更好的符合大众需求，排序的内容是最多的。当然如果你还想冲击更好的公司，那么整一个章节的内容都是需要掌握的。对于字节跳动这类十分看重算法的公司来说，这一章节是远远不够的，剑指Offer应该是你更好的选择</p></blockquote><blockquote><p>这一章节的内容信息量会很大，不适合在非电脑环境下阅读，请各位打开代码编辑器，一行行的敲代码，单纯阅读是学习不了算法的</p></blockquote><blockquote><p>另外学习算法的时候，有一个可视化界面会相对减少点学习的难度，具体可以阅读 <a href="https://github.com/algorithm-visualizer/algorithm-visualizer" target="_blank" rel="noopener">algorithm-visualizer</a> 这个仓库</p></blockquote><h3 id="36-1-位运算"><a href="#36-1-位运算" class="headerlink" title="36.1 位运算"></a>36.1 位运算</h3><ul><li>在进入正题之前，我们先来学习一下位运算的内容。因为位运算在算法中很有用，速度可以比四则运算快很多。</li><li>在学习位运算之前应该知道十进制如何转二进制，二进制如何转十进制。这里说明下简单的计算方式</li></ul><ol><li>十进制 <code>33</code> 可以看成是 <code>32 + 1</code> ，并且 <code>33</code> 应该是六位二进制的（因为 <code>33</code> 近似 <code>32</code>，而 <code>32</code> 是 <code>2</code> 的五次方，所以是六位），那么 十进制 <code>33</code> 就是 <code>100001</code> ，只要是 <code>2</code> 的次方，那么就是 <code>1</code>否则都为 <code>0</code></li><li>那么二进制 <code>100001</code> 同理，首位是 <code>2^5</code> ，末位是 <code>2^0</code> ，相加得出 <code>33</code></li></ol><p><strong>1. 左移 &lt;&lt;</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 &lt;&lt; 1 &#x2F;&#x2F; -&gt; 20</span><br></pre></td></tr></table></figure><blockquote><p>左移就是将二进制全部往左移动，<code>10</code> 在二进制中表示为 <code>1010</code>，左移一位后变成 <code>10100</code> ，转换为十进制也就是 <code>20</code>，所以基本可以把左移看成以下公式 <code>a * (2 ^ b)</code></p></blockquote><p><strong>2. 算数右移 &gt;&gt;</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 &gt;&gt; 1 &#x2F;&#x2F; -&gt; 5</span><br></pre></td></tr></table></figure><blockquote><p>算数右移就是将二进制全部往右移动并去除多余的右边，<code>10</code> 在二进制中表示为 <code>1010</code> ，右移一位后变成 101 ，转换为十进制也就是 <code>5</code>，所以基本可以把右移看成以下公式 <code>int v = a / (2 ^ b)</code></p></blockquote><p>右移很好用，比如可以用在二分算法中取中间值</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">13 &gt;&gt; 1 &#x2F;&#x2F; -&gt; 6</span><br></pre></td></tr></table></figure><p><strong>3. 按位操作</strong></p><p><strong>3.1 按位与</strong></p><blockquote><p>每一位都为 1，结果才为 <code>1</code></p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8 &amp; 7 &#x2F;&#x2F; -&gt; 0</span><br><span class="line">&#x2F;&#x2F; 1000 &amp; 0111 -&gt; 0000 -&gt; 0</span><br></pre></td></tr></table></figure><p><strong>3.2 按位或</strong></p><blockquote><p>其中一位为 <code>1</code>，结果就是 <code>1</code></p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8 | 7 &#x2F;&#x2F; -&gt; 15</span><br><span class="line">&#x2F;&#x2F; 1000 | 0111 -&gt; 1111 -&gt; 15</span><br></pre></td></tr></table></figure><p><strong>3.3 按位异或</strong></p><blockquote><p>每一位都不同，结果才为 <code>1</code></p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">8</span> ^ <span class="number">7</span> <span class="comment">// -&gt; 15</span></span><br><span class="line"><span class="number">8</span> ^ <span class="number">8</span> <span class="comment">// -&gt; 0</span></span><br><span class="line"><span class="comment">// 1000 ^ 0111 -&gt; 1111 -&gt; 15</span></span><br><span class="line"><span class="comment">// 1000 ^ 1000 -&gt; 0000 -&gt; 0</span></span><br></pre></td></tr></table></figure><ul><li>从以上代码中可以发现按位异或就是不进位加法</li><li>面试题：两个数不使用四则运算得出和</li></ul><blockquote><p>这道题中可以按位异或，因为按位异或就是不进位加法，<code>8 ^ 8 = 0</code> 如果进位了，就是 <code>16</code> 了，所以我们只需要将两个数进行异或操作，然后进位。那么也就是说两个二进制都是 <code>1</code> 的位置，左边应该有一个进位 <code>1</code>，所以可以得出以下公式 <code>a + b = (a ^ b) + ((a &amp; b) &lt;&lt; 1)</code>，然后通过迭代的方式模拟加法</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">return</span> b</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> a</span><br><span class="line">    <span class="keyword">let</span> newA = a ^ b</span><br><span class="line">    <span class="keyword">let</span> newB = (a &amp; b) &lt;&lt; <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> sum(newA, newB)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="36-2-排序"><a href="#36-2-排序" class="headerlink" title="36.2 排序"></a>36.2 排序</h3><blockquote><p>以下两个函数是排序中会用到的通用函数，就不一一写了</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkArray</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!array) <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">array, left, right</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> rightValue = array[right]</span><br><span class="line">    array[right] = array[left]</span><br><span class="line">    array[left] = rightValue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="36-2-1-冒泡排序"><a href="#36-2-1-冒泡排序" class="headerlink" title="36.2.1 冒泡排序"></a>36.2.1 冒泡排序</h4><blockquote><p>冒泡排序的原理如下，从第一个元素开始，把当前元素和下一个索引元素进行比较。如果当前元素大，那么就交换位置，重复操作直到比较到最后一个元素，那么此时最后一个元素就是该数组中最大的数。下一轮重复以上操作，但是此时最后一个元素已经是最大数了，所以不需要再比较最后一个元素，只需要比较到 <code>length - 1</code> 的位置。</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/4/12/162b895b452b306c" alt=""></p><p>以下是实现该算法的代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubble</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  checkArray(array);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = array.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="comment">// 从 0 到 `length - 1` 遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>]) swap(array, j, j + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>该算法的操作次数是一个等差数列 <code>n + (n - 1) + (n - 2) + 1</code> ，去掉常数项以后得出时间复杂度是 <code>O(n * n)</code></p></blockquote><h4 id="36-2-2-插入排序"><a href="#36-2-2-插入排序" class="headerlink" title="36.2.2 插入排序"></a>36.2.2 插入排序</h4><blockquote><p>插入排序的原理如下。第一个元素默认是已排序元素，取出下一个元素和当前元素比较，如果当前元素大就交换位置。那么此时第一个元素就是当前的最小数，所以下次取出操作从第三个元素开始，向前对比，重复之前的操作</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/4/12/162b895c7e59dcd1" alt=""></p><p>以下是实现该算法的代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertion</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  checkArray(array);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; array[j] &gt; array[j + <span class="number">1</span>]; j--)</span><br><span class="line">      swap(array, j, j + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>该算法的操作次数是一个等差数列 <code>n + (n - 1) + (n - 2) + 1</code> ，去掉常数项以后得出时间复杂度是 <code>O(n * n)</code></p></blockquote><h4 id="36-2-3-选择排序"><a href="#36-2-3-选择排序" class="headerlink" title="36.2.3 选择排序"></a>36.2.3 选择排序</h4><blockquote><p>选择排序的原理如下。遍历数组，设置最小值的索引为 0，如果取出的值比当前最小值小，就替换最小值索引，遍历完成后，将第一个元素和最小值索引上的值交换。如上操作后，第一个元素就是数组中的最小值，下次遍历就可以从索引 1 开始重复上述操作</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/4/13/162bc8ea14567e2e" alt=""></p><p>以下是实现该算法的代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selection</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  checkArray(array);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> minIndex = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; array.length; j++) &#123;</span><br><span class="line">      minIndex = array[j] &lt; array[minIndex] ? j : minIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(array, i, minIndex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>该算法的操作次数是一个等差数列<code>n + (n - 1) + (n - 2) + 1</code> ，去掉常数项以后得出时间复杂度是 <code>O(n * n)</code></p></blockquote><h4 id="36-2-4-归并排序"><a href="#36-2-4-归并排序" class="headerlink" title="36.2.4 归并排序"></a>36.2.4 归并排序</h4><blockquote><p>归并排序的原理如下。递归的将数组两两分开直到最多包含两个元素，然后将数组排序合并，最终合并为排序好的数组。假设我有一组数组 <code>[3, 1, 2, 8, 9, 7, 6]</code>，中间数索引是 <code>3</code>，先排序数组 <code>[3, 1, 2, 8]</code> 。在这个左边数组上，继续拆分直到变成数组包含两个元素（如果数组长度是奇数的话，会有一个拆分数组只包含一个元素）。然后排序数组 <code>[3, 1]</code> 和 <code>[2, 8]</code> ，然后再排序数组 <code>[1, 3, 2, 8]</code> ，这样左边数组就排序完成，然后按照以上思路排序右边数组，最后将数组 <code>[1, 2, 3, 8]</code> 和 <code>[6, 7, 9]</code> 排序</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/4/13/162be13c7e30bd86" alt=""></p><p>以下是实现该算法的代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  checkArray(array);</span><br><span class="line">  mergeSort(array, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">array, left, right</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 左右索引相同说明已经只有一个数</span></span><br><span class="line">  <span class="keyword">if</span> (left === right) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 等同于 `left + (right - left) / 2`</span></span><br><span class="line">  <span class="comment">// 相比 `(left + right) / 2` 来说更加安全，不会溢出</span></span><br><span class="line">  <span class="comment">// 使用位运算是因为位运算比四则运算快</span></span><br><span class="line">  <span class="keyword">let</span> mid = <span class="built_in">parseInt</span>(left + ((right - left) &gt;&gt; <span class="number">1</span>));</span><br><span class="line">  mergeSort(array, left, mid);</span><br><span class="line">  mergeSort(array, mid + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> help = [];</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> p1 = left;</span><br><span class="line">  <span class="keyword">let</span> p2 = mid + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= right) &#123;</span><br><span class="line">    help[i++] = array[p1] &lt; array[p2] ? array[p1++] : array[p2++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (p1 &lt;= mid) &#123;</span><br><span class="line">    help[i++] = array[p1++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (p2 &lt;= right) &#123;</span><br><span class="line">    help[i++] = array[p2++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; help.length; i++) &#123;</span><br><span class="line">    array[left + i] = help[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以上算法使用了递归的思想。递归的本质就是压栈，每递归执行一次函数，就将该函数的信息（比如参数，内部的变量，执行到的行数）压栈，直到遇到终止条件，然后出栈并继续执行函数。对于以上递归函数的调用轨迹如下</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mergeSort(data, <span class="number">0</span>, <span class="number">6</span>) <span class="comment">// mid = 3</span></span><br><span class="line">  mergeSort(data, <span class="number">0</span>, <span class="number">3</span>) <span class="comment">// mid = 1</span></span><br><span class="line">    mergeSort(data, <span class="number">0</span>, <span class="number">1</span>) <span class="comment">// mid = 0</span></span><br><span class="line">      mergeSort(data, <span class="number">0</span>, <span class="number">0</span>) <span class="comment">// 遇到终止，回退到上一步</span></span><br><span class="line">    mergeSort(data, <span class="number">1</span>, <span class="number">1</span>) <span class="comment">// 遇到终止，回退到上一步</span></span><br><span class="line">    <span class="comment">// 排序 p1 = 0, p2 = mid + 1 = 1</span></span><br><span class="line">    <span class="comment">// 回退到 `mergeSort(data, 0, 3)` 执行下一个递归</span></span><br><span class="line">  mergeSort(<span class="number">2</span>, <span class="number">3</span>) <span class="comment">// mid = 2</span></span><br><span class="line">    mergeSort(<span class="number">3</span>, <span class="number">3</span>) <span class="comment">// 遇到终止，回退到上一步</span></span><br><span class="line">  <span class="comment">// 排序 p1 = 2, p2 = mid + 1 = 3</span></span><br><span class="line">  <span class="comment">// 回退到 `mergeSort(data, 0, 3)` 执行合并逻辑</span></span><br><span class="line">  <span class="comment">// 排序 p1 = 0, p2 = mid + 1 = 2</span></span><br><span class="line">  <span class="comment">// 执行完毕回退</span></span><br><span class="line">  <span class="comment">// 左边数组排序完毕，右边也是如上轨迹</span></span><br></pre></td></tr></table></figure><blockquote><p>该算法的操作次数是可以这样计算：递归了两次，每次数据量是数组的一半，并且最后把整个数组迭代了一次，所以得出表达式 <code>2T(N / 2) + T(N)</code> （<code>T</code> 代表时间，<code>N</code> 代表数据量）。根据该表达式可以套用 该公式 得出时间复杂度为 <code>O(N * logN)</code></p></blockquote><h4 id="36-2-5-快排"><a href="#36-2-5-快排" class="headerlink" title="36.2.5 快排"></a>36.2.5 快排</h4><blockquote><p>快排的原理如下。随机选取一个数组中的值作为基准值，从左至右取值与基准值对比大小。比基准值小的放数组左边，大的放右边，对比完成后将基准值和第一个比基准值大的值交换位置。然后将数组以基准值的位置分为两部分，继续递归以上操作</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/4/16/162cd23e69ca9ea3" alt=""></p><p>以下是实现该算法的代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  checkArray(array);</span><br><span class="line">  quickSort(array, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">array, left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">    swap(array, , right)</span><br><span class="line">    <span class="comment">// 随机取值，然后和末尾交换，这样做比固定取一个位置的复杂度略低</span></span><br><span class="line">    <span class="keyword">let</span> indexs = part(array, <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * (right - left + <span class="number">1</span>)) + left, right);</span><br><span class="line">    quickSort(array, left, indexs[<span class="number">0</span>]);</span><br><span class="line">    quickSort(array, indexs[<span class="number">1</span>] + <span class="number">1</span>, right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">part</span>(<span class="params">array, left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> less = left - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> more = right;</span><br><span class="line">  <span class="keyword">while</span> (left &lt; more) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array[left] &lt; array[right]) &#123;</span><br><span class="line">      <span class="comment">// 当前值比基准值小，`less` 和 `left` 都加一</span></span><br><span class="line">   ++less;</span><br><span class="line">       ++left;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[left] &gt; array[right]) &#123;</span><br><span class="line">      <span class="comment">// 当前值比基准值大，将当前值和右边的值交换</span></span><br><span class="line">      <span class="comment">// 并且不改变 `left`，因为当前换过来的值还没有判断过大小</span></span><br><span class="line">      swap(array, --more, left);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 和基准值相同，只移动下标</span></span><br><span class="line">      left++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将基准值和比基准值大的第一个值交换位置</span></span><br><span class="line">  <span class="comment">// 这样数组就变成 `[比基准值小, 基准值, 比基准值大]`</span></span><br><span class="line">  swap(array, right, more);</span><br><span class="line">  <span class="keyword">return</span> [less, more];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>该算法的复杂度和归并排序是相同的，但是额外空间复杂度比归并排序少，只需 <code>O(logN)</code>，并且相比归并排序来说，所需的常数时间也更少</p></blockquote><p><strong>面试题</strong></p><blockquote><p>Sort Colors：该题目来自 LeetCode，题目需要我们将 <code>[2,0,2,1,1,0]</code>排序成 <code>[0,0,1,1,2,2]</code> ，这个问题就可以使用三路快排的思想。</p></blockquote><p>以下是代码实现</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sortColors = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">let</span> right = nums.length;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 下标如果遇到 right，说明已经排序完成</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt; right) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">      swap(nums, i++, ++left);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] == <span class="number">1</span>) &#123;</span><br><span class="line">      i++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      swap(nums, i, --right);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>Kth Largest Element in an Array：该题目来自 LeetCode，题目需要找出数组中第 K 大的元素，这问题也可以使用快排的思路。并且因为是找出第 K 大元素，所以在分离数组的过程中，可以找出需要的元素在哪边，然后只需要排序相应的一边数组就好。</p></blockquote><p>以下是代码实现</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> findKthLargest = <span class="function"><span class="keyword">function</span>(<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> l = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> r = nums.length - <span class="number">1</span></span><br><span class="line">  <span class="comment">// 得出第 K 大元素的索引位置</span></span><br><span class="line">  k = nums.length - k</span><br><span class="line">  <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">    <span class="comment">// 分离数组后获得比基准树大的第一个元素索引</span></span><br><span class="line">    <span class="keyword">let</span> index = part(nums, l, r)</span><br><span class="line">    <span class="comment">// 判断该索引和 k 的大小</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; k) &#123;</span><br><span class="line">      l = index + <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index &gt; k) &#123;</span><br><span class="line">      r = index - <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nums[k]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">part</span>(<span class="params">array, left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> less = left - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> more = right;</span><br><span class="line">  <span class="keyword">while</span> (left &lt; more) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array[left] &lt; array[right]) &#123;</span><br><span class="line">   ++less;</span><br><span class="line">       ++left;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[left] &gt; array[right]) &#123;</span><br><span class="line">      swap(array, --more, left);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      left++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  swap(array, right, more);</span><br><span class="line">  <span class="keyword">return</span> more;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="36-2-6-堆排序"><a href="#36-2-6-堆排序" class="headerlink" title="36.2.6 堆排序"></a>36.2.6 堆排序</h4><blockquote><p>堆排序利用了二叉堆的特性来做，二叉堆通常用数组表示，并且二叉堆是一颗完全二叉树（所有叶节点（最底层的节点）都是从左往右顺序排序，并且其他层的节点都是满的）。二叉堆又分为大根堆与小根堆</p></blockquote><ul><li>大根堆是某个节点的所有子节点的值都比他小</li><li>小根堆是某个节点的所有子节点的值都比他大</li></ul><blockquote><p>堆排序的原理就是组成一个大根堆或者小根堆。以小根堆为例，某个节点的左边子节点索引是 <code>i * 2 + 1</code>，右边是 <code>i * 2 + 2</code>，父节点是 <code>(i - 1) /2</code></p></blockquote><ol><li>首先遍历数组，判断该节点的父节点是否比他小，如果小就交换位置并继续判断，直到他的父节点比他大</li><li>重新以上操作 <code>1</code>，直到数组首位是最大值</li><li>然后将首位和末尾交换位置并将数组长度减一，表示数组末尾已是最大值，不需要再比较大小</li><li>对比左右节点哪个大，然后记住大的节点的索引并且和父节点对比大小，如果子节点大就交换位置</li><li>重复以上操作 <code>3 - 4</code> 直到整个数组都是大根堆。</li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/4/17/162d2a9ff258dfe1" alt=""></p><p>以下是实现该算法的代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">heap</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  checkArray(array);</span><br><span class="line">  <span class="comment">// 将最大值交换到首位</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">    heapInsert(array, i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> size = array.length;</span><br><span class="line">  <span class="comment">// 交换首位和末尾</span></span><br><span class="line">  swap(array, <span class="number">0</span>, --size);</span><br><span class="line">  <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    heapify(array, <span class="number">0</span>, size);</span><br><span class="line">    swap(array, <span class="number">0</span>, --size);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapInsert</span>(<span class="params">array, index</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果当前节点比父节点大，就交换</span></span><br><span class="line">  <span class="keyword">while</span> (array[index] &gt; array[<span class="built_in">parseInt</span>((index - <span class="number">1</span>) / <span class="number">2</span>)]) &#123;</span><br><span class="line">    swap(array, index, <span class="built_in">parseInt</span>((index - <span class="number">1</span>) / <span class="number">2</span>));</span><br><span class="line">    <span class="comment">// 将索引变成父节点</span></span><br><span class="line">    index = <span class="built_in">parseInt</span>((index - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapify</span>(<span class="params">array, index, size</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> left = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (left &lt; size) &#123;</span><br><span class="line">    <span class="comment">// 判断左右节点大小</span></span><br><span class="line">    <span class="keyword">let</span> largest =</span><br><span class="line">      left + <span class="number">1</span> &lt; size &amp;&amp; array[left] &lt; array[left + <span class="number">1</span>] ? left + <span class="number">1</span> : left;</span><br><span class="line">    <span class="comment">// 判断子节点和父节点大小</span></span><br><span class="line">    largest = array[index] &lt; array[largest] ? largest : index;</span><br><span class="line">    <span class="keyword">if</span> (largest === index) <span class="keyword">break</span>;</span><br><span class="line">    swap(array, index, largest);</span><br><span class="line">    index = largest;</span><br><span class="line">    left = index * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>以上代码实现了小根堆，如果需要实现大根堆，只需要把节点对比反一下就好。</li><li>该算法的复杂度是 <code>O(logN)</code></li></ul><h3 id="36-3-链表"><a href="#36-3-链表" class="headerlink" title="36.3 链表"></a>36.3 链表</h3><p><strong>反转单向链表</strong></p><blockquote><p>该题目来自 LeetCode，题目需要将一个单向链表反转。思路很简单，使用三个变量分别表示当前节点和当前节点的前后节点，虽然这题很简单，但是却是一道面试常考题</p></blockquote><p>以下是实现该算法的代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseList = <span class="function"><span class="keyword">function</span>(<span class="params">head</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判断下变量边界问题</span></span><br><span class="line">    <span class="keyword">if</span> (!head || !head.next) <span class="keyword">return</span> head</span><br><span class="line">    <span class="comment">// 初始设置为空，因为第一个节点反转后就是尾部，尾部节点指向 null</span></span><br><span class="line">    <span class="keyword">let</span> pre = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> current = head</span><br><span class="line">    <span class="keyword">let</span> next</span><br><span class="line">    <span class="comment">// 判断当前节点是否为空</span></span><br><span class="line">    <span class="comment">// 不为空就先获取当前节点的下一节点</span></span><br><span class="line">    <span class="comment">// 然后把当前节点的 next 设为上一个节点</span></span><br><span class="line">    <span class="comment">// 然后把 current 设为下一个节点，pre 设为当前节点</span></span><br><span class="line">    <span class="keyword">while</span>(current) &#123;</span><br><span class="line">        next = current.next</span><br><span class="line">        current.next = pre</span><br><span class="line">        pre = current</span><br><span class="line">        current = next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="36-4-树"><a href="#36-4-树" class="headerlink" title="36.4 树"></a>36.4 树</h3><p><strong>二叉树的先序，中序，后序遍历</strong></p><ul><li>先序遍历表示先访问根节点，然后访问左节点，最后访问右节点。</li><li>中序遍历表示先访问左节点，然后访问根节点，最后访问右节点。</li><li>后序遍历表示先访问左节点，然后访问右节点，最后访问根节点。</li></ul><p><strong>递归实现</strong></p><p>递归实现相当简单，代码如下</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TreeNode</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.val = val;</span><br><span class="line">  <span class="keyword">this</span>.left = <span class="keyword">this</span>.right = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> traversal = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root) &#123;</span><br><span class="line">    <span class="comment">// 先序</span></span><br><span class="line">    <span class="built_in">console</span>.log(root); </span><br><span class="line">    traversal(root.left);</span><br><span class="line">    <span class="comment">// 中序</span></span><br><span class="line">    <span class="comment">// console.log(root); </span></span><br><span class="line">    traversal(root.right);</span><br><span class="line">    <span class="comment">// 后序</span></span><br><span class="line">    <span class="comment">// console.log(root);</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>对于递归的实现来说，只需要理解每个节点都会被访问三次就明白为什么这样实现了。</p></blockquote><p><strong>非递归实现</strong></p><blockquote><p>非递归实现使用了栈的结构，通过栈的先进后出模拟递归实现。</p></blockquote><p>以下是先序遍历代码实现</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pre</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root) &#123;</span><br><span class="line">    <span class="keyword">let</span> stack = [];</span><br><span class="line">    <span class="comment">// 先将根节点 push</span></span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="comment">// 判断栈中是否为空</span></span><br><span class="line">    <span class="keyword">while</span> (stack.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 弹出栈顶元素</span></span><br><span class="line">      root = stack.pop();</span><br><span class="line">      <span class="built_in">console</span>.log(root);</span><br><span class="line">      <span class="comment">// 因为先序遍历是先左后右，栈是先进后出结构</span></span><br><span class="line">      <span class="comment">// 所以先 push 右边再 push 左边</span></span><br><span class="line">      <span class="keyword">if</span> (root.right) &#123;</span><br><span class="line">        stack.push(root.right);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (root.left) &#123;</span><br><span class="line">        stack.push(root.left);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是中序遍历代码实现</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mid</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root) &#123;</span><br><span class="line">    <span class="keyword">let</span> stack = [];</span><br><span class="line">    <span class="comment">// 中序遍历是先左再根最后右</span></span><br><span class="line">    <span class="comment">// 所以首先应该先把最左边节点遍历到底依次 push 进栈</span></span><br><span class="line">    <span class="comment">// 当左边没有节点时，就打印栈顶元素，然后寻找右节点</span></span><br><span class="line">    <span class="comment">// 对于最左边的叶节点来说，可以把它看成是两个 null 节点的父节点</span></span><br><span class="line">    <span class="comment">// 左边打印不出东西就把父节点拿出来打印，然后再看右节点</span></span><br><span class="line">    <span class="keyword">while</span> (stack.length &gt; <span class="number">0</span> || root) &#123;</span><br><span class="line">      <span class="keyword">if</span> (root) &#123;</span><br><span class="line">        stack.push(root);</span><br><span class="line">        root = root.left;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        root = stack.pop();</span><br><span class="line">        <span class="built_in">console</span>.log(root);</span><br><span class="line">        root = root.right;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以下是后序遍历代码实现，该代码使用了两个栈来实现遍历，相比一个栈的遍历来说要容易理解很多</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pos</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root) &#123;</span><br><span class="line">    <span class="keyword">let</span> stack1 = [];</span><br><span class="line">    <span class="keyword">let</span> stack2 = [];</span><br><span class="line">    <span class="comment">// 后序遍历是先左再右最后根</span></span><br><span class="line"><span class="comment">// 所以对于一个栈来说，应该先 push 根节点</span></span><br><span class="line">    <span class="comment">// 然后 push 右节点，最后 push 左节点</span></span><br><span class="line">    stack1.push(root);</span><br><span class="line">    <span class="keyword">while</span> (stack1.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      root = stack1.pop();</span><br><span class="line">      stack2.push(root);</span><br><span class="line">      <span class="keyword">if</span> (root.left) &#123;</span><br><span class="line">        stack1.push(root.left);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (root.right) &#123;</span><br><span class="line">        stack1.push(root.right);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (stack2.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(s2.pop());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>中序遍历的前驱后继节点</strong></p><blockquote><p>实现这个算法的前提是节点有一个 <code>parent</code> 的指针指向父节点，根节点指向 <code>null</code> 。</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/4/24/162f61ad8e8588b7" alt=""></p><blockquote><p>如图所示，该树的中序遍历结果是 <code>4, 2, 5, 1, 6, 3, 7</code></p></blockquote><p><strong>前驱节点</strong></p><blockquote><p>对于节点 2 来说，他的前驱节点就是 4 ，按照中序遍历原则，可以得出以下结论</p></blockquote><ol><li>如果选取的节点的左节点不为空，就找该左节点最右的节点。对于节点 1 来说，他有左节点 <code>2</code> ，那么节点 <code>2</code> 的最右节点就是 <code>5</code></li><li>如果左节点为空，且目标节点是父节点的右节点，那么前驱节点为父节点。对于节点 5 来说，没有左节点，且是节点 <code>2</code> 的右节点，所以节点 <code>2</code> 是前驱节点</li><li>如果左节点为空，且目标节点是父节点的左节点，向上寻找到第一个是父节点的右节点的节点。对于节点 <code>6</code> 来说，没有左节点，且是节点 <code>3</code> 的左节点，所以向上寻找到节点 <code>1</code> ，发现节点 <code>3</code> 是节点 <code>1</code> 的右节点，所以节点 <code>1</code> 是节点 <code>6</code> 的前驱节点</li></ol><p>以下是算法实现</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">predecessor</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span> </span><br><span class="line">  <span class="comment">// 结论 1</span></span><br><span class="line">  <span class="keyword">if</span> (node.left) &#123;</span><br><span class="line">    <span class="keyword">return</span> getRight(node.left)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> parent = node.parent</span><br><span class="line">    <span class="comment">// 结论 2 3 的判断</span></span><br><span class="line">    <span class="keyword">while</span>(parent &amp;&amp; parent.right === node) &#123;</span><br><span class="line">      node = parent</span><br><span class="line">      parent = node.parent</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parent</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRight</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span> </span><br><span class="line">  node = node.right</span><br><span class="line">  <span class="keyword">while</span>(node) node = node.right</span><br><span class="line">  <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>后继节点</strong></p><ul><li>对于节点 2 来说，他的后继节点就是 5 ，按照中序遍历原则，可以得出以下结论</li></ul><ol><li>如果有右节点，就找到该右节点的最左节点。对于节点 1 来说，他有右节点 3 ，那么节点 3 的最左节点就是 6</li><li>如果没有右节点，就向上遍历直到找到一个节点是父节点的左节点。对于节点 5 来说，没有右节点，就向上寻找到节点 2 ，该节点是父节点 1 的左节点，所以节点 1 是后继节点</li></ol><p>以下是算法实现</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">successor</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span> </span><br><span class="line">  <span class="comment">// 结论 1</span></span><br><span class="line">  <span class="keyword">if</span> (node.right) &#123;</span><br><span class="line">    <span class="keyword">return</span> getLeft(node.right)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 结论 2</span></span><br><span class="line">    <span class="keyword">let</span> parent = node.parent</span><br><span class="line">    <span class="comment">// 判断 parent 为空</span></span><br><span class="line">    <span class="keyword">while</span>(parent &amp;&amp; parent.left === node) &#123;</span><br><span class="line">      node = parent</span><br><span class="line">      parent = node.parent</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parent</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLeft</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!node) <span class="keyword">return</span> </span><br><span class="line">  node = node.left</span><br><span class="line">  <span class="keyword">while</span>(node) node = node.left</span><br><span class="line">  <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>树的深度</strong></p><blockquote><p>树的最大深度：该题目来自 Leetcode，题目需要求出一颗二叉树的最大深度</p></blockquote><p>以下是算法实现</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maxDepth = <span class="function"><span class="keyword">function</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span> </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>对于该递归函数可以这样理解：一旦没有找到节点就会返回 0，每弹出一次递归函数就会加一，树有三层就会得到3。</p></blockquote><h3 id="36-5-动态规划"><a href="#36-5-动态规划" class="headerlink" title="36.5 动态规划"></a>36.5 动态规划</h3><ul><li>动态规划背后的基本思想非常简单。就是将一个问题拆分为子问题，一般来说这些子问题都是非常相似的，那么我们可以通过只解决一次每个子问题来达到减少计算量的目的。</li><li>一旦得出每个子问题的解，就存储该结果以便下次使用。</li></ul><p><strong>斐波那契数列</strong></p><blockquote><p>斐波那契数列就是从 <code>0</code> 和 <code>1</code> 开始，后面的数都是前两个数之和</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0，1，1，2，3，5，8，13，21，34，55，89....</span><br></pre></td></tr></table></figure><blockquote><p>那么显然易见，我们可以通过递归的方式来完成求解斐波那契数列</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt; <span class="number">2</span> &amp;&amp; n &gt;= <span class="number">0</span>) <span class="keyword">return</span> n</span><br><span class="line">  <span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">fib(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><blockquote><p>以上代码已经可以完美的解决问题。但是以上解法却存在很严重的性能问题，当 <code>n</code> 越大的时候，需要的时间是指数增长的，这时候就可以通过动态规划来解决这个问题。</p></blockquote><p><strong>动态规划的本质其实就是两点</strong></p><ul><li>自底向上分解子问题</li><li>通过变量存储已经计算过的解</li></ul><p><strong>根据上面两点，我们的斐波那契数列的动态规划思路也就出来了</strong></p><ul><li>斐波那契数列从 <code>0</code> 和 <code>1</code> 开始，那么这就是这个子问题的最底层</li><li>通过数组来存储每一位所对应的斐波那契数列的值</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fib</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> array = <span class="keyword">new</span> <span class="built_in">Array</span>(n + <span class="number">1</span>).fill(<span class="literal">null</span>)</span><br><span class="line">  array[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">  array[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    array[i] = array[i - <span class="number">1</span>] + array[i - <span class="number">2</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array[n]</span><br><span class="line">&#125;</span><br><span class="line">fib(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p><strong>0 - 1背包问题</strong></p><blockquote><p>该问题可以描述为：给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。每个问题只能放入至多一次。</p></blockquote><p>假设我们有以下物品</p><table><thead><tr><th>物品 ID / 重量</th><th>价值</th></tr></thead><tbody><tr><td>1</td><td>3</td></tr><tr><td>2</td><td>7</td></tr><tr><td>3</td><td>12</td></tr></tbody></table><ul><li>对于一个总容量为 5 的背包来说，我们可以放入重量 2 和 3 的物品来达到背包内的物品总价值最高。</li><li>对于这个问题来说，子问题就两个，分别是放物品和不放物品，可以通过以下表格来理解子问题</li></ul><table><thead><tr><th>物品 ID / 剩余容量</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody><tr><td>1</td><td>0</td><td>3</td><td>3</td><td>3</td><td>3</td><td>3</td></tr><tr><td>2</td><td>0</td><td>3</td><td>7</td><td>10</td><td>10</td><td>10</td></tr><tr><td>3</td><td>0</td><td>3</td><td>7</td><td>12</td><td>15</td><td>19</td></tr></tbody></table><blockquote><p>直接来分析能放三种物品的情况，也就是最后一行</p></blockquote><ul><li>当容量少于 3 时，只取上一行对应的数据，因为当前容量不能容纳物品 3</li><li>当容量 为 3 时，考虑两种情况，分别为放入物品 3 和不放物品 3<ul><li>不放物品 3 的情况下，总价值为 10</li><li>放入物品 3 的情况下，总价值为 12，所以应该放入物品 3</li></ul></li><li>当容量 为 4 时，考虑两种情况，分别为放入物品 3 和不放物品 3<ul><li>不放物品 3 的情况下，总价值为 10</li><li>放入物品 3 的情况下，和放入物品 1 的价值相加，得出总价值为 15，所以应该放入物品 3</li></ul></li><li>当容量 为 5 时，考虑两种情况，分别为放入物品 3 和不放物品 3<ul><li>不放物品 3 的情况下，总价值为 10</li><li>放入物品 3 的情况下，和放入物品 2 的价值相加，得出总价值为 19，所以应该放入物品 3</li></ul></li></ul><p>以下代码对照上表更容易理解</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>w 物品重量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>v 物品价值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>C 总容量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">knapsack</span>(<span class="params">w, v, C</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> length = w.length</span><br><span class="line">  <span class="keyword">if</span> (length === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对照表格，生成的二维数组，第一维代表物品，第二维代表背包剩余容量</span></span><br><span class="line">  <span class="comment">// 第二维中的元素代表背包物品总价值</span></span><br><span class="line">  <span class="keyword">let</span> array = <span class="keyword">new</span> <span class="built_in">Array</span>(length).fill(<span class="keyword">new</span> <span class="built_in">Array</span>(C + <span class="number">1</span>).fill(<span class="literal">null</span>))</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 完成底部子问题的解</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= C; i++) &#123;</span><br><span class="line">    <span class="comment">// 对照表格第一行， array[0] 代表物品 1</span></span><br><span class="line">    <span class="comment">// i 代表剩余总容量</span></span><br><span class="line">    <span class="comment">// 当剩余总容量大于物品 1 的重量时，记录下背包物品总价值，否则价值为 0</span></span><br><span class="line">    array[<span class="number">0</span>][i] = i &gt;= w[<span class="number">0</span>] ? v[<span class="number">0</span>] : <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 自底向上开始解决子问题，从物品 2 开始</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt;= C; j++) &#123;</span><br><span class="line">      <span class="comment">// 这里求解子问题，分别为不放当前物品和放当前物品</span></span><br><span class="line">      <span class="comment">// 先求不放当前物品的背包总价值，这里的值也就是对应表格中上一行对应的值</span></span><br><span class="line">      array[i][j] = array[i - <span class="number">1</span>][j]</span><br><span class="line">      <span class="comment">// 判断当前剩余容量是否可以放入当前物品</span></span><br><span class="line">      <span class="keyword">if</span> (j &gt;= w[i]) &#123;</span><br><span class="line">        <span class="comment">// 可以放入的话，就比大小</span></span><br><span class="line">        <span class="comment">// 放入当前物品和不放入当前物品，哪个背包总价值大</span></span><br><span class="line">        array[i][j] = <span class="built_in">Math</span>.max(array[i][j], v[i] + array[i - <span class="number">1</span>][j - w[i]])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> array[length - <span class="number">1</span>][C]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>最长递增子序列</strong></p><blockquote><p>最长递增子序列意思是在一组数字中，找出最长一串递增的数字，比如</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0, 3, 4, 17, 2, 8, 6, 10</span><br></pre></td></tr></table></figure><blockquote><p>对于以上这串数字来说，最长递增子序列就是 <code>0, 3, 4, 8, 10</code>，可以通过以下表格更清晰的理解</p></blockquote><table><thead><tr><th>数字</th><th>0</th><th>3</th><th>4</th><th>17</th><th>2</th><th>8</th><th>6</th><th>10</th></tr></thead><tbody><tr><td>长度</td><td>1</td><td>2</td><td>3</td><td>4</td><td>2</td><td>4    4</td><td>5</td><td></td></tr></tbody></table><p>通过以上表格可以很清晰的发现一个规律，找出刚好比当前数字小的数，并且在小的数组成的长度基础上加一。</p><p>这个问题的动态思路解法很简单，直接上代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lis</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n.length === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  <span class="comment">// 创建一个和参数相同大小的数组，并填充值为 1</span></span><br><span class="line">  <span class="keyword">let</span> array = <span class="keyword">new</span> <span class="built_in">Array</span>(n.length).fill(<span class="number">1</span>)</span><br><span class="line">  <span class="comment">// 从索引 1 开始遍历，因为数组已经所有都填充为 1 了</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; n.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 从索引 0 遍历到 i</span></span><br><span class="line">    <span class="comment">// 判断索引 i 上的值是否大于之前的值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (n[i] &gt; n[j]) &#123;</span><br><span class="line">        array[i] = <span class="built_in">Math</span>.max(array[i], <span class="number">1</span> + array[j])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> res = <span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">    res = <span class="built_in">Math</span>.max(res, array[i])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="37-css常考面试题解析"><a href="#37-css常考面试题解析" class="headerlink" title="37 css常考面试题解析"></a>37 css常考面试题解析</h2><ul><li><a href="https://segmentfault.com/a/1190000013325778" target="_blank" rel="noopener">50道CSS基础面试题（附答案）</a></li><li><a href="https://segmentfault.com/a/1190000013860482" target="_blank" rel="noopener">《50道CSS基础面试题（附答案）》中的答案真的就只是答案吗？</a></li><li><a href="https://funteas.com/topic/5ada8eac230d1e5e25e45b89" target="_blank" rel="noopener">CSS 面试题总结</a></li><li><a href="https://github.com/yangshun/front-end-interview-handbook/blob/master/Translations/Chinese/questions/css-questions.md" target="_blank" rel="noopener">前端开发者面试问题 - CSS 部分</a></li></ul><script>export default {  mounted () {    var script = document.createElement("script");    script.type = "text/javascript"    script.charset="UTF-8"    script.src = "http://tajs.qq.com/stats?sId=59154049"    document.body.appendChild(script);  }}</script>]]></content>
      
      
      <categories>
          
          <category> 资料整理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>React基础知识点</title>
      <link href="/2017/06/20/React%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2017/06/20/React%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h5 id="React基础知识点"><a href="#React基础知识点" class="headerlink" title="React基础知识点"></a>React基础知识点</h5><p>React资料整理</p><a id="more"></a><h3 id="1-React-中-keys-的作用是什么？"><a href="#1-React-中-keys-的作用是什么？" class="headerlink" title="1 React 中 keys 的作用是什么？"></a>1 React 中 keys 的作用是什么？</h3><blockquote><p><code>Keys</code>是 <code>React</code> 用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识</p></blockquote><ul><li>在开发过程中，我们需要保证某个元素的 <code>key</code> 在其同级元素中具有唯一性。在 <code>React Diff</code> 算法中<code>React</code> 会借助元素的 <code>Key</code> 值来判断该元素是新近创建的还是被移动而来的元素，从而减少不必要的元素重渲染。此外，React 还需要借助 <code>Key</code> 值来判断元素与本地状态的关联关系，因此我们绝不可忽视转换函数中 <code>Key</code> 的重要性</li></ul><h3 id="2-传入-setState-函数的第二个参数的作用是什么？"><a href="#2-传入-setState-函数的第二个参数的作用是什么？" class="headerlink" title="2 传入 setState 函数的第二个参数的作用是什么？"></a>2 传入 setState 函数的第二个参数的作用是什么？</h3><blockquote><p>该函数会在<code>setState</code>函数调用完成并且组件开始重渲染的时候被调用，我们可以用该函数来监听渲染是否完成：</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(</span><br><span class="line">  &#123; <span class="attr">username</span>: <span class="string">'tylermcginnis33'</span> &#125;,</span><br><span class="line">  () =&gt; <span class="built_in">console</span>.log(<span class="string">'setState has finished and the component has re-rendered.'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState, props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    streak: prevState.streak + props.count</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="3-React-中-refs-的作用是什么"><a href="#3-React-中-refs-的作用是什么" class="headerlink" title="3 React 中 refs 的作用是什么"></a>3 React 中 refs 的作用是什么</h3><ul><li><code>Refs</code> 是 <code>React</code> 提供给我们的安全访问 <code>DOM</code>元素或者某个组件实例的句柄</li><li>可以为元素添加<code>ref</code>属性然后在回调函数中接受该元素在 <code>DOM</code> 树中的句柄，该值会作为回调函数的第一个参数返回</li></ul><h3 id="4-在生命周期中的哪一步你应该发起-AJAX-请求"><a href="#4-在生命周期中的哪一步你应该发起-AJAX-请求" class="headerlink" title="4 在生命周期中的哪一步你应该发起 AJAX 请求"></a>4 在生命周期中的哪一步你应该发起 AJAX 请求</h3><blockquote><p>我们应当将AJAX 请求放到 <code>componentDidMount</code> 函数中执行，主要原因有下</p></blockquote><ul><li><code>React</code> 下一代调和算法 <code>Fiber</code> 会通过开始或停止渲染的方式优化应用性能，其会影响到 <code>componentWillMount</code> 的触发次数。对于 <code>componentWillMount</code> 这个生命周期函数的调用次数会变得不确定，<code>React</code> 可能会多次频繁调用 <code>componentWillMount</code>。如果我们将 <code>AJAX</code> 请求放到 <code>componentWillMount</code> 函数中，那么显而易见其会被触发多次，自然也就不是好的选择。</li><li>如果我们将<code>AJAX</code> 请求放置在生命周期的其他函数中，我们并不能保证请求仅在组件挂载完毕后才会要求响应。如果我们的数据请求在组件挂载之前就完成，并且调用了<code>setState</code>函数将数据添加到组件状态中，对于未挂载的组件则会报错。而在 <code>componentDidMount</code> 函数中进行 <code>AJAX</code> 请求则能有效避免这个问题</li></ul><h3 id="5-shouldComponentUpdate-的作用"><a href="#5-shouldComponentUpdate-的作用" class="headerlink" title="5 shouldComponentUpdate 的作用"></a>5 shouldComponentUpdate 的作用</h3><blockquote><p><code>shouldComponentUpdate</code> 允许我们手动地判断是否要进行组件更新，根据组件的应用场景设置函数的合理返回值能够帮我们避免不必要的更新</p></blockquote><h3 id="6-如何告诉-React-它应该编译生产环境版"><a href="#6-如何告诉-React-它应该编译生产环境版" class="headerlink" title="6 如何告诉 React 它应该编译生产环境版"></a>6 如何告诉 React 它应该编译生产环境版</h3><blockquote><p>通常情况下我们会使用 <code>Webpack</code> 的 <code>DefinePlugin</code> 方法来将 <code>NODE_ENV</code> 变量值设置为 <code>production</code>。编译版本中 <code>React</code>会忽略 <code>propType</code> 验证以及其他的告警信息，同时还会降低代码库的大小，<code>React</code> 使用了 <code>Uglify</code> 插件来移除生产环境下不必要的注释等信息</p></blockquote><h3 id="7-概述下-React-中的事件处理逻辑"><a href="#7-概述下-React-中的事件处理逻辑" class="headerlink" title="7 概述下 React 中的事件处理逻辑"></a>7 概述下 React 中的事件处理逻辑</h3><blockquote><p>为了解决跨浏览器兼容性问题，<code>React</code> 会将浏览器原生事件（<code>Browser Native Event</code>）封装为合成事件（<code>SyntheticEvent</code>）传入设置的事件处理器中。这里的合成事件提供了与原生事件相同的接口，不过它们屏蔽了底层浏览器的细节差异，保证了行为的一致性。另外有意思的是，<code>React</code> 并没有直接将事件附着到子元素上，而是以单一事件监听器的方式将所有的事件发送到顶层进行处理。这样 <code>React</code> 在更新 <code>DOM</code> 的时候就不需要考虑如何去处理附着在 <code>DOM</code> 上的事件监听器，最终达到优化性能的目的</p></blockquote><h3 id="8-createElement-与-cloneElement-的区别是什么"><a href="#8-createElement-与-cloneElement-的区别是什么" class="headerlink" title="8 createElement 与 cloneElement 的区别是什么"></a>8 createElement 与 cloneElement 的区别是什么</h3><blockquote><p><code>createElement</code> 函数是 JSX 编译之后使用的创建 <code>React Element</code> 的函数，而 <code>cloneElement</code> 则是用于复制某个元素并传入新的 <code>Props</code></p></blockquote><h3 id="9-redux中间件"><a href="#9-redux中间件" class="headerlink" title="9 redux中间件"></a>9 redux中间件</h3><blockquote><p>中间件提供第三方插件的模式，自定义拦截 <code>action</code> -&gt; <code>reducer</code> 的过程。变为 <code>action</code> -&gt; <code>middlewares</code> -&gt; <code>reducer</code>。这种机制可以让我们改变数据流，实现如异步<code>action</code> ，<code>action</code> 过滤，日志输出，异常报告等功能</p></blockquote><ul><li><code>redux-logger</code>：提供日志输出</li><li><code>redux-thunk</code>：处理异步操作</li><li><code>redux-promise</code>：处理异步操作，<code>actionCreator</code>的返回值是<code>promise</code></li></ul><h3 id="10-redux有什么缺点"><a href="#10-redux有什么缺点" class="headerlink" title="10 redux有什么缺点"></a>10 redux有什么缺点</h3><ul><li>一个组件所需要的数据，必须由父组件传过来，而不能像<code>flux</code>中直接从<code>store</code>取。</li><li>当一个组件相关数据更新时，即使父组件不需要用到这个组件，父组件还是会重新<code>render</code>，可能会有效率影响，或者需要写复杂的<code>shouldComponentUpdate</code>进行判断。</li></ul><h3 id="11-react组件的划分业务组件技术组件？"><a href="#11-react组件的划分业务组件技术组件？" class="headerlink" title="11 react组件的划分业务组件技术组件？"></a>11 react组件的划分业务组件技术组件？</h3><ul><li>根据组件的职责通常把组件分为UI组件和容器组件。</li><li>UI 组件负责 UI 的呈现，容器组件负责管理数据和逻辑。</li><li>两者通过<code>React-Redux</code> 提供<code>connect</code>方法联系起来</li></ul><h3 id="12-react生命周期函数"><a href="#12-react生命周期函数" class="headerlink" title="12 react生命周期函数"></a>12 react生命周期函数</h3><p><strong>初始化阶段</strong></p><ul><li><code>getDefaultProps</code>:获取实例的默认属性</li><li><code>getInitialState</code>:获取每个实例的初始化状态</li><li><code>componentWillMount</code>：组件即将被装载、渲染到页面上</li><li><code>render</code>:组件在这里生成虚拟的<code>DOM</code>节点</li><li><code>omponentDidMount</code>:组件真正在被装载之后</li></ul><p><strong>运行中状态</strong></p><ul><li><code>componentWillReceiveProps</code>:组件将要接收到属性的时候调用</li><li><code>shouldComponentUpdate</code>:组件接受到新属性或者新状态的时候（可以返回false，接收数据后不更新，阻止<code>render</code>调用，后面的函数不会被继续执行了）</li><li><code>componentWillUpdate</code>:组件即将更新不能修改属性和状态</li><li><code>render</code>:组件重新描绘</li><li><code>componentDidUpdate</code>:组件已经更新</li></ul><p><strong>销毁阶段</strong></p><ul><li><code>componentWillUnmount</code>:组件即将销毁</li></ul><h3 id="13-react性能优化是哪个周期函数"><a href="#13-react性能优化是哪个周期函数" class="headerlink" title="13 react性能优化是哪个周期函数"></a>13 react性能优化是哪个周期函数</h3><blockquote><p><code>shouldComponentUpdate</code> 这个方法用来判断是否需要调用render方法重新描绘dom。因为dom的描绘非常消耗性能，如果我们能在<code>shouldComponentUpdate方</code>法中能够写出更优化的<code>dom diff</code>算法，可以极大的提高性能</p></blockquote><h3 id="14-为什么虚拟dom会提高性能"><a href="#14-为什么虚拟dom会提高性能" class="headerlink" title="14 为什么虚拟dom会提高性能"></a>14 为什么虚拟dom会提高性能</h3><blockquote><p>虚拟<code>dom</code>相当于在<code>js</code>和真实<code>dom</code>中间加了一个缓存，利用<code>dom diff</code>算法避免了没有必要的<code>dom</code>操作，从而提高性能</p></blockquote><p><strong>具体实现步骤如下</strong></p><ul><li>用 <code>JavaScript</code> 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 <code>DOM</code> 树，插到文档当中</li><li>当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异</li><li>把2所记录的差异应用到步骤1所构建的真正的<code>DOM</code>树上，视图就更新</li></ul><h3 id="15-diff算法"><a href="#15-diff算法" class="headerlink" title="15 diff算法?"></a>15 diff算法?</h3><ul><li>把树形结构按照层级分解，只比较同级元素。</li><li>给列表结构的每个单元添加唯一的<code>key</code>属性，方便比较。</li><li><code>React</code> 只会匹配相同 <code>class</code> 的 <code>component</code>（这里面的<code>class</code>指的是组件的名字）</li><li>合并操作，调用 <code>component</code> 的 <code>setState</code> 方法的时候, <code>React</code> 将其标记为 - <code>dirty</code>.到每一个事件循环结束, <code>React</code> 检查所有标记 <code>dirty</code>的 <code>component</code>重新绘制.</li><li>选择性子树渲染。开发人员可以重写<code>shouldComponentUpdate</code>提高<code>diff</code>的性能</li></ul><h3 id="16-react性能优化方案"><a href="#16-react性能优化方案" class="headerlink" title="16 react性能优化方案"></a>16 react性能优化方案</h3><ul><li>重写<code>shouldComponentUpdate</code>来避免不必要的dom操作</li><li>使用 <code>production</code> 版本的<code>react.js</code></li><li>使用<code>key</code>来帮助<code>React</code>识别列表中所有子组件的最小变化</li></ul><h3 id="16-简述flux-思想"><a href="#16-简述flux-思想" class="headerlink" title="16 简述flux 思想"></a>16 简述flux 思想</h3><blockquote><p><code>Flux</code> 的最大特点，就是数据的”单向流动”。</p></blockquote><ul><li>用户访问 <code>View</code></li><li><code>View</code>发出用户的 <code>Action</code></li><li><code>Dispatcher</code> 收到<code>Action</code>，要求 <code>Store</code> 进行相应的更新</li><li><code>Store</code> 更新后，发出一个<code>&quot;change&quot;</code>事件</li><li><code>View</code> 收到<code>&quot;change&quot;</code>事件后，更新页面</li></ul><h3 id="17-说说你用react有什么坑点？"><a href="#17-说说你用react有什么坑点？" class="headerlink" title="17 说说你用react有什么坑点？"></a>17 说说你用react有什么坑点？</h3><p><strong>1. JSX做表达式判断时候，需要强转为boolean类型</strong></p><blockquote><p>如果不使用 <code>!!b</code> 进行强转数据类型，会在页面里面输出 <code>0</code>。</p></blockquote><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">const</span> b = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    &#123;</span></span><br><span class="line"><span class="xml">      !!b &amp;&amp; <span class="tag">&lt;<span class="name">div</span>&gt;</span>这是一段文本<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 尽量不要在 componentWillReviceProps 里使用 setState，如果一定要使用，那么需要判断结束条件，不然会出现无限重渲染，导致页面崩溃</strong></p><p><strong>3. 给组件添加ref时候，尽量不要使用匿名函数，因为当组件更新的时候，匿名函数会被当做新的prop处理，让ref属性接受到新函数的时候，react内部会先清空ref，也就是会以null为回调参数先执行一次ref这个props，然后在以该组件的实例执行一次ref，所以用匿名函数做ref的时候，有的时候去ref赋值后的属性会取到null</strong></p><p><strong>4. 遍历子节点的时候，不要用 index 作为组件的 key 进行传入</strong></p><h3 id="18-我现在有一个button，要用react在上面绑定点击事件，要怎么做？"><a href="#18-我现在有一个button，要用react在上面绑定点击事件，要怎么做？" class="headerlink" title="18  我现在有一个button，要用react在上面绑定点击事件，要怎么做？"></a>18  我现在有一个button，要用react在上面绑定点击事件，要怎么做？</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;(e)</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="xml">      alert('我点击了按钮')</span></span><br><span class="line"><span class="xml">    &#125;&#125;&gt;</span></span><br><span class="line"><span class="xml">      按钮</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>你觉得你这样设置点击事件会有什么问题吗？</strong></p><blockquote><p>由于<code>onClick</code>使用的是匿名函数，所有每次重渲染的时候，会把该<code>onClick</code>当做一个新的<code>prop</code>来处理，会将内部缓存的<code>onClick</code>事件进行重新赋值，所以相对直接使用函数来说，可能有一点的性能下降</p></blockquote><p>修改</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  onClick = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    alert(<span class="string">'我点击了按钮'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.onClick&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      按钮</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="19-react-的虚拟dom是怎么实现的"><a href="#19-react-的虚拟dom是怎么实现的" class="headerlink" title="19 react 的虚拟dom是怎么实现的"></a>19 react 的虚拟dom是怎么实现的</h3><blockquote><p>首先说说为什么要使用<code>Virturl DOM</code>，因为操作真实<code>DOM</code>的耗费的性能代价太高，所以<code>react</code>内部使用<code>js</code>实现了一套dom结构，在每次操作在和真实dom之前，使用实现好的diff算法，对虚拟dom进行比较，递归找出有变化的dom节点，然后对其进行更新操作。为了实现虚拟<code>DOM</code>，我们需要把每一种节点类型抽象成对象，每一种节点类型有自己的属性，也就是prop，每次进行<code>diff</code>的时候，<code>react</code>会先比较该节点类型，假如节点类型不一样，那么<code>react</code>会直接删除该节点，然后直接创建新的节点插入到其中，假如节点类型一样，那么会比较<code>prop</code>是否有更新，假如有<code>prop</code>不一样，那么<code>react</code>会判定该节点有更新，那么重渲染该节点，然后在对其子节点进行比较，一层一层往下，直到没有子节点</p></blockquote><h3 id="20-react-的渲染过程中，兄弟节点之间是怎么处理的？也就是key值不一样的时候"><a href="#20-react-的渲染过程中，兄弟节点之间是怎么处理的？也就是key值不一样的时候" class="headerlink" title="20 react 的渲染过程中，兄弟节点之间是怎么处理的？也就是key值不一样的时候"></a>20 react 的渲染过程中，兄弟节点之间是怎么处理的？也就是key值不一样的时候</h3><blockquote><p>通常我们输出节点的时候都是map一个数组然后返回一个<code>ReactNode</code>，为了方便<code>react</code>内部进行优化，我们必须给每一个<code>reactNode</code>添加<code>key</code>，这个<code>key prop</code>在设计值处不是给开发者用的，而是给react用的，大概的作用就是给每一个<code>reactNode</code>添加一个身份标识，方便react进行识别，在重渲染过程中，如果key一样，若组件属性有所变化，则<code>react</code>只更新组件对应的属性；没有变化则不更新，如果key不一样，则react先销毁该组件，然后重新创建该组件</p></blockquote><h3 id="21-那给我介绍一下react"><a href="#21-那给我介绍一下react" class="headerlink" title="21 那给我介绍一下react"></a>21 那给我介绍一下react</h3><ol><li>以前我们没有jquery的时候，我们大概的流程是从后端通过ajax获取到数据然后使用jquery生成dom结果然后更新到页面当中，但是随着业务发展，我们的项目可能会越来越复杂，我们每次请求到数据，或则数据有更改的时候，我们又需要重新组装一次dom结构，然后更新页面，这样我们手动同步dom和数据的成本就越来越高，而且频繁的操作dom，也使我我们页面的性能慢慢的降低。</li><li>这个时候mvvm出现了，mvvm的双向数据绑定可以让我们在数据修改的同时同步dom的更新，dom的更新也可以直接同步我们数据的更改，这个特定可以大大降低我们手动去维护dom更新的成本，mvvm为react的特性之一，虽然react属于单项数据流，需要我们手动实现双向数据绑定。</li><li>有了mvvm还不够，因为如果每次有数据做了更改，然后我们都全量更新dom结构的话，也没办法解决我们频繁操作dom结构(降低了页面性能)的问题，为了解决这个问题，react内部实现了一套虚拟dom结构，也就是用js实现的一套dom结构，他的作用是讲真实dom在js中做一套缓存，每次有数据更改的时候，react内部先使用算法，也就是鼎鼎有名的diff算法对dom结构进行对比，找到那些我们需要新增、更新、删除的dom节点，然后一次性对真实DOM进行更新，这样就大大降低了操作dom的次数。<br>那么diff算法是怎么运作的呢，首先，diff针对类型不同的节点，会直接判定原来节点需要卸载并且用新的节点来装载卸载的节点的位置；针对于节点类型相同的节点，会对比这个节点的所有属性，如果节点的所有属性相同，那么判定这个节点不需要更新，如果节点属性不相同，那么会判定这个节点需要更新，react会更新并重渲染这个节点。</li><li>react设计之初是主要负责UI层的渲染，虽然每个组件有自己的state，state表示组件的状态，当状态需要变化的时候，需要使用setState更新我们的组件，但是，我们想通过一个组件重渲染它的兄弟组件，我们就需要将组件的状态提升到父组件当中，让父组件的状态来控制这两个组件的重渲染，当我们组件的层次越来越深的时候，状态需要一直往下传，无疑加大了我们代码的复杂度，我们需要一个状态管理中心，来帮我们管理我们状态state。</li><li>这个时候，redux出现了，我们可以将所有的state交给redux去管理，当我们的某一个state有变化的时候，依赖到这个state的组件就会进行一次重渲染，这样就解决了我们的我们需要一直把state往下传的问题。redux有action、reducer的概念，action为唯一修改state的来源，reducer为唯一确定state如何变化的入口，这使得redux的数据流非常规范，同时也暴露出了redux代码的复杂，本来那么简单的功能，却需要完成那么多的代码。</li><li>后来，社区就出现了另外一套解决方案，也就是mobx，它推崇代码简约易懂，只需要定义一个可观测的对象，然后哪个组价使用到这个可观测的对象，并且这个对象的数据有更改，那么这个组件就会重渲染，而且mobx内部也做好了是否重渲染组件的生命周期shouldUpdateComponent，不建议开发者进行更改，这使得我们使用mobx开发项目的时候可以简单快速的完成很多功能，连redux的作者也推荐使用mobx进行项目开发。但是，随着项目的不断变大，mobx也不断暴露出了它的缺点，就是数据流太随意，出了bug之后不好追溯数据的流向，这个缺点正好体现出了redux的优点所在，所以针对于小项目来说，社区推荐使用mobx，对大项目推荐使用redux</li></ol>]]></content>
      
      
      <categories>
          
          <category> 资料整理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>前端知识 - 栈和队列</title>
      <link href="/2017/06/05/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%20-%20%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
      <url>/2017/06/05/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%20-%20%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h5 id="前端知识-栈和队列"><a href="#前端知识-栈和队列" class="headerlink" title="前端知识 - 栈和队列"></a>前端知识 - 栈和队列</h5><p>资料整理</p><a id="more"></a><p><strong>栈和队列的区别?</strong></p><ul><li>栈的插入和删除操作都是在一端进行的，而队列的操作却是在两端进行的。</li><li>队列先进先出，栈先进后出。</li><li>栈只允许在表尾一端进行插入和删除，而队列只允许在表尾一端进行插入，在表头一端进行删除</li></ul><p><strong>栈和堆的区别？</strong></p><ul><li>栈区（stack）—   由编译器自动分配释放   ，存放函数的参数值，局部变量的值等。</li><li>堆区（heap）   —   一般由程序员分配释放，   若程序员不释放，程序结束时可能由OS回收。</li><li>堆（数据结构）：堆可以被看成是一棵树，如：堆排序；</li><li>栈（数据结构）：一种先进后出的数据结构</li></ul><p><strong>快速 排序的思想并实现一个快排？</strong></p><p>“快速排序”的思想很简单，整个排序过程只需要三步：</p><ul><li>（1）在数据集之中，找一个基准点</li><li>（2）建立两个数组，分别存储左边和右边的数组</li><li>（3）利用递归进行下次比较</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.length&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> arr;<span class="comment">//如果数组只有一个数，就直接返回；</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> num = <span class="built_in">Math</span>.floor(arr.length/<span class="number">2</span>);<span class="comment">//找到中间数的索引值，如果是浮点数，则向下取整</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> numValue = arr.splice(num,<span class="number">1</span>);<span class="comment">//找到中间数的值</span></span><br><span class="line">    <span class="keyword">var</span> left = [];</span><br><span class="line">    <span class="keyword">var</span> right = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]&lt;numValue)&#123;</span><br><span class="line">            left.push(arr[i]);<span class="comment">//基准点的左边的数传到左边数组</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">           right.push(arr[i]);<span class="comment">//基准点的右边的数传到右边数组</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> quickSort(left).concat([numValue],quickSort(right));<span class="comment">//递归不断重复比较</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(quickSort([<span class="number">32</span>,<span class="number">45</span>,<span class="number">37</span>,<span class="number">16</span>,<span class="number">2</span>,<span class="number">87</span>]));<span class="comment">//弹出“2,16,32,37,45,87”</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 小知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>前端基础 - 精简版</title>
      <link href="/2017/05/12/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%20-%20%E7%B2%BE%E7%AE%80%E7%89%88/"/>
      <url>/2017/05/12/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%20-%20%E7%B2%BE%E7%AE%80%E7%89%88/</url>
      
        <content type="html"><![CDATA[<h5 id="前端基础-精简版"><a href="#前端基础-精简版" class="headerlink" title="前端基础 - 精简版"></a>前端基础 - 精简版</h5><p>资料整理</p><a id="more"></a><h2 id="一、CSS相关"><a href="#一、CSS相关" class="headerlink" title="一、CSS相关"></a>一、CSS相关</h2><h3 id="1-1-左边定宽，右边自适应方案：float-margin，float-calc"><a href="#1-1-左边定宽，右边自适应方案：float-margin，float-calc" class="headerlink" title="1.1 左边定宽，右边自适应方案：float + margin，float + calc"></a>1.1 左边定宽，右边自适应方案：float + margin，float + calc</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 方案1 */</span> </span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">120px</span>;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">120px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 方案2 */</span> </span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">120px</span>;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="built_in">calc</span>(<span class="number">100%</span> - <span class="number">120px</span>);</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-左右两边定宽，中间自适应：float，float-calc-圣杯布局（设置BFC，margin负值法），flex"><a href="#1-2-左右两边定宽，中间自适应：float，float-calc-圣杯布局（设置BFC，margin负值法），flex" class="headerlink" title="1.2 左右两边定宽，中间自适应：float，float + calc, 圣杯布局（设置BFC，margin负值法），flex"></a>1.2 左右两边定宽，中间自适应：float，float + calc, 圣杯布局（设置BFC，margin负值法），flex</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrap</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.wrap</span> &gt; <span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 方案1 */</span></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">120px</span>;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">120px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">120px</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 方案2 */</span></span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">120px</span>;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">120px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="built_in">calc</span>(<span class="number">100%</span> - <span class="number">240px</span>);</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">120px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 方案3 */</span></span><br><span class="line"><span class="selector-class">.wrap</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">120px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">120px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-左右居中"><a href="#1-3-左右居中" class="headerlink" title="1.3 左右居中"></a>1.3 左右居中</h3><ul><li>行内元素: <code>text-align: center</code></li><li>定宽块状元素: 左右 <code>margin</code> 值为 <code>auto</code></li><li>不定宽块状元素: <code>table</code>布局，<code>position + transform</code></li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 方案1 */</span></span><br><span class="line"><span class="selector-class">.wrap</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline;</span><br><span class="line">  <span class="comment">/* or */</span></span><br><span class="line">  <span class="comment">/* display: inline-block; */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 方案2 */</span></span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 方案2 */</span></span><br><span class="line"><span class="selector-class">.wrap</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absulote;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateX</span>(-<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-上下垂直居中"><a href="#1-4-上下垂直居中" class="headerlink" title="1.4 上下垂直居中"></a>1.4 上下垂直居中</h3><ul><li>定高：<code>margin</code>，<code>position + margin</code>(负值)</li><li>不定高：<code>position</code> + <code>transform</code>，<code>flex</code>，<code>IFC + vertical-align:middle</code></li></ul><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 定高方案1 */</span></span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">50px</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 定高方案2 */</span></span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">margin-top</span>: -<span class="number">25px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 不定高方案1 */</span></span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 不定高方案2 */</span></span><br><span class="line"><span class="selector-class">.wrap</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 不定高方案3 */</span></span><br><span class="line"><span class="comment">/* 设置 inline-block 则会在外层产生 IFC，高度设为 100% 撑开 wrap 的高度 */</span></span><br><span class="line"><span class="selector-class">.wrap</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.wrap</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;  </span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-盒模型：content（元素内容）-padding（内边距）-border（边框）-margin（外边距）"><a href="#1-5-盒模型：content（元素内容）-padding（内边距）-border（边框）-margin（外边距）" class="headerlink" title="1.5 盒模型：content（元素内容） + padding（内边距） + border（边框） + margin（外边距）"></a>1.5 盒模型：content（元素内容） + padding（内边距） + border（边框） + margin（外边距）</h3><blockquote><p>延伸： <code>box-sizing</code></p></blockquote><ul><li><code>content-box</code>：默认值，总宽度 = <code>margin</code> + <code>border</code> + <code>padding</code> + <code>width</code></li><li><code>border-box</code>：盒子宽度包含 <code>padding</code> 和 <code>border</code>，<code>总宽度 = margin + width</code></li><li><code>inherit</code>：从父元素继承 <code>box-sizing</code> 属性</li></ul><h3 id="1-6-BFC、IFC、GFC、FFC：FC（Formatting-Contexts），格式化上下文"><a href="#1-6-BFC、IFC、GFC、FFC：FC（Formatting-Contexts），格式化上下文" class="headerlink" title="1.6 BFC、IFC、GFC、FFC：FC（Formatting Contexts），格式化上下文"></a>1.6 BFC、IFC、GFC、FFC：FC（Formatting Contexts），格式化上下文</h3><blockquote><p><code>BFC</code>：块级格式化上下文，容器里面的子元素不会在布局上影响到外面的元素，反之也是如此(按照这个理念来想，只要脱离文档流，肯定就能产生 <code>BFC</code>)。产生 <code>BFC</code> 方式如下</p></blockquote><ul><li><code>float</code> 的值不为 <code>none</code>。</li><li><code>overflow</code> 的值不为 <code>visible</code>。</li><li><code>position</code> 的值不为 <code>relative</code> 和 <code>static</code>。</li><li><code>display</code> 的值为 <code>table-cell</code>, <code>table-caption</code>, <code>inline-block</code>中的任何一个</li></ul><blockquote><p>用处？常见的多栏布局，结合块级别元素浮动，里面的元素则是在一个相对隔离的环境里运行</p></blockquote><blockquote><p><code>IFC</code>：内联格式化上下文，<code>IFC</code> 的 <code>line</code> <code>box</code>（线框）高度由其包含行内元素中最高的实际高度计算而来（不受到竖直方向的 <code>padding/margin</code> 影响)。</p></blockquote><blockquote><p><code>IFC</code>中的<code>line box</code>一般左右都贴紧整个 <code>IFC</code>，但是会因为 <code>float</code> 元素而扰乱。<code>float</code> 元素会位于 IFC 与 <code>line box</code> 之间，使得 <code>line box</code> 宽度缩短。 同个 <code>ifc</code> 下的多个 <code>line box</code> 高度会不同。 <code>IFC</code>中时不可能有块级元素的，当插入块级元素时（如 <code>p</code> 中插入 <code>div</code>）会产生两个匿名块与 <code>div</code> 分隔开，即产生两个 <code>IFC</code> ，每个 <code>IFC</code> 对外表现为块级元素，与 <code>div</code> 垂直排列。</p></blockquote><p>用处？</p><ul><li>水平居中：当一个块要在环境中水平居中时，设置其为 <code>inline-block</code> 则会在外层产生<code>IFC</code>，通过 <code>text-align</code> 则可以使其水平居中。</li><li>垂直居中：创建一个 <code>IFC</code>，用其中一个元素撑开父元素的高度，然后设置其 <code>vertical-align</code>: <code>middle</code>，其他行内元素则可以在此父元素下垂直居中</li></ul><blockquote><ul><li><strong>GFC</strong>：网格布局格式化上下文（<code>display: grid</code>）</li><li><strong>FFC</strong>：自适应格式化上下文（<code>display: flex</code>）</li></ul></blockquote><h2 id="二、JS-基础（ES5）"><a href="#二、JS-基础（ES5）" class="headerlink" title="二、JS 基础（ES5）"></a>二、JS 基础（ES5）</h2><h3 id="2-1-原型"><a href="#2-1-原型" class="headerlink" title="2.1 原型"></a>2.1 原型</h3><blockquote><p>这里可以谈很多，只要围绕 <code>[[ prototype ]]</code> 谈，都没啥问题</p></blockquote><h3 id="2-2-闭包"><a href="#2-2-闭包" class="headerlink" title="2.2 闭包"></a>2.2 闭包</h3><blockquote><p>牵扯作用域，可以两者联系起来一起谈</p></blockquote><h3 id="2-3-作用域"><a href="#2-3-作用域" class="headerlink" title="2.3 作用域"></a>2.3 作用域</h3><blockquote><p>词法作用域，动态作用域</p></blockquote><h3 id="2-4-this"><a href="#2-4-this" class="headerlink" title="2.4 this"></a>2.4 this</h3><blockquote><p>不同情况的调用，<code>this</code>指向分别如何。顺带可以提一下 <code>es6</code> 中箭头函数没有 <code>this</code>, <code>arguments</code>, <code>super</code> 等，这些只依赖包含箭头函数最接近的函数</p></blockquote><h3 id="2-5-call，apply，bind-三者用法和区别"><a href="#2-5-call，apply，bind-三者用法和区别" class="headerlink" title="2.5 call，apply，bind 三者用法和区别"></a>2.5 call，apply，bind 三者用法和区别</h3><blockquote><p>参数、绑定规则（显示绑定和强绑定），运行效率（最终都会转换成一个一个的参数去运行）、运行情况（<code>call</code>，<code>apply</code> 立即执行，<code>bind</code> 是<code>return</code> 出一个 <code>this</code> “固定”的函数，这也是为什么 <code>bind</code> 是强绑定的一个原因）</p></blockquote><blockquote><p>注：“固定”这个词的含义，它指的固定是指只要传进去了 <code>context</code>，则 <code>bind</code> 中 <code>return</code> 出来的函数 <code>this</code> 便一直指向 <code>context</code>，除非 <code>context</code> 是个变量</p></blockquote><h3 id="2-6-变量声明提升"><a href="#2-6-变量声明提升" class="headerlink" title="2.6 变量声明提升"></a>2.6 变量声明提升</h3><blockquote><p><code>js</code> 代码在运行前都会进行 <code>AST</code> 解析，函数申明默认会提到当前作用域最前面，变量申明也会进行提升。但赋值不会得到提升。关于 <code>AST</code> 解析，这里也可以说是形成词法作用域的主要原因</p></blockquote><h2 id="三、JS-基础（ES6）"><a href="#三、JS-基础（ES6）" class="headerlink" title="三、JS 基础（ES6）"></a>三、JS 基础（ES6）</h2><h3 id="3-1-let，const"><a href="#3-1-let，const" class="headerlink" title="3.1 let，const"></a>3.1 let，const</h3><blockquote><p><code>let</code> 产生块级作用域（通常配合 <code>for</code> 循环或者 <code>{}</code> 进行使用产生块级作用域），<code>const</code> 申明的变量是常量（内存地址不变）</p></blockquote><h3 id="3-2-Promise"><a href="#3-2-Promise" class="headerlink" title="3.2 Promise"></a>3.2 Promise</h3><blockquote><p>这里你谈 <code>promise</code>的时候，除了将他解决的痛点以及常用的 <code>API</code> 之外，最好进行拓展把 <code>eventloop</code> 带进来好好讲一下，<code>microtask</code>(微任务)、<code>macrotask</code>(任务) 的执行顺序，如果看过 <code>promise</code> 源码，最好可以谈一谈 原生 <code>Promise</code> 是如何实现的。<code>Promise</code> 的关键点在于<code>callback</code> 的两个参数，一个是 <code>resovle</code>，一个是 <code>reject</code>。还有就是 <code>Promise</code> 的链式调用（<code>Promise.then()</code>，每一个 <code>then</code> 都是一个责任人）</p></blockquote><h3 id="3-3-Generator"><a href="#3-3-Generator" class="headerlink" title="3.3 Generator"></a>3.3 Generator</h3><blockquote><p>遍历器对象生成函数，最大的特点是可以交出函数的执行权</p></blockquote><ul><li><code>function</code> 关键字与函数名之间有一个星号；</li><li>函数体内部使用 <code>yield</code>表达式，定义不同的内部状态；</li><li><code>next</code>指针移向下一个状态</li></ul><blockquote><p>这里你可以说说 <code>Generator</code>的异步编程，以及它的语法糖 <code>async</code> 和 <code>awiat</code>，传统的异步编程。<code>ES6</code> 之前，异步编程大致如下</p></blockquote><ul><li>回调函数</li><li>事件监听</li><li>发布/订阅</li></ul><blockquote><p>传统异步编程方案之一：协程，多个线程互相协作，完成异步任务。</p></blockquote><h3 id="3-4-async、await"><a href="#3-4-async、await" class="headerlink" title="3.4 async、await"></a>3.4 async、await</h3><blockquote><p><code>Generator</code> 函数的语法糖。有更好的语义、更好的适用性、返回值是 <code>Promise</code>。</p></blockquote><ul><li><code>async =&gt; *</code></li><li><code>await =&gt; yield</code></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基本用法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">timeout</span> (<span class="params">ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(resolve, ms)    </span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncConsole</span> (<span class="params">value, ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> timeout(ms)</span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;</span><br><span class="line">asyncConsole(<span class="string">'hello async and await'</span>, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><blockquote><p>注：最好把2，3，4 连到一起讲</p></blockquote><h3 id="3-5-AMD，CMD，CommonJs，ES6-Module：解决原始无模块化的痛点"><a href="#3-5-AMD，CMD，CommonJs，ES6-Module：解决原始无模块化的痛点" class="headerlink" title="3.5 AMD，CMD，CommonJs，ES6 Module：解决原始无模块化的痛点"></a>3.5 AMD，CMD，CommonJs，ES6 Module：解决原始无模块化的痛点</h3><ul><li><strong>AMD</strong>：<code>requirejs</code> 在推广过程中对模块定义的规范化产出，提前执行，推崇依赖前置</li><li><strong>CMD</strong>：<code>seajs</code> 在推广过程中对模块定义的规范化产出，延迟执行，推崇依赖就近</li><li><strong>CommonJs</strong>：模块输出的是一个值的 <code>copy</code>，运行时加载，加载的是一个对象（<code>module.exports</code> 属性），该对象只有在脚本运行完才会生成</li><li><strong>ES6 Module</strong>：模块输出的是一个值的引用，编译时输出接口，<code>ES6</code>模块不是对象，它对外接口只是一种静态定义，在代码静态解析阶段就会生成。</li></ul><h2 id="四、框架相关"><a href="#四、框架相关" class="headerlink" title="四、框架相关"></a>四、框架相关</h2><h3 id="4-1-数据双向绑定原理：常见数据绑定的方案"><a href="#4-1-数据双向绑定原理：常见数据绑定的方案" class="headerlink" title="4.1 数据双向绑定原理：常见数据绑定的方案"></a>4.1 数据双向绑定原理：常见数据绑定的方案</h3><ul><li><code>Object.defineProperty（vue）</code>：劫持数据的 <code>getter</code> 和 <code>setter</code></li><li>脏值检测（<code>angularjs</code>）：通过特定事件进行轮循<br>发布/订阅模式：通过消息发布并将消息进行订阅</li></ul><h3 id="4-2-VDOM：三个-part"><a href="#4-2-VDOM：三个-part" class="headerlink" title="4.2 VDOM：三个 part"></a>4.2 VDOM：三个 part</h3><ul><li>虚拟节点类，将真实 <code>DOM</code>节点用 <code>js</code> 对象的形式进行展示，并提供 <code>render</code> 方法，将虚拟节点渲染成真实 <code>DOM</code></li><li>节点 <code>diff</code> 比较：对虚拟节点进行 <code>js</code> 层面的计算，并将不同的操作都记录到 <code>patch</code> 对象</li><li><code>re-render</code>：解析 <code>patch</code> 对象，进行 <code>re-render</code></li></ul><p><strong>补充1：VDOM 的必要性？</strong></p><ul><li><strong>创建真实DOM的代价高</strong>：真实的 <code>DOM</code> 节点 <code>node</code> 实现的属性很多，而 <code>vnode</code> 仅仅实现一些必要的属性，相比起来，创建一个 <code>vnode</code> 的成本比较低。</li><li><strong>触发多次浏览器重绘及回流</strong>：使用 <code>vnode</code> ，相当于加了一个缓冲，让一次数据变动所带来的所有 <code>node</code> 变化，先在 <code>vnode</code> 中进行修改，然后 <code>diff</code> 之后对所有产生差异的节点集中一次对 <code>DOM tree</code> 进行修改，以减少浏览器的重绘及回流。</li></ul><p><strong>补充2：vue 为什么采用 vdom？</strong></p><blockquote><p>引入 <code>Virtual DOM</code> 在性能方面的考量仅仅是一方面。</p></blockquote><ul><li>性能受场景的影响是非常大的，不同的场景可能造成不同实现方案之间成倍的性能差距，所以依赖细粒度绑定及 <code>Virtual DOM</code> 哪个的性能更好还真不是一个容易下定论的问题。</li><li><code>Vue</code> 之所以引入了 <code>Virtual DOM</code>，更重要的原因是为了解耦 <code>HTML</code>依赖，这带来两个非常重要的好处是：</li></ul><blockquote><ul><li>不再依赖 <code>HTML</code> 解析器进行模版解析，可以进行更多的 <code>AOT</code> 工作提高运行时效率：通过模版 <code>AOT</code> 编译，<code>Vue</code> 的运行时体积可以进一步压缩，运行时效率可以进一步提升；</li><li>可以渲染到 <code>DOM</code> 以外的平台，实现 <code>SSR</code>、同构渲染这些高级特性，<code>Weex</code>等框架应用的就是这一特性。</li></ul></blockquote><blockquote><p>综上，<code>Virtual DOM</code> 在性能上的收益并不是最主要的，更重要的是它使得 <code>Vue</code> 具备了现代框架应有的高级特性。</p></blockquote><h3 id="4-3-vue-和-react-区别"><a href="#4-3-vue-和-react-区别" class="headerlink" title="4.3 vue 和 react 区别"></a>4.3 vue 和 react 区别</h3><ul><li>相同点：都支持 <code>ssr</code>，都有 <code>vdom</code>，组件化开发，实现 <code>webComponents</code> 规范，数据驱动等</li><li>不同点：<code>vue</code> 是双向数据流（当然为了实现单数据流方便管理组件状态，<code>vuex</code> 便出现了），<code>react</code> 是单向数据流。<code>vue</code>的 <code>vdom</code> 是追踪每个组件的依赖关系，不会渲染整个组件树，<code>react</code> 每当应该状态被改变时，全部子组件都会 <code>re-render</code></li></ul><h3 id="4-4-为什么用-vue"><a href="#4-4-为什么用-vue" class="headerlink" title="4.4 为什么用 vue"></a>4.4 为什么用 vue</h3><blockquote><p>简洁、轻快、舒服</p></blockquote><h2 id="五、网络基础类"><a href="#五、网络基础类" class="headerlink" title="五、网络基础类"></a>五、网络基础类</h2><h3 id="5-1-跨域"><a href="#5-1-跨域" class="headerlink" title="5.1 跨域"></a>5.1 跨域</h3><blockquote><p>很多种方法，但万变不离其宗，都是为了搞定同源策略。重用的有 <code>jsonp</code>、<code>iframe</code>、<code>cors</code>、<code>img</code>、H<code>TML5 postMessage</code>等等。其中用到 <code>html</code> 标签进行跨域的原理就是 <code>html</code> 不受同源策略影响。但只是接受 <code>Get</code> 的请求方式，这个得清楚。</p></blockquote><blockquote><p><strong>延伸1：img iframe script 来发送跨域请求有什么优缺点？</strong></p></blockquote><p><strong>1. <code>iframe</code></strong></p><ul><li>优点：跨域完毕之后<code>DOM</code>操作和互相之间的<code>JavaScript</code>调用都是没有问题的</li><li>缺点：1.若结果要以<code>URL</code>参数传递，这就意味着在结果数据量很大的时候需要分割传递，巨烦。2.还有一个是<code>iframe</code>本身带来的，母页面和<code>iframe</code>本身的交互本身就有安全性限制。</li></ul><p><strong>2. script</strong></p><ul><li>优点：可以直接返回<code>json</code>格式的数据，方便处理</li><li>缺点：只接受<code>GET</code>请求方式</li></ul><p><strong>3. 图片ping</strong></p><ul><li>优点：可以访问任何<code>url</code>，一般用来进行点击追踪，做页面分析常用的方法</li><li>缺点：不能访问响应文本，只能监听是否响应</li></ul><blockquote><p><strong>延伸2：配合 webpack 进行反向代理？</strong></p></blockquote><p><code>webpack</code> 在 <code>devServer</code> 选项里面提供了一个 <code>proxy</code> 的参数供开发人员进行反向代理</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">'/api'</span>: &#123;</span><br><span class="line">  target: <span class="string">'http://www.example.com'</span>, <span class="comment">// your target host</span></span><br><span class="line">  changeOrigin: <span class="literal">true</span>, <span class="comment">// needed for virtual hosted sites</span></span><br><span class="line">  pathRewrite: &#123;</span><br><span class="line">    <span class="string">'^/api'</span>: <span class="string">''</span>  <span class="comment">// rewrite path</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><blockquote><p>然后再配合 <code>http-proxy-middleware</code> 插件对 <code>api</code> 请求地址进行代理</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="built_in">require</span>(<span class="string">'http-proxy-middleware'</span>);</span><br><span class="line"><span class="comment">// proxy api requests</span></span><br><span class="line"><span class="keyword">const</span> exampleProxy = proxy(options); <span class="comment">// 这里的 options 就是 webpack 里面的 proxy 选项对应的每个选项</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// mount `exampleProxy` in web server</span></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line">app.use(<span class="string">'/api'</span>, exampleProxy);</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><blockquote><p>然后再用 <code>nginx</code> 把允许跨域的源地址添加到报头里面即可</p></blockquote><blockquote><p>说到 <code>nginx</code> ，可以再谈谈 <code>CORS</code> 配置，大致如下</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">  <span class="keyword">if</span> ($request_method = <span class="string">'OPTIONS'</span>) &#123;</span><br><span class="line">    add_header <span class="string">'Access-Control-Allow-Origin'</span> <span class="string">'*'</span>;  </span><br><span class="line">    add_header <span class="string">'Access-Control-Allow-Methods'</span> <span class="string">'GET, POST, OPTIONS'</span>; </span><br><span class="line">    add_header <span class="string">'Access-Control-Allow-Credentials'</span> <span class="string">'true'</span>;</span><br><span class="line">    add_header <span class="string">'Access-Control-Allow-Headers'</span> <span class="string">'DNT, X-Mx-ReqToken, Keep-Alive, User-Agent, X-Requested-With, If-Modified-Since, Cache-Control, Content-Type'</span>;  </span><br><span class="line">    add_header <span class="string">'Access-Control-Max-Age'</span> <span class="number">86400</span>;  </span><br><span class="line">    add_header <span class="string">'Content-Type'</span> <span class="string">'text/plain charset=UTF-8'</span>;  </span><br><span class="line">    add_header <span class="string">'Content-Length'</span> <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">200</span>;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-http-无状态无连接"><a href="#5-2-http-无状态无连接" class="headerlink" title="5.2 http 无状态无连接"></a>5.2 http 无状态无连接</h3><ul><li><code>http</code> 协议对于事务处理没有记忆能力</li><li>对同一个<code>url</code>请求没有上下文关系</li><li>每次的请求都是独立的，它的执行情况和结果与前面的请求和之后的请求是无直接关系的，它不会受前面的请求应答情况直接影响，也不会直接影响后面的请求应答情况</li><li>服务器中没有保存客户端的状态，客户端必须每次带上自己的状态去请求服务器</li><li>人生若只如初见，请求过的资源下一次会继续进行请求</li></ul><p><strong>http协议无状态中的 状态 到底指的是什么？！</strong></p><ul><li>【状态】的含义就是：客户端和服务器在某次会话中产生的数据</li><li>那么对应的【无状态】就意味着：这些数据不会被保留</li><li>通过增加<code>cookie</code>和<code>session</code>机制，现在的网络请求其实是有状态的</li><li>在没有状态的<code>http</code>协议下，服务器也一定会保留你每次网络请求对数据的修改，但这跟保留每次访问的数据是不一样的，保留的只是会话产生的结果，而没有保留会话</li></ul><h3 id="5-3-http-cache：就是-http-缓存"><a href="#5-3-http-cache：就是-http-缓存" class="headerlink" title="5.3 http-cache：就是 http 缓存"></a>5.3 http-cache：就是 http 缓存</h3><p><strong>1. 首先得明确 http 缓存的好处</strong></p><ul><li>减少了冗余的数据传输，减少网费</li><li>减少服务器端的压力</li><li><code>Web</code> 缓存能够减少延迟与网络阻塞，进而减少显示某个资源所用的时间</li><li>加快客户端加载网页的速度</li></ul><p><strong>2. 常见 http 缓存的类型</strong></p><ul><li>私有缓存（一般为本地浏览器缓存）</li><li>代理缓存</li></ul><p><strong>3. 然后谈谈本地缓存</strong></p><blockquote><p>本地缓存是指浏览器请求资源时命中了浏览器本地的缓存资源，浏览器并不会发送真正的请求给服务器了。它的执行过程是</p></blockquote><ul><li>第一次浏览器发送请求给服务器时，此时浏览器还没有本地缓存副本，服务器返回资源给浏览器，响应码是<code>200 OK</code>，浏览器收到资源后，把资源和对应的响应头一起缓存下来</li><li>第二次浏览器准备发送请求给服务器时候，浏览器会先检查上一次服务端返回的响应头信息中的<code>Cache-Control</code>，它的值是一个相对值，单位为秒，表示资源在客户端缓存的最大有效期，过期时间为第一次请求的时间减去<code>Cache-Control</code>的值，过期时间跟当前的请求时间比较，如果本地缓存资源没过期，那么命中缓存，不再请求服务器</li><li>如果没有命中，浏览器就会把请求发送给服务器，进入缓存协商阶段。</li></ul><blockquote><p>与本地缓存相关的头有：<code>Cache-Control</code>、<code>Expires</code>，<code>Cache-Control</code>有多个可选值代表不同的意义，而<code>Expires</code>就是一个日期格式的绝对值。</p></blockquote><p><strong>3.1 Cache-Control</strong></p><blockquote><p><code>Cache-Control</code>是<code>HTPP</code>缓存策略中最重要的头，它是<code>HTTP/1.1</code>中出现的，它由如下几个值</p></blockquote><ul><li><code>no-cache</code>：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在<code>ETag</code>，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载</li><li><code>no-store</code>：直接禁止游览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源</li><li><code>public</code>：可以被所有的用户缓存，包括终端用户和<code>CDN</code>等中间代理服务器。</li><li><code>private</code>：只能被终端用户的浏览器缓存，不允许<code>CDN</code>等中继缓存服务器对其缓存。</li><li><code>max-age</code>：从当前请求开始，允许获取的响应被重用的最长时间（秒）。</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 例如：</span></span><br><span class="line"></span><br><span class="line">Cache-Control: public, max-age=1000 </span><br><span class="line"><span class="comment"># 表示资源可以被所有用户以及代理服务器缓存，最长时间为1000秒。</span></span><br></pre></td></tr></table></figure><p><strong>3.2 Expires</strong></p><blockquote><p><code>Expires</code>是<code>HTTP/1.0</code>出现的头信息，同样是用于决定本地缓存策略的头，它是一个绝对时间，时间格式是如<code>Mon, 10 Jun 2015 21:31:12 GMT</code>，只要发送请求时间是在<code>Expires</code>之前，那么本地缓存始终有效，否则就会去服务器发送请求获取新的资源。如果同时出现<code>Cache-Control：max-age</code>和<code>Expires</code>，那么<code>max-age</code>优先级更高。他们可以这样组合使用</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cache-Control: public</span><br><span class="line">Expires: Wed, Jan 10 2018 00:27:04 GMT</span><br></pre></td></tr></table></figure><p><strong>3.3 所谓的缓存协商</strong></p><blockquote><p>当第一次请求时服务器返回的响应头中存在以下情况时</p></blockquote><ul><li>没有 <code>Cache-Control</code> 和 <code>Expires</code></li><li><code>Cache-Control</code> 和 <code>Expires</code> 过期了</li><li><code>Cache-Control</code> 的属性设置为 <code>no-cache</code> 时</li></ul><blockquote><p>那么浏览器第二次请求时就会与服务器进行协商，询问浏览器中的缓存资源是不是旧版本，需不需要更新，此时，服务器就会做出判断，如果缓存和服务端资源的最新版本是一致的，那么就无需再次下载该资源，服务端直接返回<code>304 Not Modified</code> 状态码，如果服务器发现浏览器中的缓存已经是旧版本了，那么服务器就会把最新资源的完整内容返回给浏览器，状态码就是<code>200 Ok</code>，那么服务端是根据什么来判断浏览器的缓存是不是最新的呢？其实是根据<code>HTTP</code>的另外两组头信息，分别是：<code>Last-Modified/If-Modified-Since</code> 与 <code>ETag/If-None-Match</code>。</p></blockquote><p><strong>Last-Modified 与 If-Modified-Since</strong></p><ul><li>浏览器第一次请求资源时，服务器会把资源的最新修改时间<code>Last-Modified:Thu, 29 Dec 2011 18:23:55 GMT</code>放在响应头中返回给浏览器</li><li>第二次请求时，浏览器就会把上一次服务器返回的修改时间放在请求头<code>If-Modified-Since:Thu, 29 Dec 2011 18:23:55</code>发送给服务器，服务器就会拿这个时间跟服务器上的资源的最新修改时间进行对比</li></ul><blockquote><p>如果两者相等或者大于服务器上的最新修改时间，那么表示浏览器的缓存是有效的，此时缓存会命中，服务器就不再返回内容给浏览器了，同时<code>Last-Modified</code>头也不会返回，因为资源没被修改，返回了也没什么意义。如果没命中缓存则最新修改的资源连同<code>Last-Modified</code>头一起返回</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第一次请求返回的响应头</span></span><br><span class="line">Cache-Control:max-age=3600</span><br><span class="line">Expires: Fri, Jan 12 2018 00:27:04 GMT</span><br><span class="line">Last-Modified: Wed, Jan 10 2018 00:27:04 GMT</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第二次请求的请求头信息</span></span><br><span class="line">If-Modified-Since: Wed, Jan 10 2018 00:27:04 GMT</span><br></pre></td></tr></table></figure><blockquote><p>这组头信息是基于资源的修改时间来判断资源有没有更新，另一种方式就是根据资源的内容来判断，就是接下来要讨论的 <code>ETag</code> 与 <code>If-None-Match</code></p></blockquote><p><strong>ETag与If-None-Match</strong></p><blockquote><p><code>ETag/If-None-Match</code>与<code>Last-Modified/If-Modified-Since</code>的流程其实是类似的，唯一的区别是它基于资源的内容的摘要信息（比如<code>MD5 hash</code>）来判断</p></blockquote><blockquote><p>浏览器发送第二次请求时，会把第一次的响应头信息<code>ETag</code>的值放在<code>If-None-Match</code>的请求头中发送到服务器，与最新的资源的摘要信息对比，如果相等，取浏览器缓存，否则内容有更新，最新的资源连同最新的摘要信息返回。用<code>ETag</code>的好处是如果因为某种原因到时资源的修改时间没改变，那么用<code>ETag</code>就能区分资源是不是有被更新。</p></blockquote><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第一次请求返回的响应头：</span></span><br><span class="line"></span><br><span class="line">Cache-Control: public, max-age=31536000</span><br><span class="line">ETag: <span class="string">"15f0fff99ed5aae4edffdd6496d7131f"</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第二次请求的请求头信息：</span></span><br><span class="line"></span><br><span class="line">If-None-Match: <span class="string">"15f0fff99ed5aae4edffdd6496d7131f"</span></span><br></pre></td></tr></table></figure><h3 id="5-4-cookie-和-session"><a href="#5-4-cookie-和-session" class="headerlink" title="5.4 cookie 和 session"></a>5.4 cookie 和 session</h3><ul><li><code>session</code>： 是一个抽象概念，开发者为了实现中断和继续等操作，将 <code>user agent</code>和 <code>server</code> 之间一对一的交互，抽象为“会话”，进而衍生出“会话状态”，也就是 <code>session</code> 的概念</li><li><code>cookie</code>：它是一个世纪存在的东西，<code>http</code> 协议中定义在 <code>header</code> 中的字段，可以认为是 <code>session</code> 的一种后端无状态实现</li></ul><blockquote><p>现在我们常说的 <code>session</code>，是为了绕开 <code>cookie</code> 的各种限制，通常借助 <code>cookie</code>本身和后端存储实现的，一种更高级的会话状态实现</p></blockquote><p><code>session</code> 的常见实现要借助<code>cookie</code>来发送 <code>sessionID</code></p><h3 id="5-5-安全问题，如-XSS-和-CSRF"><a href="#5-5-安全问题，如-XSS-和-CSRF" class="headerlink" title="5.5 安全问题，如 XSS 和 CSRF"></a>5.5 安全问题，如 XSS 和 CSRF</h3><ul><li><code>XSS</code>：跨站脚本攻击，是一种网站应用程序的安全漏洞攻击，是代码注入的一种。常见方式是将恶意代码注入合法代码里隐藏起来，再诱发恶意代码，从而进行各种各样的非法活动</li></ul><blockquote><p>防范：记住一点 “所有用户输入都是不可信的”，所以得做输入过滤和转义</p></blockquote><ul><li><code>CSRF</code>：跨站请求伪造，也称 <code>XSRF</code>，是一种挟制用户在当前已登录的<code>Web</code>应用程序上执行非本意的操作的攻击方法。与 <code>XSS</code> 相比，<code>XSS</code>利用的是用户对指定网站的信任，<code>CSRF</code>利用的是网站对用户网页浏览器的信任。</li></ul><blockquote><p>防范：用户操作验证（验证码），额外验证机制（<code>token</code>使用）等</p></blockquote><script>export default {  mounted () {    var script = document.createElement("script");    script.type = "text/javascript"    script.charset="UTF-8"    script.src = "http://tajs.qq.com/stats?sId=59154049"    document.body.appendChild(script);  }}</script>]]></content>
      
      
      <categories>
          
          <category> 资料整理 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
