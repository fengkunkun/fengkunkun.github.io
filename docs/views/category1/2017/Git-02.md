---
title: Git-02
date: 2017-09-08 17:13:34
categories:
 -  技术
---

##### Git-02

Git

<!--more-->

## git-比较命令补充

> **`目标`**使用diff命令比较 暂存区和工作区的差异, 比较暂存区和上一个commit的差异,比较工作区与最新commit之间的差异
>
> ```bash
> # 显示 某个版本的提交内容
> $ git show 版本号
> # 显示暂存区和工作区的差异
> $ git diff
> # 显示暂存区和上一个commit的差异
> $ git diff --cached [file]
> # 显示工作区与当前分支最新commit之间的差异
> $ git diff HEAD
> 
> ```
>
> **`任务`**
>
> 1. 初始化仓库 新建文件a.js 内容为1 提交到仓库
> 2. 修改a.js 为2 ,比较暂存区和工作区差异
> 3. 提交a.js到暂存区, 比较暂存区和上一个commit差异
> 4. 比较工作区于最新commit差异
>
> **`路径`**
>
> ```bash 
> # 初始化仓库
> $ git init demo
> # 编辑文件内容
> $ vi a.js
> # 编辑内容为1
> # 提交到暂存区
> $ git add . 
> # 提交到仓库区
> $ git commit -m "提交到仓库区"
> # vi编辑为2
> # 比较暂存区和工作区差异
> $ git diff 
> # 提交a到暂存区
> $ git  add .
> # 比较暂存区和上一个commit差异
> $ git diff --cached a
> # 比较工作区于最新commit差异
> $ git diff HEAD
> ```
>
> 

## git-基础-分支概念及使用

> **`目标`**:了解什么是分支 以及真正的分支需求
>
> 定义:一旦我们初始化仓库完成,就自动帮我们创建了一个**master主线分支**,使用其他**分支**意味着你可以把你的工作从开发**主线**上分离开来，以免影响开发主线。
>
> ```bash 
> # 新建一个分支
> $ git branch <分支名称>
> # 切换到指定分支
> $ git checkout <分支名称>
> # 新建分支并切换到该分支
> $ git checkout -b <分支名称>
> #删除分支 
> $ git branch -d <分支名称>
> # 列出所有本地分支
> $ git branch 
> # 新建一个分支，指向指定commit
> $ git branch [branch] [commit]
> ```
>
> **`任务`**: 
>
> 1. 初始化一个仓库
> 2. 并完成新建一个分支dev,
> 3. 切换到该分支下
>
> **`路径`**: 
>
> ```bash 
> # 初始化仓库
> $ git  init demo 
> # 新建一个dev分支
> $ git  branch dev
> # 切换到dev分支下
> $ git checkout dev 
> ```

## Git-分支合并-快进模式

> **`目标`**:	了解分支合并,  并能了解合并快进模式
>
> - 一般来讲,master分支作为主要稳定分支,开发都在其他分支上,当完成分支工作,就设计到分支的合并
> - 当分支合并时,要合并的分支代码大于自己的版本,并且拥有了自己最新的提交版本,而可以快速合并
>
> ```bash
> # 合并指定分支到当前分支
> $ git merge [branch] 
> ```
>
> **`任务`**: 
>
> 1. 初始化一个仓库
> 2. 新建文件a.js, 提交到仓库,
> 3. 新建分支dev, 在dev中修改a.js内容为hello world 提交到仓库,
> 4. 切回master分支,合并dev分支代码
>
> **`路径`**
>
> ```bash
> # 初始化一个仓库 
> $ git init demo 
> # 新建一个文件并提交
> $ touch a.js
> $ git add a.js
> $ git commit -m "提交代码"
> # 新建dev并切换到该分支
> $ git checkout -b dev
> # 编辑.js 为hello world 
> # 提交dev分支
> $ git commit -a -m  "提交dev修改"
> # 切换master分支
> $ git checkout master 
> # 合并dev分支代码
> $ git merge dev 
> ```
>
> 

## Git-分支合并-合并模式

> **`目标`**: 了解git分支合并时, 两个分支都存在更新的情况下 合并模式
>
> - 如果git分支合并时,当前分支和合并分支互有改动并且已提交到仓库, 合并时涉及到 代码和文件的合并
>
> **`任务`**: 
>
> 1. 初始化一个仓库,
> 2. 新建一个a.js 内容为 123, 提交到仓库, 
> 3. 拉取分支dev,新增b.js 内容为456,提交到仓库,
> 4. 切回master分支,修改a.js内容为123456,提交到仓库,
> 5. 合并dev分支到master
>
> **`路径`**:
>
> ```bash
> # 初始化仓库
> $ git init Demo 
> # 切换到该目录
> $ cd  Demo
> # 新建a.js
> $ touch a.js
> # 编辑a.js 为123,
> #提交到仓库
> $ git add . 
> $ git commit -m "提交到仓库"
> # 新建并切换到新分支dev
> $ git  checkout -b dev 
> # 新建b.js 并提交
> $ touch b.js
> $ git add b.js
> $ git commit -m "提交dev b.js"
> # 切回master分支
> $ git checkout master 
> # 编辑a.js内容为123456
> # 提交a.js到仓库
> $ git commit -a -m "提交master修改"
> # 合并dev分支
> $ git merge dev
> ```
>
> 

## Git-合并-解决冲突

> **目标**:合并模式很容易造成文件的冲突,学会解决文件冲突
>
> - 可以通过打开文件的方式查找冲突的部位 手动修改 
> - vscode打开文件  进行解决
> - 其他
>
> **任务**: 在上一小节的任务基础上, 在dev分支里面 将123456 改为654321,然后合并到master分支
>
> **注意** 冲突文件 解决之后还处在修改状态 还未进行提交  需要进行提交

## git远程仓库

> **`目标`**: 了解什么是远程仓库

> - 远程仓库相当于帮我们永久备份了代码 
> - 解决了多人协同的问题
> - 第三方远程仓库托管服务：
>
> - GitHub
> - 码云（gitee）
> - coding
> - Gitlab
>   - 一个开源的类似于 GitHub 的 Git 仓库托管服务
>   - 支持自行搭建

## 将本地仓库推到线上远程仓库

> **`目标`**:如何新建远程仓库 并将本地仓库推到线上远程仓库同步
>
> 如何把一个本地仓库放到 `GitHub`：
>
> 1. 在 `GitHub` 中新建一个远程仓库(参照讲义)
> 2. 在本地仓库下执行
>
> 第1次推送：
>
> ```bash
> # 别名我们通常喜欢使用 origin 作为远程仓库的别名 
> $ git remote add 别名 远程仓库地址 
> $ git  remote -v 查看配置地址
> 
> # 当本地分支和远程分支名字一样的时候，可以简写只写一个
> # -u 的作用是记住本次的 push 地址和分支信息
> # 如果不加 -u，则下一次 push 的时候，还需要使用完整的命令
> $ git push -u 远程仓库地址别名 本地分支
> 
> 如果要推送的本地分支和远端分支已有，可以简写为
> git push origin <分支名>
> ```
>
> 第二次推送: 
>
> ```bash 
> # 由于第一次推送中 采用了 -u 指令 所以之后推送就很简单了
> $ git push
> ```
>
> **注意**: 可以给本地仓库加多个远程仓库 
>
> **`任务`**: 
>
> 1. 新建一个自己的远程仓库  https协议
> 2. 新建一个本地仓库 增加一些内容
> 3. 将本地仓库内容推到线上
> 4. 新建本地分支dev 在dev中新增dev.js  
> 5. 推送dev分支到远程仓库
>
> ```bash
> # 新建远程仓库  打开gitbub 右上角 new Repository
> # 新建本地仓库
> # 添加远程仓库 注意origin可以随意定义 一般定义成origin 
> $ git remote add origin url
> # 第一次推送  
> $ git push -u origin master
> # 第二次推送
> $ git push
> # 新建本地分支 
> $ git  checkout -b dev
> # 新增dev.js
> $ vi dev.js
> # 推送dev到远程仓库
> $ git push origin dev
> ```
>
> 

## Git远程仓库-从线上拉取线上代码

> **`目标`**: 掌握如何从远程仓库拉取代码到本地 形成本地仓库
>
> - 当我们新加入一个团队 加入一个项目的时候 需要从远程仓库拉取代码到本地 进行开发
>
> ```bash 
> # 从线上拉取代码到本地仓库
> git clone <远程仓库地址> <目录名(可忽略)>
> ```

​	  **注意** 克隆下来的仓库相当于 已经完成了本地仓库和 远程仓库的通话, 可以直接使用推送命令

```bash 
# 推送
$ git push 
```

> 
>
> **`任务`**: 
>
> 1. 拉取上小节中的远程仓库内容到一个test目录下 
> 2. 新建一个index.html 内容为 hello world  
> 3. 提交仓库区,推送到远程仓库
>
> **`路径`**
>
> ```bash 
> # 拉取远程仓库内容到test目录下
> $ git clone <地址> test
> # 新建index.html
> # 提交仓库
> $ git commit -a -m "提交index.html"
> # 推送到远程仓库
> $ git push 
> ```
>
> 

## Git远程仓库-拉取和更新

> 
>
> **`目标`**: 掌握远程仓库到本地仓库的拉取和更新
>
> 当远程仓库有变化时:需要拉取远程仓库的**`更新`**到自己的仓库
>
> **注意** 上小节中讲到的**克隆** 代码,只是将远程仓库完整拷贝了一份,形成一份本地仓库,
>
> ```bash
> # 拉取远程仓库更新 
> $ git pull 
> ```
>
> ```bash
> # 下载远程仓库的所有变动
> $ git fetch [remote]
> 
> # 显示所有远程仓库
> $ git remote -v
> 
> # 显示某个远程仓库的信息
> $ git remote show [remote]
> 
> # 增加一个新的远程仓库，并命名
> $ git remote add [shortname] [url]
> 
> # 取回远程仓库的变化，并与本地分支合并
> $ git pull [remote] [branch]
> 
> # 上传本地指定分支到远程仓库
> $ git push [remote] [branch]
> 
> # 强行推送当前分支到远程仓库，即使有冲突
> $ git push [remote] --force
> 
> # 推送所有分支到远程仓库
> $ git push [remote] --all
> ```
>
> **`任务`**:  
>
> 1. 从上一小节的远程仓库 新增文件 
> 2. 从上一小节的远程仓库修改文件 
> 3. 从上一小节的远程仓库删除文件
> 4. 拉取更新到本地仓库

## Git多人协作

> **`目标`**: 掌握如果通过git进行多人协作
>
> - 默认情况下 只有仓库所有者才可以推送代码
> - gitHub的远程仓库 public情况下 所有人只有克隆拉取的权限 但是没有提交的权限
> - 需要通过管理员- 远程仓库管理者给开发者分配提交权限
>
> 演示: jquery代码的拉取, 但是不能提交的问题
>
> **`任务`**:  
>
> 1. 两人协作, 一人新建远程仓库
> 2. 另一人拉取远程仓库
> 3. 不配发权限情况下 提交
> 4. 配发权限提交
>
> **`路径`**: 
>
> 1. 按照任务步骤操作

## 远程仓库-本地仓库-冲突解决

> **`目标`**:  掌握远程仓库和本地仓库 如何解决冲突
>
> - 当远程仓库版本和本地版本同时推进时,可能会产生文件冲突
> - 所以,提交之前需要先拉取线上更新代码, 合并本地仓库代码
> - 一旦出现冲突,需要进行解决,将文本区域内容 提交合并结果
>
> **`任务`**: 
>
> 1. 在远程仓库总新建文件 test.js 写入内容 123 提交
> 2. 本地仓库拉取更新 并修改test.js内容 为456
> 3. 在远程仓库修改test.js内容为 789 提交
> 4. 拉取更新 
> 5. 解决冲突 采用本地内容456 提交到本地仓库 然后推送到远程仓库
>
> **`路径`**: 
>
> 按照任务步骤操作

## Git本地分支以及推送到远程分支

## Git的标签(了解-扩展)

> **`目标`**:了解git打标签的含义
>
> - 像其他版本控制系统（VCS）一样，Git 可以给历史中的某一个提交打上标签，以示重要。 比较有代表性的是人们会使用这个功能来标记发布结点（v1.0 等等）。
>
> 在 Git 中列出已有的标签是非常简单直观的。 只需要输入 `git tag`：
>
> ```bash
> $ git tag
> v0.1
> v1.3
> ```

> ```bash
> # 列出所有tag
> $ git tag
> 
> # 新建一个tag在当前commit
> $ git tag [tag]
> 
> # 新建一个tag在指定commit
> $ git tag [tag] [commit]
> 
> # 删除本地tag
> $ git tag -d [tag]
> 
> # 删除远程tag
> $ git push origin :refs/tags/[tagName]
> 
> # 查看tag信息
> $ git show [tag]
> 
> # 提交指定tag
> $ git push [remote] [tag]
> 
> # 提交所有tag
> $ git push [remote] --tags
> 
> # 新建一个分支，指向某个tag
> $ git checkout -b [branch] [tag]
> ```
>
> 
>
> **`任务`**:  
>
> 1. 给自己的第一次提交版本打上标签 v1.0.0
> 2. 给自己的第三次提交打上标签 v.1.0.1
> 3. 分别查看以上两个标签内容信息
>
> **`路径`**
>
> ```bash
> # 打标签
> $  git  tag v1.0.0 <commitid>
> $  git  tag v1.0.1 <commitid>
> # 查看标签
> $ git show v.1.0.0
> $ git show v.1.0.1
> ```



## 图形化Git管理工具(了解)

> **`目标`**: 了解图形化git管理工具,`TortoiseGit` 
>
> - `TortoiseGit`  和 `TortioiseSVN  `都是图形化版本控制系统 
> - `TortoiseGit` 只是将git的一些命令封装到了图形化界面中 
> - 工具所作的事情与命令行完全一致
>
> 

## Git总结

> 仓库 > 分支 > 工作区 暂存区 仓库区
>
> 远程仓库 > 本地仓库
>
> 分支合并 git  merge  合并的分支  
>
> 远程仓库   gitHub新建仓库 => 地址 远程仓库的地址
>
> 远程仓库地址 => 本地仓库 和 远程仓库建立联系  git  remote add  origin 地址
>
> 本地仓库 => 远程仓库  git push origin dev  
>
> 拷贝整个远程仓库代码 git  clone  地址  
>
> 拉取更新 git pull 
>
> 