---
title: JavaScript-jQuery-03
date: 2017-07-03 15:13:34
categories:
 -  技术
---

##### JavaScript-jQuery-03

JavaScript-jQuery

<!--more-->

## **jQuery** **元素操作**

> 主要是遍历、创建、添加、删除元素操作。

### **遍历元素**

jQuery 隐式迭代是对同一类元素做了同样的操作。如果想要给同一类元素做不同操作，就需要用到遍历。

> 语法1：$("div").each(function(index, domEle) { xxx; }）

```
\1. each() 方法遍历匹配的每一个元素。主要用DOM处理。 each 每一个

\2. 里面的回调函数有2个参数：  index 是每个元素的索引号;  demEle 是每个DOM元素对象，不是jquery对象

\3. 所以要想使用jquery方法，需要给这个dom元素转换为jquery对象  $(domEle)
```

语法2：$.each(object，function(index, element){ xxx;}）

```
\1. $.each()方法可用于遍历任何对象。主要用于数据处理，比如数组，对象

\2. 里面的函数有2个参数：  index 是每个元素的索引号;  element  遍历内容
```

**案例：购物车案例****模块****-****计算总计和总额**

```
①核心思路：把所有文本框里面的值相加就是总计数量。总额同理

②文本框里面的值不相同，如果想要相加需要用到each遍历。声明一个变量，相加即可

③点击+号-号，会改变总计和总额，如果用户修改了文本框里面的值同样会改变总计和总额

④因此可以封装一个函数求总计和总额的， 以上2个操作调用这个函数即可。

⑤注意1： 总计是文本框里面的值相加用 val()     总额是普通元素的内容用text()  

⑥要注意普通元素里面的内容要去掉￥并且转换为数字型才能相加

多次需要求总计，所有封装函数最为合适
```

### **创建**元素

> 语法：$(''<li></li>'');    

### **添加**元素

> element.append(''内容'') [把内容放入匹配元素内部最后面，类似原生 appendChild。]
>
> element.prepend(''内容'') 把内容放入匹配元素内部最前面。

**外****部添加**

> element.after(''内容'') // 把内容放入目标元素后面
>
> element.before(''内容'')    //  把内容放入目标元素前面 

```
①内部添加元素，生成之后，它们是父子关系。

②外部添加元素，生成之后，他们是兄弟关系。
```

**删除****元素**

> element.remove()   //  删除匹配的元素（本身）
>
> element.empty()    //  删除匹配的元素集合中所有的子节点
>
> element.html('''')   //  清空匹配的元素内容

```
①remove 删除元素本身。

②empt() 和  html('''') 作用等价，都可以删除元素里面的内容，只不过 html 还可以设置内容。
```

**案例：购物车案例****模块****-****删除商品模块**

```
①核心思路：把商品remove() 删除元素即可

②有三个地方需要删除： 1. 商品后面的删除按钮 2. 删除选中的商品 3. 清理购物车

③商品后面的删除按钮： 一定是删除当前的商品，所以从 $(this) 出发

④删除选中的商品： 先判断小的复选框按钮是否选中状态，如果是选中，则删除对应的商品

⑤清理购物车： 则是把所有的商品全部删掉
```

**案例：购物车案例****模块****-****选中商品添加背景**

```
①核心思路：选中的商品添加背景，不选中移除背景即可

②全选按钮点击：如果全选是选中的，则所有的商品添加背景，否则移除背景

③小的复选框点击： 如果是选中状态，则当前商品添加背景，否则移除背景

④这个背景，可以通过类名修改，添加类和删除类
```

## **jQuery** **尺寸、位置操作**



### **jQuery 尺寸**

> width()、height()【只算width和height】
>
> innerWidth()、innerHeight()【包含padding+width】
>
> outerWidth()、outerHeight()【包含padding、border、width】
>
> outerWidth(true)、outerHeight(true)【包含padding、border、margin、width】

```
以上参数为空，则是获取相应值，返回的是数字型。
如果参数为数字，则是修改相应值。
参数可以不必写单位。
```





### **jQuery 位置**

> 位置主要有三个： offset()、position()、scrollTop()/scrollLeft()

**offset()设置或获取元素偏移**

```
①offset() 方法设置或返回被选元素相对于**文档**的偏移坐标，跟父级没有关系。

②该方法有2个属性 left、top 。offset().top  用于获取距离文档顶部的距离，offset().left 用于获取距离文档左侧的距离。

③可以设置元素的偏移：offset({ top: 10, left: 30 });
```

**position()** 获取元素偏移**

①position() 方法用于返回被选元素相对于**带有定位的父级**偏移坐标，如果父级都没有定位，则以文档为准。

②该方法有2个属性 left、top。position().top 用于获取距离定位父级顶部的距离，position().left 用于获取距离定位父级左侧的距离。

注意：该方法只能获取。

**scrollTop()、scrollLeft()设置****或获取元素被卷去的头部和****左侧**

①scrollTop() 方法设置或返回被选元素被卷去的头部。

②不跟参数是获取200，参数为不带单位的数字则是设置被卷去的头部。

scroll事件

#### **案例带有动画的返回顶部**

```
①核心原理： 使用animate动画返回顶部。

②animate动画函数里面有个scrollTop 属性，可以设置位置

③但是是元素做动画，因此 $(“body,html”).animate({scrollTop: 0})
```

#### **案例：品优购电梯导航**

```
①当我们滚动到 今日推荐 模块，就让电梯导航显示出来

②点击电梯导航页面可以滚动到相应内容区域

③核心算法：因为电梯导航模块和内容区模块一一对应的

④当我们点击电梯导航某个小模块，就可以拿到当前小模块的索引号

⑤就可以把animate要移动的距离求出来：当前索引号内容区模块它的offset().top

⑥然后执行动画即可
```

```
第二部分：

①当我们点击电梯导航某个小li， 当前小li 添加current类，兄弟移除类名

②当我们页面滚动到内容区域某个模块， 左侧电梯导航，相对应的小li模块，也会添加current类， 兄弟移除current类。

③触发的事件是页面滚动，因此这个功能要写到页面滚动事件里面。

④需要用到each，遍历内容区域大模块。 each里面能拿到内容区域每一个模块元素和索引号

⑤判断的条件：  被卷去的头部 大于等于 内容区域里面每个模块的offset().top

⑥就利用这个索引号找到相应的电梯导航小li添加类。
```

## **jQuery** **事件**

目标：

```
能够说出4种常见的注册事件 

能够说出 on 绑定事件的优势

能够说出 jQuery 事件委派的优点以及方式

能够说出绑定事件与解绑事件
```

### **jQuery**事件注册**

> 语法：element.事件(function(){})

```
$(“div”).click(function(){  事件处理程序 })       
```

> 其他事件和原生基本一致。
>
> 比如mouseover、mouseout、blur、focus、change、keydown、keyup、resize、scroll 等

### **事件处理** **on()** **绑定事件**

> on() 方法在匹配元素上绑定一个或多个事件的事件处理函数

> 语法：element.on(events,[selector],fn)

```
\1. events:一个或多个用空格分隔的事件类型，如"click"或"keydown" 。

\2. selector: 元素的子元素选择器 。

\3. fn:回调函数 即绑定在元素身上的侦听函数。 
```

**on() 方法优势1：**

1、可以绑定多个事件，多个处理事件处理程序。 

```
 $(“div”).on({

  mouseover: function(){}, 

  mouseout: function(){},

  click: function(){}  

});       
```

**on() 方法优势2：**

> 可以事件委派操作。事件委派的定义就是，把原来加给子元素身上的事件绑定在父元素身上，就是把事件委派给父元素。

```
$('ul').on('click', 'li', function() {

​    alert('hello world!');

});    
```

> 在此之前有bind(), live()，delegate()等方法来处理事件绑定或者事件委派，最新版本的请用on替代他们。  

**on() 方法优势3：**

> 动态创建的元素，click()没有办法绑定事件，on() 可以给动态生成的元素绑定事件

```
 $(“div").on("click",”p”, function(){

​     alert("俺可以给动态生成的元素绑定事件")

 });       
```

### 案例：发布微博案例

> ①点击发布按钮， 动态创建一个小li，放入文本框的内容和删除按钮， 并且添加到ul 中。
>
> ②点击的删除按钮，可以删除当前的微博留言。

### **事件处理** **off()** **解绑事件**

> off() 方法可以移除通过 on() 方法添加的事件处理程序。

```
$("p").off() // 解绑p元素所有事件处理程序

$("p").off( "click")  // 解绑p元素上面的点击事件 后面的 foo 是侦听函数名

$("ul").off("click", "li");   // 解绑事件委托
```

> 如果有的事件只想触发一次， 可以使用 one()来绑定事件。

### **自动触发事件trigger()** 

> 有些事件希望自动触发, 比如轮播图自动播放功能跟点击右侧按钮一致。可以利用定时器自动触发右侧按钮点击事件，不必鼠标点击触发

> element.click()  // 第一种简写形式

> element.trigger("type")//第二种自动触发模式

```
$("p").on("click", function () {

  alert("hi~");

}); 

$("p").trigger("click"); // 此时自动触发点击事件，不需要鼠标点击
```

> element.triggerHandler(type)  // 第三种自动触发模式

> triggerHandler模式不会触发元素的默认行为，这是和前面两种的区别。