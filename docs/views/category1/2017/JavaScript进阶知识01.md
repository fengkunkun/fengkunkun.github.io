---
title: JavaScript进阶知识-01
date: 2017-07-06 17:13:34
categories:
 -  技术
---

##### JavaScript进阶知识-01

JavaScript进阶知识

<!--more-->

# 01-JavaScript进阶

## 核心知识点

- 理解面向对象编程
- 类（构造函数）和对象
- 原型



## 一. JS高级要学什么【了解】

- **面向对象编程（理论 + 实战）** 
  - 类和对象
  - 原型
  - 实战（贪吃蛇游戏）
- **继承** 
  - 原型继承
  - 借用继承
  - 组合继承
- **JS函数进阶** 
  - 函数内部this的指向
  - call/apply/bind 更改函数内部this指向
  - 高阶函数（函数作为函数的参数 和 函数作为函数的返回值）
  - 闭包
  - 递归
- **正则表达式** 
  - 正则语法
  - RegExp对象
  - 表单验证（登录 注册）



## 二. 面向对象理论篇【了解】

### 2.1 面向过程和面向对象

- 面向过程：关注的是**过程**中的每一步
  现实需求（吃蛋炒饭）：开始→买鸡蛋→买米→炒蛋→蒸米.......→蛋炒饭→ 结束
- 面向对象：关注的是**对象**能做什么，找对象做事
  现实需求：（吃蛋炒饭）: 老婆或老公或厨师做蛋炒饭（开始→买鸡蛋→买米→炒蛋→蒸米.......→蛋炒饭→ 结束）

- 注意：面向对象不是替代面向过程，而是对过程的高度封装。



### 2.2 如何面向对象编程

- 面向对象编程的概念：

  > ​	Object Oriented Programming，简称 OOP ，是一种面向对象**编程开发思想** 。它将**真实世界各种复杂的关系** ，**抽象为一个个对象** ，然后由**对象之间**的**分工**与**合作**，完成对真实世界的模拟。
  >
  > ① 真实世界各种复杂的关系：盖房子
  >
  > ② 抽象为一个个对象（找对象）：找人，需要设计师、搬运工、砌墙师
  >
  > ③ 对象之间的分工：设计师设计图纸、搬运工搬砖，搬运材料、砌墙师砌墙
  >
  > ④ 对象之间的合作：搬运工搬砖给砌墙师用
  >
  > ⑤ 完成

  

- 面向对象编程的步骤：（重点）

  1. 明确需求
  2. 划分对象
  3. 对象分工
  4. 对象合作
  5. 完成目标



### 2.3 面向对象的好处

- 适合大型项目的开发，提高开发效率
- 易于维护。



### 2.4 面向对象的特征

- **封装**：把过程封装到对象中
- **继承**：子承父业。减少代码冗余（减少代码量）
- [多态]：一种事物（动物），具有多种形态（一条狗、一只猫.....）。 





## 三.类和对象【重点】

### 3.1 什么是类

- **生活中**：一类、种类

- **编程中**：

  - 类指的是抽象的名称：狗
  - class关键字，ES6之前没有类的概念。 我们现在学的是ECMAScript3和ES5
  - 在ES3或ES5中通过**构造函数** 来创建对象
  - 构造函数：
    - 内置的：Object、Date、Array等  
    - 自定义：Dog
  - 总结：现阶段我们通过==构造函数== 来创建对象
  - new关键字

  

### 3.2 什么是对象

- 生活中：万物皆对象。任何具体的事和物都可以看成对象

- 编程中：对象由**属性**和**方法**组成（或由键值对）。 具体的实例，实例对象

  - 属性：对象的静态特征，咱们班的班长，姓名、年龄、身高、性别

  - 方法：对象的功能特征，咱们班的班长，点名、写代码

  - 注意事项：

    - 方法的值用什么表示，用函数来表示
    - 对象方法中的this，指向调用者。

    



### 3.3 类（构造函数）和对象的关系

- 类是对象的模板
- 对象是类的具体实例（通过关键字 instanceof 检测一个对象是否属于某一个类型）
  - 语法：对象名 instanceof 构造函数名;  返回布尔值
- 创建对象得通过类（构造函数）创建
- new 构造函数() → 具体的实例



### 3.4 创建对象

- 语法：自定义构造函数

  > ```javascript
  > function 构造函数名(参数...){
  >  this.key = value；
  >  .......
  > }
  > // 注意规范：构造函数名首字母要大写  帕斯卡（每个单词首字母大写）  驼峰（从第二个单词开始首字母大写）
  > ```
  >
  > 

- 语法：**new**关键字创建对象

  > ```javascript
  > var 对象名 = new 构造函数名(实参...);
  > ```



### 3.5 new关键字的执行过程

- 代码：

  > ```javascript
  >  function Student(name,age,gender) {
  >    // 属性
  >    this.name = name;
  >    this.age = age;
  >    this.gender = gender;
  >    // 方法
  >    this.sayHi = function() {
  >      // 方法内部：this 代表的是调用方法的对象
  >      console.log('我叫什么' + this.name)
  >    };
  >    this.writeCode = function() {
  >      console.log('我会写code');
  >    }
  >  }
  >  // 创建对象
  >  var zs = new Student('张三',10,'男');
  >  // 使用对象
  >  zs.writeCode();
  > 
  > ```
  >
  > 

- 理论：

  > - // 1. 会向内存申请一块空间，存放对象。
  > - // 2. this关键字会指向内存中存放对象的空间。（this代表了当前创建的对象）
  > - // 3. 通过this关键字向内存中的对象中添加属性和方法
  > - // 4. 会把this返回给外部接收的变量

  

- 总结：构造函数在执行时，内部的this指向当前创建的对象



### 3.6 构造函数和普通函数

- 相同点

  - 都是函数

- 不同点

  - 构造函数通过new关键字调用
  - 普通函数直接调用

  



### 3.7 案例

1. 根据需求定义学生构造函数，并创建3个学生对象。
   - 需求：每一个学生会自我介绍（叫什么、多大了）、敲代码、唱歌



## 四.原型【重点】

### 4.1 为什么要学习原型

- 问题：若不用原型，则会产生内存浪费问题。
- 原因：方法放在构造函数中，每次new时，都会向对象中添加方法。 
- 解决方案：把方法放到原型中，就可以让同类型的对象共享 。

### 4.2 什么是原型

- 原型就是一个对象，原型一直都在。
- 获取原型：
  - 语法：`构造函数名.prototype`

### 4.3 构造函数和原型的关系

- 理论

  - 构造函数可以通过  prototype  获取到原型 
  - 原型可以通过 constructor  找到构造函数 

- 代码

  > ```javascript
  >  // 学生类→ 构造函数
  >  function Student(name,age,gender) {
  >    // 属性
  >    this.name = name;
  >    this.age = age;
  >    this.gender = gender;
  >  }
  > 
  >  // 获取原型
  >  // 每一个函数都有一个对应的原型
  >  var yx = Student.prototype;
  >  console.log(yx);
  >  // 原型是一个对象
  >  // 自带了一个成员：constructor → 构造函数
  >  console.log(yx.constructor === Student);
  > ```
  >
  > 

### 4.4 原型的作用

​    	节省内存。 因为原型中存放的成员（属性或方法），都可以被相关的构造函数所创建的对象==共享==。

### 4.5 实例对象和原型的关系

- 理论

  > - // ① 首先，会从对象本身中去找
  > - // ② 若对象中，找不到，则会通过`__proto__`所提供的原型地址，找原型
  > - // ③ 去原型中查找。

- 代码

  > ```javascript
  >  // 学生类→ 构造函数
  >  function Student(name, age, gender) {
  >    // 属性
  >    this.name = name;
  >    this.age = age;
  >    this.gender = gender;
  >    // this.type = '学生'
  >  }
  > 
  >  // 获取原型
  >  // 每一个函数都有一个对应的原型
  >  var yx = Student.prototype;
  >  // 对象.key = value
  >  // 方法
  >  yx.sayHi = function () {
  >    // 方法内部：this 代表的是调用方法的对象
  >    console.log('我叫什么' + this.name)
  >  };
  >  yx.writeCode = function () {
  >    console.log('我会写code');
  >  }
  >  yx.type = '学生';
  > 
  >  // 创建对象
  >  var zs = new Student('张三', 10, '男');
  >  // 创建对象
  >  var ls = new Student('李四', 11, '男');
  >  // 创建对象
  >  var ww = new Student('王五', 17, '女');
  > ```
  >
  > 

  