<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="前端基础 - 复习"><meta name="keywords" content=""><meta name="author" content="Sumind"><meta name="copyright" content="Sumind"><title>前端基础 - 复习 | Sumindの世界</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-5"><a class="toc-link" href="#前端基础-复习"><span class="toc-number">1.</span> <span class="toc-text">前端基础 - 复习</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一、CSS"><span class="toc-number"></span> <span class="toc-text">一、CSS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-盒模型"><span class="toc-number"></span> <span class="toc-text">1. 盒模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-BFC"><span class="toc-number"></span> <span class="toc-text">2. BFC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-层叠上下文"><span class="toc-number"></span> <span class="toc-text">3.层叠上下文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-居中布局"><span class="toc-number"></span> <span class="toc-text">4. 居中布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-选择器优先级"><span class="toc-number"></span> <span class="toc-text">5. 选择器优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-去除浮动影响，防止父级高度塌陷"><span class="toc-number"></span> <span class="toc-text">6.去除浮动影响，防止父级高度塌陷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-link-与-import-的区别"><span class="toc-number"></span> <span class="toc-text">7.link 与 @import 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-CSS预处理器-Sass-Less-Postcss"><span class="toc-number"></span> <span class="toc-text">8. CSS预处理器(Sass&#x2F;Less&#x2F;Postcss)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-CSS动画"><span class="toc-number"></span> <span class="toc-text">9.CSS动画</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、JavaScript"><span class="toc-number"></span> <span class="toc-text">二、JavaScript</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-原型-构造函数-实例"><span class="toc-number"></span> <span class="toc-text">1. 原型 &#x2F; 构造函数 &#x2F; 实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-原型链："><span class="toc-number"></span> <span class="toc-text">2.原型链：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-执行上下文-EC"><span class="toc-number"></span> <span class="toc-text">3. 执行上下文(EC)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-变量对象"><span class="toc-number"></span> <span class="toc-text">4.变量对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-作用域"><span class="toc-number"></span> <span class="toc-text">5. 作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-作用域链"><span class="toc-number"></span> <span class="toc-text">6.作用域链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-闭包"><span class="toc-number"></span> <span class="toc-text">7. 闭包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-script-引入方式："><span class="toc-number"></span> <span class="toc-text">8. script 引入方式：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-对象的拷贝"><span class="toc-number"></span> <span class="toc-text">9. 对象的拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-new运算符的执行过程"><span class="toc-number"></span> <span class="toc-text">10. new运算符的执行过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-instanceof原理"><span class="toc-number"></span> <span class="toc-text">11. instanceof原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-代码的复用"><span class="toc-number"></span> <span class="toc-text">12. 代码的复用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-继承"><span class="toc-number"></span> <span class="toc-text">13. 继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-类型转换"><span class="toc-number"></span> <span class="toc-text">14. 类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-类型判断"><span class="toc-number"></span> <span class="toc-text">15. 类型判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-模块化"><span class="toc-number"></span> <span class="toc-text">16. 模块化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-防抖与节流"><span class="toc-number"></span> <span class="toc-text">17. 防抖与节流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-函数执行改变this"><span class="toc-number"></span> <span class="toc-text">18. 函数执行改变this</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-ES6-ES7"><span class="toc-number"></span> <span class="toc-text">19. ES6&#x2F;ES7</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-AST"><span class="toc-number"></span> <span class="toc-text">20. AST</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-babel编译原理"><span class="toc-number"></span> <span class="toc-text">21. babel编译原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-函数柯里化"><span class="toc-number"></span> <span class="toc-text">22. 函数柯里化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-数组-array"><span class="toc-number"></span> <span class="toc-text">23. 数组(array)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、浏览器"><span class="toc-number"></span> <span class="toc-text">三、浏览器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-跨标签页通讯"><span class="toc-number"></span> <span class="toc-text">1. 跨标签页通讯</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-浏览器架构"><span class="toc-number"></span> <span class="toc-text">2. 浏览器架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-浏览器下事件循环-Event-Loop"><span class="toc-number"></span> <span class="toc-text">3. 浏览器下事件循环(Event Loop)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-从输入-url-到展示的过程"><span class="toc-number"></span> <span class="toc-text">4. 从输入 url 到展示的过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-重绘与回流"><span class="toc-number"></span> <span class="toc-text">5. 重绘与回流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-存储"><span class="toc-number"></span> <span class="toc-text">6. 存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-Web-Worker"><span class="toc-number"></span> <span class="toc-text">7. Web Worker</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-内存泄露"><span class="toc-number"></span> <span class="toc-text">8. 内存泄露</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、服务端与网络"><span class="toc-number"></span> <span class="toc-text">四、服务端与网络</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-http-https-协议"><span class="toc-number"></span> <span class="toc-text">1. http&#x2F;https 协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-常见状态码"><span class="toc-number"></span> <span class="toc-text">2. 常见状态码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-get-post"><span class="toc-number"></span> <span class="toc-text">3. get &#x2F; post</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Websocket"><span class="toc-number"></span> <span class="toc-text">4. Websocket</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-TCP三次握手"><span class="toc-number"></span> <span class="toc-text">5. TCP三次握手</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-TCP四次挥手"><span class="toc-number"></span> <span class="toc-text">6. TCP四次挥手</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-Node-的-Event-Loop-6个阶段"><span class="toc-number"></span> <span class="toc-text">7. Node 的 Event Loop: 6个阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-跨域"><span class="toc-number"></span> <span class="toc-text">8. 跨域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-安全"><span class="toc-number"></span> <span class="toc-text">9. 安全</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五、框架：Vue"><span class="toc-number"></span> <span class="toc-text">五、框架：Vue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-nextTick"><span class="toc-number"></span> <span class="toc-text">1. nextTick</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-生命周期"><span class="toc-number"></span> <span class="toc-text">2. 生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Proxy-相比于-defineProperty-的优势"><span class="toc-number"></span> <span class="toc-text">3. Proxy 相比于 defineProperty 的优势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-vue-router"><span class="toc-number"></span> <span class="toc-text">4. vue-router</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-vuex"><span class="toc-number"></span> <span class="toc-text">5. vuex</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#"><span class="toc-number"></span> <span class="toc-text"></span></a></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://gitee.com/sumind/picCloud/raw/master/img/Head-portrait.jpg"></div><div class="author-info__name text-center">Sumind</div><div class="author-info__description text-center">人生没有白走的路，每一步都算数</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">32</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">3</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://gitee.com/sumind/picCloud/raw/master/img/top_img.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Sumindの世界</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">时间轴</a><a class="site-page" href="/gallery">相册</a><a class="site-page" href="/about">关于我</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">前端基础 - 复习</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-03-20</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/">资料整理</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h5 id="前端基础-复习"><a href="#前端基础-复习" class="headerlink" title="前端基础 - 复习"></a>前端基础 - 复习</h5><p>资料整理</p>
<a id="more"></a>



<h2 id="一、CSS"><a href="#一、CSS" class="headerlink" title="一、CSS"></a>一、CSS</h2><h3 id="1-盒模型"><a href="#1-盒模型" class="headerlink" title="1. 盒模型"></a>1. 盒模型</h3><blockquote>
<p>页面渲染时，<code>dom</code> 元素所采用的 布局模型。可通过<code>box-sizing</code>进行设置。根据计算宽高的区域可分为</p>
</blockquote>
<ul>
<li><code>content-box</code> (<code>W3C</code> 标准盒模型)</li>
<li><code>border-box</code> (<code>IE</code> 盒模型)</li>
<li><code>padding-box</code></li>
<li><code>margin-box</code> (浏览器未实现)</li>
</ul>
<h3 id="2-BFC"><a href="#2-BFC" class="headerlink" title="2. BFC"></a>2. BFC</h3><blockquote>
<p>块级格式化上下文，是一个独立的渲染区域，让处于 <code>BFC</code> 内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。</p>
</blockquote>
<blockquote>
<p>IE下为 <code>Layout</code>，可通过 <code>zoom:1</code> 触发</p>
</blockquote>
<p><strong>触发条件:</strong></p>
<ul>
<li>根元素</li>
<li><code>position: absolute/fixed</code></li>
<li><code>display: inline-block / table</code></li>
<li><code>float</code> 元素</li>
<li><code>ovevflow !== visible</code></li>
</ul>
<p><strong>规则:</strong></p>
<ul>
<li>属于同一个 <code>BFC</code> 的两个相邻 <code>Box</code> 垂直排列</li>
<li>属于同一个 <code>BFC</code> 的两个相邻 <code>Box</code> 的 <code>margin</code> 会发生重叠</li>
<li><code>BFC</code> 中子元素的 <code>margin box</code> 的左边， 与包含块 (BFC) <code>border box</code>的左边相接触 (子元素 <code>absolute</code> 除外)</li>
<li><code>BFC</code> 的区域不会与 <code>float</code> 的元素区域重叠</li>
<li>计算 <code>BFC</code> 的高度时，浮动子元素也参与计算</li>
<li>文字层不会被浮动层覆盖，环绕于周围</li>
</ul>
<p><strong>应用:</strong></p>
<ul>
<li>阻止<code>margin</code>重叠</li>
<li>可以包含浮动元素 —— 清除内部浮动(清除浮动的原理是两个<code>div</code>都位于同一个 <code>BFC</code> 区域之中)</li>
<li>自适应两栏布局</li>
<li>可以阻止元素被浮动元素覆盖</li>
</ul>
<h3 id="3-层叠上下文"><a href="#3-层叠上下文" class="headerlink" title="3.层叠上下文"></a>3.层叠上下文</h3><blockquote>
<p>元素提升为一个比较特殊的图层，在三维空间中 (z轴) 高出普通元素一等。</p>
</blockquote>
<p><strong>触发条件</strong></p>
<ul>
<li>根层叠上下文(<code>html</code>)</li>
<li><code>position</code></li>
<li><code>css3</code>属性<ul>
<li><code>flex</code></li>
<li><code>transform</code></li>
<li><code>opacity</code></li>
<li><code>filter</code></li>
<li><code>will-change</code></li>
<li><code>webkit-overflow-scrolling</code></li>
</ul>
</li>
</ul>
<p><strong>层叠等级：层叠上下文在z轴上的排序</strong></p>
<ul>
<li>在同一层叠上下文中，层叠等级才有意义</li>
<li><code>z-index</code>的优先级最高</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2019/2/14/168e9d9f3a1d368b" alt=""></p>
<h3 id="4-居中布局"><a href="#4-居中布局" class="headerlink" title="4. 居中布局"></a>4. 居中布局</h3><p><strong>水平居中</strong></p>
<ul>
<li>行内元素: <code>text-align: center</code></li>
<li>块级元素: <code>margin: 0 auto</code></li>
<li><code>absolute + transform</code></li>
<li><code>flex + justify-content: center</code></li>
</ul>
<p><strong>垂直居中</strong></p>
<ul>
<li><code>line-height: height</code></li>
<li><code>absolute + transform</code></li>
<li><code>flex + align-items: center</code></li>
<li><code>table</code></li>
</ul>
<p><strong>水平垂直居中</strong></p>
<ul>
<li><code>absolute + transform</code></li>
<li><code>flex + justify-content + align-items</code></li>
</ul>
<h3 id="5-选择器优先级"><a href="#5-选择器优先级" class="headerlink" title="5. 选择器优先级"></a>5. 选择器优先级</h3><ul>
<li><code>!important</code> &gt; 行内样式 &gt; <code>#id</code> &gt; <code>.class</code> &gt; <code>tag</code> &gt; <code>*</code> &gt; 继承 &gt; 默认</li>
<li>选择器 从右往左 解析</li>
</ul>
<h3 id="6-去除浮动影响，防止父级高度塌陷"><a href="#6-去除浮动影响，防止父级高度塌陷" class="headerlink" title="6.去除浮动影响，防止父级高度塌陷"></a>6.去除浮动影响，防止父级高度塌陷</h3><ul>
<li>通过增加尾元素清除浮动</li>
<li><code>:after / &lt;br&gt; : clear: both</code></li>
<li>创建父级 <code>BFC</code></li>
<li>父级设置高度</li>
</ul>
<h3 id="7-link-与-import-的区别"><a href="#7-link-与-import-的区别" class="headerlink" title="7.link 与 @import 的区别"></a>7.link 与 @import 的区别</h3><ul>
<li><code>link</code>功能较多，可以定义 <code>RSS</code>，定义 <code>Rel</code> 等作用，而<code>@import</code>只能用于加载 <code>css</code></li>
<li>当解析到<code>link</code>时，页面会同步加载所引的 <code>css</code>，而<code>@import</code>所引用的 <code>css</code> 会等到页面加载完才被加载</li>
<li><code>@import</code>需要 <code>IE5</code> 以上才能使用</li>
<li><code>link</code>可以使用 <code>js</code> 动态引入，<code>@import</code>不行</li>
</ul>
<h3 id="8-CSS预处理器-Sass-Less-Postcss"><a href="#8-CSS预处理器-Sass-Less-Postcss" class="headerlink" title="8. CSS预处理器(Sass/Less/Postcss)"></a>8. CSS预处理器(Sass/Less/Postcss)</h3><blockquote>
<p><code>CSS</code>预处理器的原理: 是将类 <code>CSS</code>语言通过 <code>Webpack</code> 编译 转成浏览器可读的真正 <code>CSS</code>。在这层编译之上，便可以赋予 <code>CSS</code> 更多更强大的功能，常用功能:</p>
</blockquote>
<ul>
<li>嵌套</li>
<li>变量</li>
<li>循环语句</li>
<li>条件语句</li>
<li>自动前缀</li>
<li>单位转换</li>
<li><code>mixin</code>复用</li>
</ul>
<blockquote>
<p>面试中一般不会重点考察该点，一般介绍下自己在实战项目中的经验即可~</p>
</blockquote>
<h3 id="9-CSS动画"><a href="#9-CSS动画" class="headerlink" title="9.CSS动画"></a>9.CSS动画</h3><p><strong>transition: 过渡动画</strong></p>
<ul>
<li><code>transition-property</code>: 属性</li>
<li><code>transition-duration</code>: 间隔</li>
<li><code>transition-timing-function</code>: 曲线</li>
<li><code>transition-delay</code>: 延迟</li>
<li>常用钩子: <code>transitionend</code></li>
</ul>
<p><strong>animation / keyframes</strong></p>
<ul>
<li><code>animation-name</code>: 动画名称，对应<code>@keyframes</code></li>
<li><code>animation-duration</code>: 间隔</li>
<li><code>animation-timing-function</code>: 曲线</li>
<li><code>animation-delay</code>: 延迟</li>
<li><code>animation-iteration-count</code>: 次数<ul>
<li><code>infinite</code>: 循环动画</li>
</ul>
</li>
<li><code>animation-direction</code>: 方向<ul>
<li><code>alternate</code>: 反向播放</li>
</ul>
</li>
<li><code>animation-fill-mode</code>: 静止模式<ul>
<li><code>forwards</code>: 停止时，保留最后一帧</li>
<li><code>backwards</code>: 停止时，回到第一帧</li>
<li><code>both</code>: 同时运用 <code>forwards / backwards</code></li>
</ul>
</li>
<li>常用钩子: <code>animationend</code></li>
</ul>
<blockquote>
<p>动画属性: 尽量使用动画属性进行动画，能拥有较好的性能表现</p>
</blockquote>
<ul>
<li><code>translate</code></li>
<li><code>scale</code></li>
<li><code>rotate</code></li>
<li><code>skew</code></li>
<li><code>opacity</code></li>
<li><code>color</code></li>
</ul>
<h2 id="二、JavaScript"><a href="#二、JavaScript" class="headerlink" title="二、JavaScript"></a>二、JavaScript</h2><h3 id="1-原型-构造函数-实例"><a href="#1-原型-构造函数-实例" class="headerlink" title="1. 原型 / 构造函数 / 实例"></a>1. 原型 / 构造函数 / 实例</h3><ul>
<li>原型(<code>prototype</code>): 一个简单的对象，用于实现对象的 属性继承。可以简单的理解成对象的爹。在 <code>Firefox</code> 和 <code>Chrome</code> 中，每个<code>JavaScript</code>对象中都包含一个<code>__proto__</code>(非标准)的属性指向它爹(该对象的原型)，可<code>obj.__proto__</code>进行访问。</li>
<li>构造函数: 可以通过<code>new</code>来 新建一个对象 的函数。</li>
<li>实例: 通过构造函数和<code>new</code>创建出来的对象，便是实例。 实例通过<code>__proto__</code>指向原型，通过<code>constructor</code>指向构造函数。</li>
</ul>
<blockquote>
<p>以<code>Object</code>为例，我们常用的<code>Object</code>便是一个构造函数，因此我们可以通过它构建实例。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实例</span></span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>则此时， 实例为<code>instance</code>, 构造函数为<code>Object</code>，我们知道，构造函数拥有一个<code>prototype</code>的属性指向原型，因此原型为:</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原型</span></span><br><span class="line"><span class="keyword">const</span> prototype = <span class="built_in">Object</span>.prototype</span><br></pre></td></tr></table></figure>

<p><strong>这里我们可以来看出三者的关系:</strong></p>
<ul>
<li><code>实例.__proto__ === 原型</code></li>
<li><code>原型.constructor === 构造函数</code></li>
<li><code>构造函数.prototype === 原型</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 这条线其实是是基于原型进行获取的，可以理解成一条基于原型的映射线</span><br><span class="line">&#x2F;&#x2F; 例如: </span><br><span class="line">&#x2F;&#x2F; const o &#x3D; new Object()</span><br><span class="line">&#x2F;&#x2F; o.constructor &#x3D;&#x3D;&#x3D; Object   --&gt; true</span><br><span class="line">&#x2F;&#x2F; o.__proto__ &#x3D; null;</span><br><span class="line">&#x2F;&#x2F; o.constructor &#x3D;&#x3D;&#x3D; Object   --&gt; false</span><br><span class="line">实例.constructor &#x3D;&#x3D;&#x3D; 构造函数</span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2019/2/14/168e9d9b940c4c6f" alt=""></p>
<h3 id="2-原型链："><a href="#2-原型链：" class="headerlink" title="2.原型链："></a>2.原型链：</h3><blockquote>
<p>原型链是由原型对象组成，每个对象都有 <code>__proto__</code> 属性，指向了创建该对象的构造函数的原型，<code>__proto__</code> 将对象连接起来组成了原型链。是一个用来实现继承和共享属性的有限的对象链</p>
</blockquote>
<ul>
<li>属性查找机制: 当查找对象的属性时，如果实例对象自身不存在该属性，则沿着原型链往上一级查找，找到时则输出，不存在时，则继续沿着原型链往上一级查找，直至最顶级的原型对象<code>Object.prototype</code>，如还是没找到，则输出<code>undefined</code>；</li>
<li>属性修改机制: 只会修改实例对象本身的属性，如果不存在，则进行添加该属性，如果需要修改原型的属性时，则可以用: <code>b.prototype.x = 2</code>；但是这样会造成所有继承于该对象的实例的属性发生改变。</li>
</ul>
<h3 id="3-执行上下文-EC"><a href="#3-执行上下文-EC" class="headerlink" title="3. 执行上下文(EC)"></a>3. 执行上下文(EC)</h3><blockquote>
<p>执行上下文可以简单理解为一个对象:</p>
</blockquote>
<p><strong>它包含三个部分:</strong></p>
<ul>
<li>变量对象(<code>VO</code>)</li>
<li>作用域链(词法作用域)</li>
<li><code>this</code>指向</li>
</ul>
<p><strong>它的类型:</strong></p>
<ul>
<li>全局执行上下文</li>
<li>函数执行上下文</li>
<li><code>eval</code>执行上下文</li>
</ul>
<p><strong>代码执行过程:</strong></p>
<ul>
<li>创建 全局上下文 (<code>global EC</code>)</li>
<li>全局执行上下文 (<code>caller</code>) 逐行 自上而下 执行。遇到函数时，函数执行上下文 (<code>callee</code>) 被<code>push</code>到执行栈顶层</li>
<li>函数执行上下文被激活，成为 <code>active EC</code>, 开始执行函数中的代码，<code>caller</code> 被挂起</li>
<li>函数执行完后，<code>callee</code> 被<code>pop</code>移除出执行栈，控制权交还全局上下文 (<code>caller</code>)，继续执行</li>
</ul>
<h3 id="4-变量对象"><a href="#4-变量对象" class="headerlink" title="4.变量对象"></a>4.变量对象</h3><ul>
<li>变量对象，是执行上下文中的一部分，可以抽象为一种 数据作用域，其实也可以理解为就是一个简单的对象，它存储着该执行上下文中的所有 变量和函数声明(不包含函数表达式)。</li>
<li>活动对象 (<code>AO</code>): 当变量对象所处的上下文为 <code>active EC</code> 时，称为活动对象。</li>
</ul>
<h3 id="5-作用域"><a href="#5-作用域" class="headerlink" title="5. 作用域"></a>5. 作用域</h3><blockquote>
<p>执行上下文中还包含作用域链。理解作用域之前，先介绍下作用域。作用域其实可理解为该上下文中声明的 变量和声明的作用范围。可分为 块级作用域 和 函数作用域</p>
</blockquote>
<p><strong>特性:</strong></p>
<ul>
<li>声明提前: 一个声明在函数体内都是可见的, 函数优先于变量</li>
<li>非匿名自执行函数，函数变量为 只读 状态，无法修改</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="number">1</span>) &#125;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    foo = <span class="number">10</span>  <span class="comment">// 由于foo在函数中只为可读，因此赋值无效</span></span><br><span class="line">    <span class="built_in">console</span>.log(foo)</span><br><span class="line">&#125;()) </span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果打印：  ƒ foo() &#123; foo = 10 ; console.log(foo) &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="6-作用域链"><a href="#6-作用域链" class="headerlink" title="6.作用域链"></a>6.作用域链</h3><blockquote>
<p>我们知道，我们可以在执行上下文中访问到父级甚至全局的变量，这便是作用域链的功劳。作用域链可以理解为一组对象列表，包含 父级和自身的变量对象，因此我们便能通过作用域链访问到父级里声明的变量或者函数。</p>
</blockquote>
<p><strong>由两部分组成:</strong></p>
<ul>
<li><code>[[scope]]</code>属性: 指向父级变量对象和作用域链，也就是包含了父级的<code>[[scope]]</code>和<code>AO</code></li>
<li><code>AO</code>: 自身活动对象</li>
</ul>
<blockquote>
<p>如此 <code>[[scopr]]</code>包含<code>[[scope]]</code>，便自上而下形成一条 链式作用域。</p>
</blockquote>
<h3 id="7-闭包"><a href="#7-闭包" class="headerlink" title="7. 闭包"></a>7. 闭包</h3><blockquote>
<p>闭包属于一种特殊的作用域，称为 静态作用域。它的定义可以理解为: 父函数被销毁 的情况下，返回出的子函数的<code>[[scope]]</code>中仍然保留着父级的单变量对象和作用域链，因此可以继续访问到父级的变量对象，这样的函数称为闭包。</p>
</blockquote>
<p><strong>闭包会产生一个很经典的问题:</strong></p>
<blockquote>
<p>多个子函数的<code>[[scope]]</code>都是同时指向父级，是完全共享的。因此当父级的变量对象被修改时，所有子函数都受到影响。</p>
</blockquote>
<p>••解决:**</p>
<ul>
<li>变量可以通过 函数参数的形式 传入，避免使用默认的<code>[[scope]]</code>向上查找</li>
<li>使用<code>setTimeout</code>包裹，通过第三个参数传入</li>
<li>使用 块级作用域，让变量成为自己上下文的属性，避免共享</li>
</ul>
<h3 id="8-script-引入方式："><a href="#8-script-引入方式：" class="headerlink" title="8. script 引入方式："></a>8. script 引入方式：</h3><ul>
<li><code>html</code> 静态<code>&lt;script&gt;</code>引入</li>
<li><code>js</code> 动态插入<code>&lt;script&gt;</code></li>
<li><code>&lt;script defer&gt;</code>: 异步加载，元素解析完成后执行</li>
<li><code>&lt;script async&gt;</code>: 异步加载，但执行时会阻塞元素渲染</li>
</ul>
<h3 id="9-对象的拷贝"><a href="#9-对象的拷贝" class="headerlink" title="9. 对象的拷贝"></a>9. 对象的拷贝</h3><p><strong>浅拷贝: 以赋值的形式拷贝引用对象，仍指向同一个地址，修改时原对象也会受到影响</strong></p>
<ul>
<li><code>Object.assign</code></li>
<li>展开运算符(<code>...</code>)</li>
</ul>
<p><strong>深拷贝: 完全拷贝一个新对象，修改时原对象不再受到任何影响</strong></p>
<ul>
<li><code>JSON.parse(JSON.stringify(obj))</code>: 性能最快</li>
<li>具有循环引用的对象时，报错</li>
<li>当值为函数、<code>undefined</code>、或<code>symbol</code>时，无法拷贝</li>
<li>递归进行逐一赋值</li>
</ul>
<h3 id="10-new运算符的执行过程"><a href="#10-new运算符的执行过程" class="headerlink" title="10. new运算符的执行过程"></a>10. new运算符的执行过程</h3><ul>
<li>新生成一个对象</li>
<li>链接到原型: <code>obj.__proto__ = Con.prototype</code></li>
<li>绑定<code>this: apply</code></li>
<li>返回新对象(如果构造函数有自己 <code>retrun</code> 时，则返回该值)</li>
</ul>
<h3 id="11-instanceof原理"><a href="#11-instanceof原理" class="headerlink" title="11. instanceof原理"></a>11. instanceof原理</h3><blockquote>
<p>能在实例的 原型对象链 中找到该构造函数的<code>prototype</code>属性所指向的 原型对象，就返回<code>true</code>。即:</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// __proto__: 代表原型对象链</span></span><br><span class="line">instance.[__proto__...] === instance.constructor.prototype</span><br><span class="line"></span><br><span class="line"><span class="comment">// return true</span></span><br></pre></td></tr></table></figure>

<h3 id="12-代码的复用"><a href="#12-代码的复用" class="headerlink" title="12. 代码的复用"></a>12. 代码的复用</h3><blockquote>
<p>当你发现任何代码开始写第二遍时，就要开始考虑如何复用。一般有以下的方式:</p>
</blockquote>
<ul>
<li>函数封装</li>
<li>继承</li>
<li>复制<code>extend</code></li>
<li>混入<code>mixin</code></li>
<li>借用<code>apply/call</code></li>
</ul>
<h3 id="13-继承"><a href="#13-继承" class="headerlink" title="13. 继承"></a>13. 继承</h3><blockquote>
<p>在 JS 中，继承通常指的便是 原型链继承，也就是通过指定原型，并可以通过原型链继承原型上的属性或者方法。</p>
</blockquote>
<p><strong>最优化: 圣杯模式</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> inherit = (<span class="function"><span class="keyword">function</span>(<span class="params">c,p</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">c,p</span>)</span>&#123;</span><br><span class="line">		F.prototype = p.prototype;</span><br><span class="line">		c.prototype = <span class="keyword">new</span> F();</span><br><span class="line">		c.uber = p.prototype;</span><br><span class="line">		c.prototype.constructor = c;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用 <code>ES6</code> 的语法糖 <code>class / extends</code></p>
</blockquote>
<h3 id="14-类型转换"><a href="#14-类型转换" class="headerlink" title="14. 类型转换"></a>14. 类型转换</h3><blockquote>
<p>大家都知道 JS 中在使用运算符号或者对比符时，会自带隐式转换，规则如下:</p>
</blockquote>
<ul>
<li><code>-、*、/、%</code>：一律转换成数值后计算</li>
<li><strong>+：</strong><ul>
<li>数字 + 字符串 = 字符串， 运算顺序是从左到右</li>
<li>数字 + 对象， 优先调用对象的<code>valueOf -&gt; toString</code></li>
<li>数字 + <code>boolean/null</code> -&gt; 数字</li>
<li>数字 + <code>undefined</code> -&gt; <code>NaN</code></li>
</ul>
</li>
<li><code>[1].toString() === &#39;1&#39;</code></li>
<li><code>{}.toString() === &#39;[object object]&#39;</code></li>
<li><code>NaN !== NaN</code> 、+<code>undefined</code> 为 <code>NaN</code></li>
</ul>
<h3 id="15-类型判断"><a href="#15-类型判断" class="headerlink" title="15. 类型判断"></a>15. 类型判断</h3><blockquote>
<p>判断 <code>Target</code> 的类型，单单用 <code>typeof</code> 并无法完全满足，这其实并不是 <code>bug</code>，本质原因是 <code>JS</code> 的万物皆对象的理论。因此要真正完美判断时，我们需要区分对待:</p>
</blockquote>
<ul>
<li>基本类型(<code>null</code>): 使用 <code>String(null)</code></li>
<li>基本类型(<code>string / number / boolean / undefined</code>) + <code>function</code>: - 直接使用 <code>typeof</code>即可</li>
<li>其余引用类型(<code>Array / Date / RegExp Error</code>): 调用<code>toString</code>后根据<code>[object XXX]</code>进行判断</li>
</ul>
<p>很稳的判断封装:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> class2type = &#123;&#125;</span><br><span class="line"><span class="string">'Array Date RegExp Object Error'</span>.split(<span class="string">' '</span>).forEach(<span class="function"><span class="params">e</span> =&gt;</span> class2type[ <span class="string">'[object '</span> + e + <span class="string">']'</span> ] = e.toLowerCase()) </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">type</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">null</span>) <span class="keyword">return</span> <span class="built_in">String</span>(obj)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> obj === <span class="string">'object'</span> ? class2type[ <span class="built_in">Object</span>.prototype.toString.call(obj) ] || <span class="string">'object'</span> : <span class="keyword">typeof</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="16-模块化"><a href="#16-模块化" class="headerlink" title="16. 模块化"></a>16. 模块化</h3><blockquote>
<p>模块化开发在现代开发中已是必不可少的一部分，它大大提高了项目的可维护、可拓展和可协作性。通常，我们 在浏览器中使用 <code>ES6</code> 的模块化支持，在 <code>Node</code> 中使用 <code>commonjs</code> 的模块化支持。</p>
</blockquote>
<p><strong>分类:</strong></p>
<ul>
<li><code>es6: import / export</code></li>
<li><code>commonjs: require / module.exports / exports</code></li>
<li><code>amd: require / defined</code></li>
</ul>
<p><strong>require与import的区别</strong></p>
<ul>
<li><code>require</code>支持 动态导入，<code>import</code>不支持，正在提案 (<code>babel</code> 下可支持)</li>
<li><code>require</code>是 同步 导入，<code>impor</code>t属于 异步 导入</li>
<li><code>require</code>是 值拷贝，导出值变化不会影响导入值；<code>import</code>指向 内存地址，导入值会随导出值而变化</li>
</ul>
<h3 id="17-防抖与节流"><a href="#17-防抖与节流" class="headerlink" title="17. 防抖与节流"></a>17. 防抖与节流</h3><blockquote>
<p>防抖与节流函数是一种最常用的 高频触发优化方式，能对性能有较大的帮助。</p>
</blockquote>
<ul>
<li>防抖 (debounce): 将多次高频操作优化为只在最后一次执行，通常使用的场景是：用户输入，只需再输入完成后做一次输入校验即可。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, wait, immediate</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span></span><br><span class="line">        <span class="keyword">let</span> context = <span class="keyword">this</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (immediate &amp;&amp; !timer) &#123;</span><br><span class="line">            fn.apply(context, args)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (timer) clearTimeout(timer)</span><br><span class="line">        timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            fn.apply(context, args)</span><br><span class="line">        &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>节流(throttle): 每隔一段时间后执行一次，也就是降低频率，将高频操作优化成低频操作，通常使用场景: 滚动条事件 或者 <code>resize</code> 事件，通常每隔 <code>100~500 ms</code>执行一次即可。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, wait, immediate</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> callNow = immediate</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="keyword">this</span>,</span><br><span class="line">            args = <span class="built_in">arguments</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (callNow) &#123;</span><br><span class="line">            fn.apply(context, args)</span><br><span class="line">            callNow = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">            timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                fn.apply(context, args)</span><br><span class="line">                timer = <span class="literal">null</span></span><br><span class="line">            &#125;, wait)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="18-函数执行改变this"><a href="#18-函数执行改变this" class="headerlink" title="18. 函数执行改变this"></a>18. 函数执行改变this</h3><ul>
<li>由于 JS 的设计原理: 在函数中，可以引用运行环境中的变量。因此就需要一个机制来让我们可以在函数体内部获取当前的运行环境，这便是<code>this</code>。</li>
</ul>
<blockquote>
<p>因此要明白 <code>this</code> 指向，其实就是要搞清楚 函数的运行环境，说人话就是，谁调用了函数。例如</p>
</blockquote>
<ul>
<li><code>obj.fn()</code>，便是 <code>obj</code> 调用了函数，既函数中的 <code>this === obj</code></li>
<li><code>fn()</code>，这里可以看成 <code>window.fn()</code>，因此 <code>this === window</code></li>
</ul>
<blockquote>
<p>但这种机制并不完全能满足我们的业务需求，因此提供了三种方式可以手动修改 <code>this</code> 的指向:</p>
</blockquote>
<ul>
<li><code>call: fn.call(target, 1, 2)</code></li>
<li><code>apply: fn.apply(target, [1, 2])</code></li>
<li><code>bind: fn.bind(target)(1,2)</code></li>
</ul>
<h3 id="19-ES6-ES7"><a href="#19-ES6-ES7" class="headerlink" title="19. ES6/ES7"></a>19. ES6/ES7</h3><blockquote>
<p>由于 <code>Babel</code>的强大和普及，现在 <code>ES6/ES7</code> 基本上已经是现代化开发的必备了。通过新的语法糖，能让代码整体更为简洁和易读。</p>
</blockquote>
<p><strong>声明</strong></p>
<ul>
<li><code>let / const</code>: 块级作用域、不存在变量提升、暂时性死区、不允许重复声明</li>
<li><code>const</code>: 声明常量，无法修改</li>
</ul>
<p><strong>解构赋值</strong></p>
<p><strong>class / extend: 类声明与继承</strong></p>
<p><strong>Set / Map: 新的数据结构</strong></p>
<p><strong>异步解决方案:</strong></p>
<ul>
<li><code>Promise</code>的使用与实现</li>
<li><code>generator</code>:<ul>
<li><code>yield</code>: 暂停代码</li>
<li><code>next()</code>: 继续执行代码</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">helloWorld</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'hello'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'world'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'ending'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> generator = helloWorld();</span><br><span class="line"></span><br><span class="line">generator.next()  <span class="comment">// &#123; value: 'hello', done: false &#125;</span></span><br><span class="line"></span><br><span class="line">generator.next()  <span class="comment">// &#123; value: 'world', done: false &#125;</span></span><br><span class="line"></span><br><span class="line">generator.next()  <span class="comment">// &#123; value: 'ending', done: true &#125;</span></span><br><span class="line"></span><br><span class="line">generator.next()  <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>await / async</code>: 是<code>generator</code>的语法糖， <code>babel</code>中是基于<code>promise</code>实现。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getUserByAsync</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">let</span> user = <span class="keyword">await</span> fetchUser();</span><br><span class="line">   <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user = <span class="keyword">await</span> getUserByAsync()</span><br><span class="line"><span class="built_in">console</span>.log(user)</span><br></pre></td></tr></table></figure>

<h3 id="20-AST"><a href="#20-AST" class="headerlink" title="20. AST"></a>20. AST</h3><blockquote>
<p>抽象语法树 (<code>Abstract Syntax Tree</code>)，是将代码逐字母解析成 树状对象 的形式。这是语言之间的转换、代码语法检查，代码风格检查，代码格式化，代码高亮，代码错误提示，代码自动补全等等的基础。例如:</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> n * n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过解析转化成的AST如下图:</p>
</blockquote>
<p><img src="https://user-gold-cdn.xitu.io/2019/2/14/168e9d95910dd187?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<h3 id="21-babel编译原理"><a href="#21-babel编译原理" class="headerlink" title="21. babel编译原理"></a>21. babel编译原理</h3><ul>
<li><code>babylon</code> 将 <code>ES6/ES7</code> 代码解析成 <code>AST</code></li>
<li><code>babel-traverse</code> 对 <code>AST</code> 进行遍历转译，得到新的 <code>AST</code></li>
<li>新 AST 通过 <code>babel-generator</code> 转换成 <code>ES5</code></li>
</ul>
<h3 id="22-函数柯里化"><a href="#22-函数柯里化" class="headerlink" title="22. 函数柯里化"></a>22. 函数柯里化</h3><blockquote>
<p>在一个函数中，首先填充几个参数，然后再返回一个新的函数的技术，称为函数的柯里化。通常可用于在不侵入函数的前提下，为函数 预置通用参数，供多次重复调用。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">y</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x + y</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> add1 = add(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">add1(<span class="number">2</span>) === <span class="number">3</span></span><br><span class="line">add1(<span class="number">20</span>) === <span class="number">21</span></span><br></pre></td></tr></table></figure>

<h3 id="23-数组-array"><a href="#23-数组-array" class="headerlink" title="23. 数组(array)"></a>23. 数组(array)</h3><ul>
<li><code>map</code>: 遍历数组，返回回调返回值组成的新数组</li>
<li><code>forEach</code>: 无法<code>break</code>，可以用<code>try/catch</code>中<code>throw new Error</code>来停止</li>
<li><code>filter</code>: 过滤</li>
<li><code>some</code>: 有一项返回<code>true</code>，则整体为<code>true</code></li>
<li><code>every</code>: 有一项返回<code>false</code>，则整体为<code>false</code></li>
<li><code>join</code>: 通过指定连接符生成字符串</li>
<li><code>push / pop</code>: 末尾推入和弹出，改变原数组， 返回推入/弹出项</li>
<li><code>unshift / shift</code>: 头部推入和弹出，改变原数组，返回操作项</li>
<li><code>sort(fn) / reverse</code>: 排序与反转，改变原数组</li>
<li><code>concat</code>: 连接数组，不影响原数组， 浅拷贝</li>
<li><code>slice(start, end)</code>: 返回截断后的新数组，不改变原数组</li>
<li><code>splice(start, number, value...)</code>: 返回删除元素组成的数组，<code>value</code>为插入项，改变原数组</li>
<li><code>indexOf / lastIndexOf(value, fromIndex)</code>: 查找数组项，返回对应的下标</li>
<li><code>reduce / reduceRight(fn(prev, cur)</code>， <code>defaultPrev)</code>: 两两执行，<code>prev</code> 为上次化简函数的<code>return</code>值，<code>cur</code>为当前值(从第二项开始)</li>
</ul>
<p><strong>数组乱序：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>];</span><br><span class="line">arr.sort(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.random() - <span class="number">0.5</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>数组拆解: flat: [1,[2,3]] –&gt; [1, 2, 3]</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.flat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.toString().split(<span class="string">','</span>).map(<span class="function"><span class="params">item</span> =&gt;</span> +item )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、浏览器"><a href="#三、浏览器" class="headerlink" title="三、浏览器"></a>三、浏览器</h2><h3 id="1-跨标签页通讯"><a href="#1-跨标签页通讯" class="headerlink" title="1. 跨标签页通讯"></a>1. 跨标签页通讯</h3><blockquote>
<p>不同标签页间的通讯，本质原理就是去运用一些可以 共享的中间介质，因此比较常用的有以下方法:</p>
</blockquote>
<ul>
<li>通过父页面<code>window.open()</code>和子页面<code>postMessage</code><ul>
<li>异步下，通过 <code>window.open(&#39;about: blank&#39;)</code> 和 <code>tab.location.href = &#39;*&#39;</code></li>
</ul>
</li>
<li>设置同域下共享的<code>localStorage</code>与监听<code>window.onstorage</code><ul>
<li>重复写入相同的值无法触发</li>
<li>会受到浏览器隐身模式等的限制</li>
</ul>
</li>
<li>设置共享<code>cookie</code>与不断轮询脏检查(<code>setInterval</code>)</li>
<li>借助服务端或者中间层实现</li>
</ul>
<h3 id="2-浏览器架构"><a href="#2-浏览器架构" class="headerlink" title="2. 浏览器架构"></a>2. 浏览器架构</h3><ul>
<li>用户界面</li>
<li>主进程</li>
<li>内核<ul>
<li>渲染引擎</li>
<li><code>JS</code> 引擎<ul>
<li>执行栈</li>
</ul>
</li>
</ul>
</li>
<li>事件触发线程<ul>
<li>消息队列<ul>
<li>微任务</li>
<li>宏任务</li>
</ul>
</li>
</ul>
</li>
<li>网络异步线程</li>
<li>定时器线程</li>
</ul>
<h3 id="3-浏览器下事件循环-Event-Loop"><a href="#3-浏览器下事件循环-Event-Loop" class="headerlink" title="3. 浏览器下事件循环(Event Loop)"></a>3. 浏览器下事件循环(Event Loop)</h3><blockquote>
<p>事件循环是指: 执行一个宏任务，然后执行清空微任务列表，循环再执行宏任务，再清微任务列表</p>
</blockquote>
<ul>
<li>微任务 <code>microtask(jobs): promise / ajax / Object.observe</code>(该方法已废弃)</li>
<li>宏任务 <code>macrotask(task): setTimout / script / IO / UI Rendering</code></li>
</ul>
<h3 id="4-从输入-url-到展示的过程"><a href="#4-从输入-url-到展示的过程" class="headerlink" title="4. 从输入 url 到展示的过程"></a>4. 从输入 url 到展示的过程</h3><ul>
<li><code>DNS</code> 解析</li>
<li><code>TCP</code> 三次握手</li>
<li>发送请求，分析 <code>url</code>，设置请求报文(头，主体)</li>
<li>服务器返回请求的文件 (<code>html</code>)</li>
<li>浏览器渲染<ul>
<li><code>HTML parser</code> –&gt; <code>DOM Tree</code><ul>
<li>标记化算法，进行元素状态的标记</li>
<li><code>dom</code> 树构建</li>
</ul>
</li>
</ul>
</li>
<li><code>CSS parser --&gt; Style Tree</code><ul>
<li>解析 <code>css</code> 代码，生成样式树</li>
</ul>
</li>
<li><code>attachment</code> –&gt; <code>Render Tree</code><ul>
<li>结合 dom树 与 style树，生成渲染树</li>
</ul>
</li>
<li><code>layout</code>: 布局</li>
<li><code>GPU painting</code>: 像素绘制页面</li>
</ul>
<h3 id="5-重绘与回流"><a href="#5-重绘与回流" class="headerlink" title="5. 重绘与回流"></a>5. 重绘与回流</h3><blockquote>
<p>当元素的样式发生变化时，浏览器需要触发更新，重新绘制元素。这个过程中，有两种类型的操作，即重绘与回流。</p>
</blockquote>
<blockquote>
<ul>
<li>重绘(repaint): 当元素样式的改变不影响布局时，浏览器将使用重绘对元素进行更新，此时由于只需要UI层面的重新像素绘制，因此 损耗较少</li>
<li>回流(reflow): 当元素的尺寸、结构或触发某些属性时，浏览器会重新渲染页面，称为回流。此时，浏览器需要重新经过计算，计算后还需要重新页面布局，因此是较重的操作。会触发回流的操作:</li>
</ul>
</blockquote>
<ul>
<li>页面初次渲染</li>
<li>浏览器窗口大小改变</li>
<li>元素尺寸、位置、内容发生改变</li>
<li>元素字体大小变化</li>
<li>添加或者删除可见的 <code>dom</code> 元素</li>
<li>激活 <code>CSS</code> 伪类（例如：<code>:hover</code>）</li>
<li>查询某些属性或调用某些方法<ul>
<li><code>clientWidth、clientHeight、clientTop、clientLeft</code></li>
<li><code>offsetWidth、offsetHeight、offsetTop、offsetLeft</code></li>
<li><code>scrollWidth、scrollHeight、scrollTop、scrollLeft</code></li>
<li><code>getComputedStyle()</code></li>
<li><code>getBoundingClientRect()</code></li>
<li><code>scrollTo()</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>回流必定触发重绘，重绘不一定触发回流。重绘的开销较小，回流的代价较高。</p>
</blockquote>
<p><strong>最佳实践:</strong></p>
<p><strong>css</strong></p>
<ul>
<li>避免使用<code>table</code>布局</li>
<li>将动画效果应用到<code>position</code>属性为<code>absolute</code>或<code>fixed</code>的元素上</li>
</ul>
<p><strong>javascript</strong></p>
<ul>
<li>避免频繁操作样式，可汇总后统一 一次修改</li>
<li>尽量使用<code>class</code>进行样式修改</li>
<li>减少<code>dom</code>的增删次数，可使用 字符串 或者 <code>documentFragment</code> 一次性插入</li>
<li>极限优化时，修改样式可将其<code>display: none</code>后修改</li>
<li>避免多次触发上面提到的那些会触发回流的方法，可以的话尽量用 变量存住</li>
</ul>
<h3 id="6-存储"><a href="#6-存储" class="headerlink" title="6. 存储"></a>6. 存储</h3><blockquote>
<p>我们经常需要对业务中的一些数据进行存储，通常可以分为 短暂性存储 和 持久性储存。</p>
</blockquote>
<ul>
<li>短暂性的时候，我们只需要将数据存在内存中，只在运行时可用</li>
<li>持久性存储，可以分为 浏览器端 与 服务器端<ul>
<li>浏览器:<ul>
<li><code>cookie</code>: 通常用于存储用户身份，登录状态等<ul>
<li><code>http</code> 中自动携带， 体积上限为 <code>4K</code>， 可自行设置过期时间</li>
</ul>
</li>
<li><code>localStorage / sessionStorage</code>: 长久储存/窗口关闭删除， 体积限制为 <code>4~5M</code></li>
<li><code>indexDB</code></li>
</ul>
</li>
<li>服务器:<ul>
<li>分布式缓存 <code>redis</code></li>
<li>数据库 </li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="7-Web-Worker"><a href="#7-Web-Worker" class="headerlink" title="7. Web Worker"></a>7. Web Worker</h3><blockquote>
<p>现代浏览器为<code>JavaScript</code>创造的 多线程环境。可以新建并将部分任务分配到<code>worker</code>线程并行运行，两个线程可 独立运行，互不干扰，可通过自带的 消息机制 相互通信。</p>
</blockquote>
<p><strong>基本用法:</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建 worker</span></span><br><span class="line"><span class="keyword">const</span> worker = <span class="keyword">new</span> Worker(<span class="string">'work.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向主进程推送消息</span></span><br><span class="line">worker.postMessage(<span class="string">'Hello World'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听主进程来的消息</span></span><br><span class="line">worker.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Received message '</span> + event.data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>限制:</strong></p>
<ul>
<li>同源限制</li>
<li>无法使用 <code>document / window / alert / confirm</code></li>
<li>无法加载本地资源</li>
</ul>
<h3 id="8-内存泄露"><a href="#8-内存泄露" class="headerlink" title="8. 内存泄露"></a>8. 内存泄露</h3><ul>
<li>意外的全局变量: 无法被回收</li>
<li>定时器: 未被正确关闭，导致所引用的外部变量无法被释放</li>
<li>事件监听: 没有正确销毁 (低版本浏览器可能出现)</li>
<li>闭包: 会导致父级中的变量无法被释放</li>
<li><code>dom</code> 引用: <code>dom</code> 元素被删除时，内存中的引用未被正确清空</li>
</ul>
<blockquote>
<p>可用 <code>chrome</code> 中的 <code>timeline</code> 进行内存标记，可视化查看内存的变化情况，找出异常点。</p>
</blockquote>
<h2 id="四、服务端与网络"><a href="#四、服务端与网络" class="headerlink" title="四、服务端与网络"></a>四、服务端与网络</h2><h3 id="1-http-https-协议"><a href="#1-http-https-协议" class="headerlink" title="1. http/https 协议"></a>1. http/https 协议</h3><p><strong>1.0 协议缺陷:</strong></p>
<ul>
<li>无法复用链接，完成即断开，重新慢启动和 <code>TCP 3</code>次握手</li>
<li><code>head of line blocking</code>: 线头阻塞，导致请求之间互相影响</li>
</ul>
<p><strong>1.1 改进:</strong></p>
<ul>
<li>长连接(默认 <code>keep-alive</code>)，复用</li>
<li><code>host</code> 字段指定对应的虚拟站点</li>
<li><strong>新增功能:</strong><ul>
<li>断点续传</li>
<li>身份认证</li>
<li>状态管理</li>
<li><code>cache</code> 缓存<ul>
<li><code>Cache-Control</code></li>
<li><code>Expires</code></li>
<li><code>Last-Modified</code></li>
<li><code>Etag</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>2.0:</strong></p>
<ul>
<li>多路复用</li>
<li>二进制分帧层: 应用层和传输层之间</li>
<li>首部压缩</li>
<li>服务端推送</li>
</ul>
<p><strong>https: 较为安全的网络传输协议</strong></p>
<ul>
<li>证书(公钥)</li>
<li><code>SSL</code> 加密</li>
<li>端口 <code>443</code></li>
</ul>
<p><strong>TCP:</strong></p>
<ul>
<li>三次握手</li>
<li>四次挥手</li>
<li>滑动窗口: 流量控制</li>
<li>拥塞处理<ul>
<li>慢开始</li>
<li>拥塞避免</li>
<li>快速重传</li>
<li>快速恢复</li>
</ul>
</li>
</ul>
<p><strong>缓存策略: 可分为 强缓存 和 协商缓存</strong></p>
<ul>
<li><code>Cache-Control/Expires</code>: 浏览器判断缓存是否过期，未过期时，直接使用强缓存，<code>Cache-Control</code>的 <code>max-age</code> 优先级高于 <code>Expires</code></li>
<li>当缓存已经过期时，使用协商缓存<ul>
<li>唯一标识方案: <code>Etag</code>(<code>response</code> 携带) &amp; <code>If-None-Match</code>(<code>request</code>携带，上一次返回的 <code>Etag</code>): 服务器判断资源是否被修改</li>
<li>最后一次修改时间: <code>Last-Modified(response) &amp; If-Modified-Since</code>(<code>request</code>，上一次返回的<code>Last-Modified</code>)<ul>
<li>如果一致，则直接返回 304 通知浏览器使用缓存</li>
<li>如不一致，则服务端返回新的资源</li>
</ul>
</li>
</ul>
</li>
<li><code>Last-Modified</code> 缺点：<ul>
<li>周期性修改，但内容未变时，会导致缓存失效</li>
<li>最小粒度只到 <code>s</code>， <code>s</code> 以内的改动无法检测到</li>
</ul>
</li>
<li><code>Etag</code> 的优先级高于<code>Last-Modified</code></li>
</ul>
<h3 id="2-常见状态码"><a href="#2-常见状态码" class="headerlink" title="2. 常见状态码"></a>2. 常见状态码</h3><ul>
<li><code>1xx</code>: 接受，继续处理</li>
<li><code>200</code>: 成功，并返回数据</li>
<li><code>201</code>: 已创建</li>
<li><code>202</code>: 已接受</li>
<li><code>203</code>: 成为，但未授权</li>
<li><code>204</code>: 成功，无内容</li>
<li><code>205</code>: 成功，重置内容</li>
<li><code>206</code>: 成功，部分内容</li>
<li><code>301</code>: 永久移动，重定向</li>
<li><code>302</code>: 临时移动，可使用原有URI</li>
<li><code>304</code>: 资源未修改，可使用缓存</li>
<li><code>305</code>: 需代理访问</li>
<li><code>400</code>: 请求语法错误</li>
<li><code>401</code>: 要求身份认证</li>
<li><code>403</code>: 拒绝请求</li>
<li><code>404</code>: 资源不存在</li>
<li><code>500</code>: 服务器错误</li>
</ul>
<h3 id="3-get-post"><a href="#3-get-post" class="headerlink" title="3. get / post"></a>3. get / post</h3><ul>
<li><code>get</code>: 缓存、请求长度受限、会被历史保存记录<ul>
<li>无副作用(不修改资源)，幂等(请求次数与资源无关)的场景</li>
</ul>
</li>
<li><code>post</code>: 安全、大数据、更多编码类型</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2019/2/14/168e9d9050b9d08a" alt=""></p>
<h3 id="4-Websocket"><a href="#4-Websocket" class="headerlink" title="4. Websocket"></a>4. Websocket</h3><blockquote>
<p><code>Websocket</code> 是一个 持久化的协议， 基于 <code>http</code> ， 服务端可以 主动 <code>push</code></p>
</blockquote>
<p><strong>兼容：</strong></p>
<blockquote>
<ul>
<li><code>FLASH Socket</code></li>
<li>长轮询： 定时发送 <code>ajax</code></li>
<li><code>long poll</code>： 发送 –&gt; 有消息时再 <code>response</code></li>
</ul>
</blockquote>
<ul>
<li><code>new WebSocket(url)</code></li>
<li><code>ws.onerror = fn</code></li>
<li><code>ws.onclose = fn</code></li>
<li><code>ws.onopen = fn</code></li>
<li><code>ws.onmessage = fn</code></li>
<li><code>ws.send()</code></li>
</ul>
<h3 id="5-TCP三次握手"><a href="#5-TCP三次握手" class="headerlink" title="5. TCP三次握手"></a>5. TCP三次握手</h3><blockquote>
<p>建立连接前，客户端和服务端需要通过握手来确认对方:</p>
</blockquote>
<ul>
<li>客户端发送 <code>syn</code>(同步序列编号) 请求，进入 <code>syn_send</code> 状态，等待确认</li>
<li>服务端接收并确认 <code>syn</code> 包后发送 <code>syn+ack</code> 包，进入 <code>syn_recv</code> 状态</li>
<li>客户端接收 <code>syn+ack</code> 包后，发送 <code>ack</code> 包，双方进入 <code>established</code> 状态</li>
</ul>
<h3 id="6-TCP四次挥手"><a href="#6-TCP四次挥手" class="headerlink" title="6. TCP四次挥手"></a>6. TCP四次挥手</h3><ul>
<li>客户端 – FIN –&gt; 服务端， FIN—WAIT</li>
<li>服务端 – ACK –&gt; 客户端， CLOSE-WAIT</li>
<li>服务端 – ACK,FIN –&gt; 客户端， LAST-ACK</li>
<li>客户端 – ACK –&gt; 服务端，CLOSED</li>
</ul>
<h3 id="7-Node-的-Event-Loop-6个阶段"><a href="#7-Node-的-Event-Loop-6个阶段" class="headerlink" title="7. Node 的 Event Loop: 6个阶段"></a>7. Node 的 Event Loop: 6个阶段</h3><ul>
<li><p><code>timer</code> 阶段: 执行到期的<code>setTimeout / setInterval</code>队列回调</p>
</li>
<li><p><code>I/O</code> 阶段: 执行上轮循环残流的<code>callback</code></p>
</li>
<li><p><code>idle</code>, <code>prepare</code></p>
</li>
<li><p><code>poll</code>: 等待回调</p>
<ul>
<li><ol>
<li>执行回调</li>
</ol>
</li>
<li><ol start="2">
<li>执行定时器</li>
</ol>
<ul>
<li>如有到期的<code>setTimeout / setInterval</code>， 则返回 <code>timer</code> 阶段</li>
<li>如有<code>setImmediate</code>，则前往 <code>check</code> 阶段</li>
</ul>
</li>
</ul>
</li>
<li><p><code>check</code></p>
<ul>
<li>执行<code>setImmediate</code></li>
</ul>
</li>
<li><p><code>close callbacks</code></p>
</li>
</ul>
<h3 id="8-跨域"><a href="#8-跨域" class="headerlink" title="8. 跨域"></a>8. 跨域</h3><ul>
<li><code>JSONP</code>: 利用<code>&lt;script&gt;</code>标签不受跨域限制的特点，缺点是只能支持 <code>get</code> 请求</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonp</span>(<span class="params">url, jsonpCallback, success</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>)</span><br><span class="line">  script.src = url</span><br><span class="line">  script.async = <span class="literal">true</span></span><br><span class="line">  script.type = <span class="string">'text/javascript'</span></span><br><span class="line">  <span class="built_in">window</span>[jsonpCallback] = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    success &amp;&amp; success(data)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(script)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>设置 <code>CORS: Access-Control-Allow-Origin：*</code></li>
<li><code>postMessage</code></li>
</ul>
<h3 id="9-安全"><a href="#9-安全" class="headerlink" title="9. 安全"></a>9. 安全</h3><ul>
<li><code>XSS</code>攻击: 注入恶意代码<ul>
<li><code>cookie</code> 设置 <code>httpOnly</code></li>
<li>转义页面上的输入内容和输出内容</li>
</ul>
</li>
<li><code>CSRF</code>: 跨站请求伪造，防护:<ul>
<li><code>get</code>不修改数据</li>
<li>不被第三方网站访问到用户的 <code>cookie</code></li>
<li>设置白名单，不被第三方网站请求</li>
<li>请求校验</li>
</ul>
</li>
</ul>
<h2 id="五、框架：Vue"><a href="#五、框架：Vue" class="headerlink" title="五、框架：Vue"></a>五、框架：Vue</h2><h3 id="1-nextTick"><a href="#1-nextTick" class="headerlink" title="1. nextTick"></a>1. nextTick</h3><blockquote>
<p>在下次<code>dom</code>更新循环结束之后执行延迟回调，可用于获取更新后的<code>dom</code>状态</p>
</blockquote>
<ul>
<li>新版本中默认是<code>mincrotasks</code>, <code>v-on</code>中会使用<code>macrotasks</code></li>
<li><code>macrotasks</code>任务的实现:<ul>
<li><code>setImmediate / MessageChannel / setTimeout</code></li>
</ul>
</li>
</ul>
<h3 id="2-生命周期"><a href="#2-生命周期" class="headerlink" title="2. 生命周期"></a>2. 生命周期</h3><p><strong><em>init</em></strong></p>
<ul>
<li><code>initLifecycle/Event</code>，往vm上挂载各种属性</li>
<li><code>callHook: beforeCreated</code>: 实例刚创建</li>
<li><code>initInjection/initState</code>: 初始化注入和 <code>data</code> 响应性</li>
<li><code>created: 创建完成，属性已经绑定， 但还未生成真实</code>dom`</li>
<li>进行元素的挂载： <code>$el / vm.$mount()</code></li>
<li>是否有<code>template</code>: 解析成 <code>render function</code> <ul>
<li><code>*.vue</code>文件: <code>vue-loader</code>会将<code>&lt;template&gt;</code>编译成<code>render function</code></li>
</ul>
</li>
<li><code>beforeMount</code>: 模板编译/挂载之前</li>
<li>执行<code>render function</code>，生成真实的<code>dom</code>，并替换到<code>dom tree</code>中</li>
<li><code>mounted</code>: 组件已挂载</li>
</ul>
<p><strong>update</strong></p>
<ul>
<li>执行<code>diff</code>算法，比对改变是否需要触发<code>UI</code>更新</li>
<li><code>flushScheduleQueue</code></li>
<li><code>watcher.before</code>: 触发<code>beforeUpdate</code>钩子    - <code>watcher.run()</code>: 执行<code>watcher</code>中的 <code>notify</code>，通知所有依赖项更新UI</li>
<li>触发<code>updated</code>钩子: 组件已更新</li>
<li><code>actived / deactivated(keep-alive)</code>: 不销毁，缓存，组件激活与失活</li>
<li><code>destroy</code><ul>
<li><code>beforeDestroy</code>: 销毁开始</li>
<li>销毁自身且递归销毁子组件以及事件监听<ul>
<li><code>remove()</code>: 删除节点</li>
<li><code>watcher.teardown()</code>: 清空依赖</li>
<li><code>vm.$off()</code>: 解绑监听</li>
</ul>
</li>
<li><code>destroyed</code>: 完成后触发钩子</li>
</ul>
</li>
</ul>
<blockquote>
<p>上面是vue的声明周期的简单梳理，接下来我们直接以代码的形式来完成vue的初始化</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化Vue实例</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	 <span class="comment">// 挂载属性</span></span><br><span class="line">    initLifeCycle(vm) </span><br><span class="line">    <span class="comment">// 初始化事件系统，钩子函数等</span></span><br><span class="line">    initEvent(vm) </span><br><span class="line">    <span class="comment">// 编译slot、vnode</span></span><br><span class="line">    initRender(vm) </span><br><span class="line">    <span class="comment">// 触发钩子</span></span><br><span class="line">    callHook(vm, <span class="string">'beforeCreate'</span>)</span><br><span class="line">    <span class="comment">// 添加inject功能</span></span><br><span class="line">    initInjection(vm)</span><br><span class="line">    <span class="comment">// 完成数据响应性 props/data/watch/computed/methods</span></span><br><span class="line">    initState(vm)</span><br><span class="line">    <span class="comment">// 添加 provide 功能</span></span><br><span class="line">    initProvide(vm)</span><br><span class="line">    <span class="comment">// 触发钩子</span></span><br><span class="line">    callHook(vm, <span class="string">'created'</span>)</span><br><span class="line">		</span><br><span class="line">	 <span class="comment">// 挂载节点</span></span><br><span class="line">    <span class="keyword">if</span> (vm.$options.el) &#123;</span><br><span class="line">        vm.$mount(vm.$options.el)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 挂载节点实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountComponent</span>(<span class="params">vm</span>) </span>&#123;</span><br><span class="line">	 <span class="comment">// 获取 render function</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.options.render) &#123;</span><br><span class="line">        <span class="comment">// template to render</span></span><br><span class="line">        <span class="comment">// Vue.compile = compileToFunctions</span></span><br><span class="line">        <span class="keyword">let</span> &#123; render &#125; = compileToFunctions() </span><br><span class="line">        <span class="keyword">this</span>.options.render = render</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 触发钩子</span></span><br><span class="line">    callHook(<span class="string">'beforeMounte'</span>)</span><br><span class="line">    <span class="comment">// 初始化观察者</span></span><br><span class="line">    <span class="comment">// render 渲染 vdom， </span></span><br><span class="line">    vdom = vm.render()</span><br><span class="line">    <span class="comment">// update: 根据 diff 出的 patchs 挂载成真实的 dom </span></span><br><span class="line">    vm._update(vdom)</span><br><span class="line">    <span class="comment">// 触发钩子  </span></span><br><span class="line">    callHook(vm, <span class="string">'mounted'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新节点实现</span></span><br><span class="line">funtion queueWatcher(watcher) &#123;</span><br><span class="line">	nextTick(flushScheduleQueue)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空队列</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushScheduleQueue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	 <span class="comment">// 遍历队列中所有修改</span></span><br><span class="line">    <span class="keyword">for</span>()&#123;</span><br><span class="line">	    <span class="comment">// beforeUpdate</span></span><br><span class="line">        watcher.before()</span><br><span class="line">         </span><br><span class="line">        <span class="comment">// 依赖局部更新节点</span></span><br><span class="line">        watcher.update() </span><br><span class="line">        callHook(<span class="string">'updated'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁实例实现</span></span><br><span class="line">Vue.prototype.$destory = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	 <span class="comment">// 触发钩子</span></span><br><span class="line">    callHook(vm, <span class="string">'beforeDestory'</span>)</span><br><span class="line">    <span class="comment">// 自身及子节点</span></span><br><span class="line">    remove() </span><br><span class="line">    <span class="comment">// 删除依赖</span></span><br><span class="line">    watcher.teardown() </span><br><span class="line">    <span class="comment">// 删除监听</span></span><br><span class="line">    vm.$off() </span><br><span class="line">    <span class="comment">// 触发钩子</span></span><br><span class="line">    callHook(vm, <span class="string">'destoryed'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-Proxy-相比于-defineProperty-的优势"><a href="#3-Proxy-相比于-defineProperty-的优势" class="headerlink" title="3. Proxy 相比于 defineProperty 的优势"></a>3. Proxy 相比于 defineProperty 的优势</h3><ul>
<li>数组变化也能监听到</li>
<li>不需要深度遍历监听</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> data = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">let</span> reactiveData = <span class="keyword">new</span> <span class="built_in">Proxy</span>(data, &#123;</span><br><span class="line">	<span class="keyword">get</span>: function(target, name)&#123;</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="4-vue-router"><a href="#4-vue-router" class="headerlink" title="4. vue-router"></a>4. vue-router</h3><p><strong>mode</strong></p>
<ul>
<li><code>hash</code></li>
<li><code>history</code></li>
</ul>
<p><strong>跳转</strong></p>
<ul>
<li><code>this.$router.push()</code></li>
<li><code>&lt;router-link to=&quot;&quot;&gt;&lt;/router-link&gt;</code></li>
</ul>
<p><strong>占位</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;router-view&gt;&lt;&#x2F;router-view&gt;</span><br></pre></td></tr></table></figure>

<h3 id="5-vuex"><a href="#5-vuex" class="headerlink" title="5. vuex"></a>5. vuex</h3><ul>
<li><code>state</code>: 状态中心</li>
<li><code>mutations</code>: 更改状态</li>
<li><code>actions</code>: 异步更改状态</li>
<li><code>getters</code>: 获取状态</li>
<li><code>modules</code>: 将<code>state</code>分成多个<code>modules</code>，便于管理</li>
</ul>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Sumind</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://sumind.cn/2018/03/20/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%20-%20%E5%A4%8D%E4%B9%A0/">https://sumind.cn/2018/03/20/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%20-%20%E5%A4%8D%E4%B9%A0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://sumind.cn">Sumindの世界</a>！</span></div></div><div class="post-meta__tag-list"></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/06/20/VS%20Code%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90/"><i class="fa fa-chevron-left">  </i><span>VS Code插件推荐</span></a></div><div class="next-post pull-right"><a href="/2018/01/26/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%20-%20HTML/"><span>前端知识 - HTML</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://gitee.com/sumind/picCloud/raw/master/img/top_img.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2016 - 2020 By Sumind</div><div class="framework-info"><span> - I will be a front-end engineer with soul - </span></div><div class="footer_custom_text">hitokoto</div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"superSample":2,"width":210,"height":420,"position":"right","hOffset":0,"vOffset":-40},"log":false,"tagMode":false});</script></body></html><!-- 音频播放 -->
<link rel="stylesheet" href="https://cdn.bootcss.com/aplayer/1.7.0/APlayer.min.css">
<div id="aplayer"></div>
<script type="text/javascript" src="https://cdn.bootcss.com/aplayer/1.7.0/APlayer.min.js"></script>
<script type="text/javascript" src="/js/music.js"></script>
<script type="text/javascript" color="225,225,225" opacity='0.8' zIndex="-2" count="100" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>