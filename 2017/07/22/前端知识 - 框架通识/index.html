<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="前端知识 - 框架通识"><meta name="keywords" content=""><meta name="author" content="Sumind"><meta name="copyright" content="Sumind"><title>前端知识 - 框架通识 | Sumindの世界</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script><meta name="generator" content="Hexo 4.2.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-5"><a class="toc-link" href="#前端知识-框架通识"><span class="toc-number">1.</span> <span class="toc-text">前端知识 - 框架通识</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#框架通识"><span class="toc-number"></span> <span class="toc-text">框架通识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-MVVM"><span class="toc-number"></span> <span class="toc-text">1 MVVM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-路由原理"><span class="toc-number"></span> <span class="toc-text">2 路由原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Virtual-Dom"><span class="toc-number"></span> <span class="toc-text">3 Virtual Dom</span></a></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://gitee.com/sumind/picCloud/raw/master/img/Head-portrait.jpg"></div><div class="author-info__name text-center">Sumind</div><div class="author-info__description text-center">人生没有白走的路，每一步都算数</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">32</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">3</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://gitee.com/sumind/picCloud/raw/master/img/top_img.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Sumindの世界</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">时间轴</a><a class="site-page" href="/gallery">相册</a><a class="site-page" href="/about">关于我</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">前端知识 - 框架通识</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-07-22</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%B0%8F%E7%9F%A5%E8%AF%86/">小知识</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h5 id="前端知识-框架通识"><a href="#前端知识-框架通识" class="headerlink" title="前端知识 - 框架通识"></a>前端知识 - 框架通识</h5><p>资料整理</p>
<a id="more"></a>



<h2 id="框架通识"><a href="#框架通识" class="headerlink" title="框架通识"></a>框架通识</h2><h3 id="1-MVVM"><a href="#1-MVVM" class="headerlink" title="1 MVVM"></a>1 MVVM</h3><blockquote>
<p><code>MVVM</code> 由以下三个内容组成</p>
</blockquote>
<ul>
<li><code>View</code>：界面</li>
<li><code>Model</code>：数据模型</li>
<li><code>ViewModel</code>：作为桥梁负责沟通 <code>View</code> 和 <code>Model</code></li>
</ul>
<blockquote>
<p>在 <code>JQuery</code> 时期，如果需要刷新 <code>UI</code> 时，需要先取到对应的 <code>DOM</code> 再更新 <code>UI</code>，这样数据和业务的逻辑就和页面有强耦合。</p>
</blockquote>
<p>::: tip MVVM<br>在 <code>MVVM</code> 中，<code>UI</code> 是通过数据驱动的，数据一旦改变就会相应的刷新对应的 <code>UI</code>，<code>UI</code> 如果改变，也会改变对应的数据。这种方式就可以在业务处理中只关心数据的流转，而无需直接和页面打交道。<code>ViewModel</code> 只关心数据和业务的处理，不关心 <code>View</code> 如何处理数据，在这种情况下，<code>View</code> 和 <code>Model</code> 都可以独立出来，任何一方改变了也不一定需要改变另一方，并且可以将一些可复用的逻辑放在一个 <code>ViewModel</code> 中，让多个 <code>View</code>复用这个 <code>ViewModel</code>。<br>:::</p>
<ul>
<li>在 <code>MVVM</code> 中，最核心的也就是数据双向绑定，例如 <code>Angluar</code> 的脏数据检测，<code>Vue</code> 中的数据劫持。</li>
</ul>
<p><strong>脏数据检测</strong></p>
<blockquote>
<p>当触发了指定事件后会进入脏数据检测，这时会调用 <code>$digest</code> 循环遍历所有的数据观察者，判断当前值是否和先前的值有区别，如果检测到变化的话，会调用 <code>$watch</code> 函数，然后再次调用 <code>$digest</code> 循环直到发现没有变化。循环至少为二次 ，至多为十次。</p>
</blockquote>
<blockquote>
<p>脏数据检测虽然存在低效的问题，但是不关心数据是通过什么方式改变的，都可以完成任务，但是这在 <code>Vue</code> 中的双向绑定是存在问题的。并且脏数据检测可以实现批量检测出更新的值，再去统一更新 <code>UI</code>，大大减少了操作 <code>DOM</code> 的次数。所以低效也是相对的，这就仁者见仁智者见智了。</p>
</blockquote>
<p><strong>数据劫持</strong></p>
<blockquote>
<p><code>Vue</code> 内部使用了 <code>Object.defineProperty()</code> 来实现双向绑定，通过这个函数可以监听到 <code>set</code> 和 <code>get</code> 的事件。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123; <span class="attr">name</span>: <span class="string">'yck'</span> &#125;</span><br><span class="line">observe(data)</span><br><span class="line"><span class="keyword">let</span> name = data.name <span class="comment">// -&gt; get value</span></span><br><span class="line">data.name = <span class="string">'yyy'</span> <span class="comment">// -&gt; change value</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断类型</span></span><br><span class="line">  <span class="keyword">if</span> (!obj || <span class="keyword">typeof</span> obj !== <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Object</span>.keys(obj).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    defineReactive(obj, key, obj[key])</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj, key, val</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 递归子属性</span></span><br><span class="line">  observe(val)</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    <span class="keyword">get</span>: function reactiveGetter() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'get value'</span>)</span><br><span class="line">      <span class="keyword">return</span> val</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function reactiveSetter(newVal) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'change value'</span>)</span><br><span class="line">      val = newVal</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上代码简单的实现了如何监听数据的 <code>set</code> 和 <code>get</code> 的事件，但是仅仅如此是不够的，还需要在适当的时候给属性添加发布订阅</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    &#123;&#123;name&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在解析如上模板代码时，遇到 <code></code> 就会给属性 <code>name</code> 添加发布订阅。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过 Dep 解耦</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs = []</span><br><span class="line">  &#125;</span><br><span class="line">  addSub(sub) &#123;</span><br><span class="line">    <span class="comment">// sub 是 Watcher 实例</span></span><br><span class="line">    <span class="keyword">this</span>.subs.push(sub)</span><br><span class="line">  &#125;</span><br><span class="line">  notify() &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs.forEach(<span class="function"><span class="params">sub</span> =&gt;</span> &#123;</span><br><span class="line">      sub.update()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 全局属性，通过该属性配置 Watcher</span></span><br><span class="line">Dep.target = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.querySelector(<span class="string">'div'</span>).innerText = value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(obj, key, cb) &#123;</span><br><span class="line">    <span class="comment">// 将 Dep.target 指向自己</span></span><br><span class="line">    <span class="comment">// 然后触发属性的 getter 添加监听</span></span><br><span class="line">    <span class="comment">// 最后将 Dep.target 置空</span></span><br><span class="line">    Dep.target = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">this</span>.cb = cb</span><br><span class="line">    <span class="keyword">this</span>.obj = obj</span><br><span class="line">    <span class="keyword">this</span>.key = key</span><br><span class="line">    <span class="keyword">this</span>.value = obj[key]</span><br><span class="line">    Dep.target = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  update() &#123;</span><br><span class="line">    <span class="comment">// 获得新值</span></span><br><span class="line">    <span class="keyword">this</span>.value = <span class="keyword">this</span>.obj[<span class="keyword">this</span>.key]</span><br><span class="line">    <span class="comment">// 调用 update 方法更新 Dom</span></span><br><span class="line">    <span class="keyword">this</span>.cb(<span class="keyword">this</span>.value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> data = &#123; <span class="attr">name</span>: <span class="string">'yck'</span> &#125;</span><br><span class="line">observe(data)</span><br><span class="line"><span class="comment">// 模拟解析到 `&#123;&#123;name&#125;&#125;` 触发的操作</span></span><br><span class="line"><span class="keyword">new</span> Watcher(data, <span class="string">'name'</span>, update)</span><br><span class="line"><span class="comment">// update Dom innerText</span></span><br><span class="line">data.name = <span class="string">'yyy'</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>接下来,对 <code>defineReactive</code> 函数进行改造</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj, key, val</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 递归子属性</span></span><br><span class="line">  observe(val)</span><br><span class="line">  <span class="keyword">let</span> dp = <span class="keyword">new</span> Dep()</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    <span class="keyword">get</span>: function reactiveGetter() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'get value'</span>)</span><br><span class="line">      <span class="comment">// 将 Watcher 添加到订阅</span></span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        dp.addSub(Dep.target)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> val</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function reactiveSetter(newVal) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'change value'</span>)</span><br><span class="line">      val = newVal</span><br><span class="line">      <span class="comment">// 执行 watcher 的 update 方法</span></span><br><span class="line">      dp.notify()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上实现了一个简易的双向绑定，核心思路就是手动触发一次属性的 <code>getter</code> 来实现发布订阅的添加</p>
</blockquote>
<p><strong>Proxy 与 Object.defineProperty 对比</strong></p>
<blockquote>
<p><code>Object.defineProperty</code> 虽然已经能够实现双向绑定了，但是他还是有缺陷的。</p>
</blockquote>
<ul>
<li>只能对属性进行数据劫持，所以需要深度遍历整个对象<br>对于数组不能监听到数据的变化</li>
<li>虽然 <code>Vue</code> 中确实能检测到数组数据的变化，但是其实是使用了 <code>hack</code>的办法，并且也是有缺陷的。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arrayProto = <span class="built_in">Array</span>.prototype</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> arrayMethods = <span class="built_in">Object</span>.create(arrayProto)</span><br><span class="line"><span class="comment">// hack 以下几个函数</span></span><br><span class="line"><span class="keyword">const</span> methodsToPatch = [</span><br><span class="line">  <span class="string">'push'</span>,</span><br><span class="line">  <span class="string">'pop'</span>,</span><br><span class="line">  <span class="string">'shift'</span>,</span><br><span class="line">  <span class="string">'unshift'</span>,</span><br><span class="line">  <span class="string">'splice'</span>,</span><br><span class="line">  <span class="string">'sort'</span>,</span><br><span class="line">  <span class="string">'reverse'</span></span><br><span class="line">]</span><br><span class="line">methodsToPatch.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">method</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获得原生函数</span></span><br><span class="line">  <span class="keyword">const</span> original = arrayProto[method]</span><br><span class="line">  def(arrayMethods, method, <span class="function"><span class="keyword">function</span> <span class="title">mutator</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 调用原生函数</span></span><br><span class="line">    <span class="keyword">const</span> result = original.apply(<span class="keyword">this</span>, args)</span><br><span class="line">    <span class="keyword">const</span> ob = <span class="keyword">this</span>.__ob__</span><br><span class="line">    <span class="keyword">let</span> inserted</span><br><span class="line">    <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'push'</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'unshift'</span>:</span><br><span class="line">        inserted = args</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'splice'</span>:</span><br><span class="line">        inserted = args.slice(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (inserted) ob.observeArray(inserted)</span><br><span class="line">    <span class="comment">// 触发更新</span></span><br><span class="line">    ob.dep.notify()</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>反观 <code>Proxy</code>就没以上的问题，原生支持监听数组变化，并且可以直接对整个对象进行拦截，所以 <code>Vue</code> 也将在下个大版本中使用 <code>Proxy</code> 替换 <code>Object.defineProperty</code></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> onWatch = <span class="function">(<span class="params">obj, setBind, getLogger</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> handler = &#123;</span><br><span class="line">    <span class="keyword">get</span>(target, property, receiver) &#123;</span><br><span class="line">      getLogger(target, property)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, property, receiver);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>(target, property, value, receiver) &#123;</span><br><span class="line">      setBind(value);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, property, value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, handler);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">let</span> value</span><br><span class="line"><span class="keyword">let</span> p = onWatch(obj, (v) =&gt; &#123;</span><br><span class="line">  value = v</span><br><span class="line">&#125;, (target, property) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Get '<span class="subst">$&#123;property&#125;</span>' = <span class="subst">$&#123;target[property]&#125;</span>`</span>);</span><br><span class="line">&#125;)</span><br><span class="line">p.a = <span class="number">2</span> <span class="comment">// bind `value` to `2`</span></span><br><span class="line">p.a <span class="comment">// -&gt; Get 'a' = 2</span></span><br></pre></td></tr></table></figure>

<h3 id="2-路由原理"><a href="#2-路由原理" class="headerlink" title="2 路由原理"></a>2 路由原理</h3><blockquote>
<p>前端路由实现起来其实很简单，本质就是监听 <code>URL</code> 的变化，然后匹配路由规则，显示相应的页面，并且无须刷新。目前单页面使用的路由就只有两种实现方式</p>
</blockquote>
<ul>
<li><code>hash</code> 模式</li>
<li><code>history</code> 模式</li>
</ul>
<blockquote>
<p><code>www.test.com/##/</code> 就是 <code>Hash URL</code>，当 <code>##</code> 后面的哈希值发生变化时，不会向服务器请求数据，可以通过<br><code>hashchange</code> 事件来监听到 <code>URL</code> 的变化，从而进行跳转页面。</p>
</blockquote>
<p><img src="https://user-gold-cdn.xitu.io/2018/7/11/164888109d57995f?w=942&h=493&f=png&s=39581" alt=""></p>
<blockquote>
<p><code>History</code>模式是 <code>HTML5</code> 新推出的功能，比之 <code>Hash URL</code> 更加美观</p>
</blockquote>
<p><img src="https://user-gold-cdn.xitu.io/2018/7/11/164888478584a217?w=1244&h=585&f=png&s=59637" alt=""></p>
<h3 id="3-Virtual-Dom"><a href="#3-Virtual-Dom" class="headerlink" title="3 Virtual Dom"></a>3 Virtual Dom</h3><p><strong>为什么需要 Virtual Dom</strong></p>
<blockquote>
<p>众所周知，操作 <code>DOM</code> 是很耗费性能的一件事情，既然如此，我们可以考虑通过 <code>JS</code> 对象来模拟 <code>DOM</code> 对象，毕竟操作 <code>JS</code> 对象比操作 <code>DOM</code> 省时的多</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设这里模拟一个 ul，其中包含了 5 个 li</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="comment">// 这里替换上面的 li</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>从上述例子中，我们一眼就可以看出先前的 <code>ul</code> 中的第三个 <code>li</code> 被移除了，四五替换了位置。</p>
</blockquote>
<ul>
<li>如果以上操作对应到 <code>DOM</code> 中，那么就是以下代码</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除第三个 li</span></span><br><span class="line">ul.childNodes[<span class="number">2</span>].remove()</span><br><span class="line"><span class="comment">// 将第四个 li 和第五个交换位置</span></span><br><span class="line"><span class="keyword">let</span> fromNode = ul.childNodes[<span class="number">4</span>]</span><br><span class="line"><span class="keyword">let</span> toNode = node.childNodes[<span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> cloneFromNode = fromNode.cloneNode(<span class="literal">true</span>)</span><br><span class="line"><span class="keyword">let</span> cloenToNode = toNode.cloneNode(<span class="literal">true</span>)</span><br><span class="line">ul.replaceChild(cloneFromNode, toNode)</span><br><span class="line">ul.replaceChild(cloenToNode, fromNode)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当然在实际操作中，我们还需要给每个节点一个标识，作为判断是同一个节点的依据。所以这也是 <code>Vue</code> 和 <code>React</code> 中官方推荐列表里的节点使用唯一的 <code>key</code> 来保证性能。</p>
</blockquote>
<ul>
<li>那么既然 <code>DOM</code> 对象可以通过 <code>JS</code> 对象来模拟，反之也可以通过 <code>JS</code> 对象来渲染出对应的 <code>DOM</code></li>
<li>以下是一个 <code>JS</code> 对象模拟 <code>DOM</code> 对象的简单实现</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>tag 'div'</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> </span>props &#123; class: 'item' &#125;</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;Array&#125;</span> </span>children [ Element1, 'text']</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>key option</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">constructor</span>(tag, props, children, key) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tag = tag</span><br><span class="line">    <span class="keyword">this</span>.props = props</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(children)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.children = children</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isString(children)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.key = children</span><br><span class="line">      <span class="keyword">this</span>.children = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (key) <span class="keyword">this</span>.key = key</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 渲染</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">let</span> root = <span class="keyword">this</span>._createElement(</span><br><span class="line">      <span class="keyword">this</span>.tag,</span><br><span class="line">      <span class="keyword">this</span>.props,</span><br><span class="line">      <span class="keyword">this</span>.children,</span><br><span class="line">      <span class="keyword">this</span>.key</span><br><span class="line">    )</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(root)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">  &#125;</span><br><span class="line">  create() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._createElement(<span class="keyword">this</span>.tag, <span class="keyword">this</span>.props, <span class="keyword">this</span>.children, <span class="keyword">this</span>.key)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建节点</span></span><br><span class="line">  _createElement(tag, props, child, key) &#123;</span><br><span class="line">    <span class="comment">// 通过 tag 创建节点</span></span><br><span class="line">    <span class="keyword">let</span> el = <span class="built_in">document</span>.createElement(tag)</span><br><span class="line">    <span class="comment">// 设置节点属性</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> props) &#123;</span><br><span class="line">      <span class="keyword">if</span> (props.hasOwnProperty(key)) &#123;</span><br><span class="line">        <span class="keyword">const</span> value = props[key]</span><br><span class="line">        el.setAttribute(key, value)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (key) &#123;</span><br><span class="line">      el.setAttribute(<span class="string">'key'</span>, key)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归添加子节点</span></span><br><span class="line">    <span class="keyword">if</span> (child) &#123;</span><br><span class="line">      child.forEach(<span class="function"><span class="params">element</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> child</span><br><span class="line">        <span class="keyword">if</span> (element <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">          child = <span class="keyword">this</span>._createElement(</span><br><span class="line">            element.tag,</span><br><span class="line">            element.props,</span><br><span class="line">            element.children,</span><br><span class="line">            element.key</span><br><span class="line">          )</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          child = <span class="built_in">document</span>.createTextNode(element)</span><br><span class="line">        &#125;</span><br><span class="line">        el.appendChild(child)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> el</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Virtual Dom 算法简述</strong></p>
<ul>
<li>既然我们已经通过 <code>JS</code> 来模拟实现了 <code>DOM</code>，那么接下来的难点就在于如何判断旧的对象和新的对象之间的差异。</li>
<li><code>DOM</code> 是多叉树的结构，如果需要完整的对比两颗树的差异，那么需要的时间复杂度会是 <code>O(n ^ 3)</code>，这个复杂度肯定是不能接受的。于是 <code>React</code>团队优化了算法，实现了 <code>O(n)</code> 的复杂度来对比差异。</li>
<li>实现<code>O(n)</code> 复杂度的关键就是只对比同层的节点，而不是跨层对比，这也是考虑到在实际业务中很少会去跨层的移动 <code>DOM</code> 元素</li>
</ul>
<blockquote>
<p>所以判断差异的算法就分为了两步</p>
</blockquote>
<ul>
<li>首先从上至下，从左往右遍历对象，也就是树的深度遍历，这一步中会给每个节点添加索引，便于最后渲染差异</li>
<li>一旦节点有子元素，就去判断子元素是否有不同</li>
</ul>
<p><strong>Virtual Dom 算法实现</strong></p>
<p><strong>树的递归</strong></p>
<ul>
<li>首先我们来实现树的递归算法，在实现该算法前，先来考虑下两个节点对比会有几种情况</li>
<li>新的节点的 <code>tagName</code> 或者 <code>key</code> 和旧的不同，这种情况代表需要替换旧的节点，并且也不再需要遍历新旧节点的子元素了，因为整个旧节点都被删掉了</li>
<li>新的节点的 <code>tagName</code> 和 <code>key</code>（可能都没有）和旧的相同，开始遍历子树</li>
<li>没有新的节点，那么什么都不用做</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; StateEnums, isString, move &#125; <span class="keyword">from</span> <span class="string">'./util'</span></span><br><span class="line"><span class="keyword">import</span> Element <span class="keyword">from</span> <span class="string">'./element'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">diff</span>(<span class="params">oldDomTree, newDomTree</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 用于记录差异</span></span><br><span class="line">  <span class="keyword">let</span> pathchs = &#123;&#125;</span><br><span class="line">  <span class="comment">// 一开始的索引为 0</span></span><br><span class="line">  dfs(oldDomTree, newDomTree, <span class="number">0</span>, pathchs)</span><br><span class="line">  <span class="keyword">return</span> pathchs</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">oldNode, newNode, index, patches</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 用于保存子树的更改</span></span><br><span class="line">  <span class="keyword">let</span> curPatches = []</span><br><span class="line">  <span class="comment">// 需要判断三种情况</span></span><br><span class="line">  <span class="comment">// 1.没有新的节点，那么什么都不用做</span></span><br><span class="line">  <span class="comment">// 2.新的节点的 tagName 和 `key` 和旧的不同，就替换</span></span><br><span class="line">  <span class="comment">// 3.新的节点的 tagName 和 key（可能都没有） 和旧的相同，开始遍历子树</span></span><br><span class="line">  <span class="keyword">if</span> (!newNode) &#123;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newNode.tag === oldNode.tag &amp;&amp; newNode.key === oldNode.key) &#123;</span><br><span class="line">    <span class="comment">// 判断属性是否变更</span></span><br><span class="line">    <span class="keyword">let</span> props = diffProps(oldNode.props, newNode.props)</span><br><span class="line">    <span class="keyword">if</span> (props.length) curPatches.push(&#123; <span class="attr">type</span>: StateEnums.ChangeProps, props &#125;)</span><br><span class="line">    <span class="comment">// 遍历子树</span></span><br><span class="line">    diffChildren(oldNode.children, newNode.children, index, patches)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 节点不同，需要替换</span></span><br><span class="line">    curPatches.push(&#123; <span class="attr">type</span>: StateEnums.Replace, <span class="attr">node</span>: newNode &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (curPatches.length) &#123;</span><br><span class="line">    <span class="keyword">if</span> (patches[index]) &#123;</span><br><span class="line">      patches[index] = patches[index].concat(curPatches)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      patches[index] = curPatches</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>判断属性的更改</strong></p>
<blockquote>
<p>判断属性的更改也分三个步骤</p>
</blockquote>
<ul>
<li>遍历旧的属性列表，查看每个属性是否还存在于新的属性列表中</li>
<li>遍历新的属性列表，判断两个列表中都存在的属性的值是否有变化</li>
<li>在第二步中同时查看是否有属性不存在与旧的属性列列表中</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffProps</span>(<span class="params">oldProps, newProps</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断 Props 分以下三步骤</span></span><br><span class="line">  <span class="comment">// 先遍历 oldProps 查看是否存在删除的属性</span></span><br><span class="line">  <span class="comment">// 然后遍历 newProps 查看是否有属性值被修改</span></span><br><span class="line">  <span class="comment">// 最后查看是否有属性新增</span></span><br><span class="line">  <span class="keyword">let</span> change = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> oldProps) &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldProps.hasOwnProperty(key) &amp;&amp; !newProps[key]) &#123;</span><br><span class="line">      change.push(&#123;</span><br><span class="line">        prop: key</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> newProps) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newProps.hasOwnProperty(key)) &#123;</span><br><span class="line">      <span class="keyword">const</span> prop = newProps[key]</span><br><span class="line">      <span class="keyword">if</span> (oldProps[key] &amp;&amp; oldProps[key] !== newProps[key]) &#123;</span><br><span class="line">        change.push(&#123;</span><br><span class="line">          prop: key,</span><br><span class="line">          value: newProps[key]</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!oldProps[key]) &#123;</span><br><span class="line">        change.push(&#123;</span><br><span class="line">          prop: key,</span><br><span class="line">          value: newProps[key]</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> change</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>判断列表差异算法实现</strong></p>
<blockquote>
<p>这个算法是整个 <code>Virtual Dom</code> 中最核心的算法，且让我一一为你道来。 这里的主要步骤其实和判断属性差异是类似的，也是分为三步</p>
</blockquote>
<ul>
<li>遍历旧的节点列表，查看每个节点是否还存在于新的节点列表中</li>
<li>遍历新的节点列表，判断是否有新的节点</li>
<li>在第二步中同时判断节点是否有移动</li>
</ul>
<blockquote>
<p>PS：该算法只对有 <code>key</code> 的节点做处理</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">listDiff</span>(<span class="params">oldList, newList, index, patches</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 为了遍历方便，先取出两个 list 的所有 keys</span></span><br><span class="line">  <span class="keyword">let</span> oldKeys = getKeys(oldList)</span><br><span class="line">  <span class="keyword">let</span> newKeys = getKeys(newList)</span><br><span class="line">  <span class="keyword">let</span> changes = []</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于保存变更后的节点数据</span></span><br><span class="line">  <span class="comment">// 使用该数组保存有以下好处</span></span><br><span class="line">  <span class="comment">// 1.可以正确获得被删除节点索引</span></span><br><span class="line">  <span class="comment">// 2.交换节点位置只需要操作一遍 DOM</span></span><br><span class="line">  <span class="comment">// 3.用于 `diffChildren` 函数中的判断，只需要遍历</span></span><br><span class="line">  <span class="comment">// 两个树中都存在的节点，而对于新增或者删除的节点来说，完全没必要</span></span><br><span class="line">  <span class="comment">// 再去判断一遍</span></span><br><span class="line">  <span class="keyword">let</span> list = []</span><br><span class="line">  oldList &amp;&amp;</span><br><span class="line">    oldList.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> key = item.key</span><br><span class="line">      <span class="keyword">if</span> (isString(item)) &#123;</span><br><span class="line">        key = item</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 寻找新的 children 中是否含有当前节点</span></span><br><span class="line">      <span class="comment">// 没有的话需要删除</span></span><br><span class="line">      <span class="keyword">let</span> index = newKeys.indexOf(key)</span><br><span class="line">      <span class="keyword">if</span> (index === <span class="number">-1</span>) &#123;</span><br><span class="line">        list.push(<span class="literal">null</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> list.push(key)</span><br><span class="line">    &#125;)</span><br><span class="line">  <span class="comment">// 遍历变更后的数组</span></span><br><span class="line">  <span class="keyword">let</span> length = list.length</span><br><span class="line">  <span class="comment">// 因为删除数组元素是会更改索引的</span></span><br><span class="line">  <span class="comment">// 所有从后往前删可以保证索引不变</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="comment">// 判断当前元素是否为空，为空表示需要删除</span></span><br><span class="line">    <span class="keyword">if</span> (!list[i]) &#123;</span><br><span class="line">      list.splice(i, <span class="number">1</span>)</span><br><span class="line">      changes.push(&#123;</span><br><span class="line">        type: StateEnums.Remove,</span><br><span class="line">        index: i</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 遍历新的 list，判断是否有节点新增或移动</span></span><br><span class="line">  <span class="comment">// 同时也对 `list` 做节点新增和移动节点的操作</span></span><br><span class="line">  newList &amp;&amp;</span><br><span class="line">    newList.forEach(<span class="function">(<span class="params">item, i</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> key = item.key</span><br><span class="line">      <span class="keyword">if</span> (isString(item)) &#123;</span><br><span class="line">        key = item</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 寻找旧的 children 中是否含有当前节点</span></span><br><span class="line">      <span class="keyword">let</span> index = list.indexOf(key)</span><br><span class="line">      <span class="comment">// 没找到代表新节点，需要插入</span></span><br><span class="line">      <span class="keyword">if</span> (index === <span class="number">-1</span> || key == <span class="literal">null</span>) &#123;</span><br><span class="line">        changes.push(&#123;</span><br><span class="line">          type: StateEnums.Insert,</span><br><span class="line">          node: item,</span><br><span class="line">          index: i</span><br><span class="line">        &#125;)</span><br><span class="line">        list.splice(i, <span class="number">0</span>, key)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 找到了，需要判断是否需要移动</span></span><br><span class="line">        <span class="keyword">if</span> (index !== i) &#123;</span><br><span class="line">          changes.push(&#123;</span><br><span class="line">            type: StateEnums.Move,</span><br><span class="line">            <span class="keyword">from</span>: index,</span><br><span class="line">            to: i</span><br><span class="line">          &#125;)</span><br><span class="line">          move(list, index, i)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  <span class="keyword">return</span> &#123; changes, list &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getKeys</span>(<span class="params">list</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> keys = []</span><br><span class="line">  <span class="keyword">let</span> text</span><br><span class="line">  list &amp;&amp;</span><br><span class="line">    list.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> key</span><br><span class="line">      <span class="keyword">if</span> (isString(item)) &#123;</span><br><span class="line">        key = [item]</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">        key = item.key</span><br><span class="line">      &#125;</span><br><span class="line">      keys.push(key)</span><br><span class="line">    &#125;)</span><br><span class="line">  <span class="keyword">return</span> keys</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>遍历子元素打标识</strong></p>
<blockquote>
<p>对于这个函数来说，主要功能就两个</p>
</blockquote>
<ul>
<li>判断两个列表差异<ul>
<li>给节点打上标记</li>
<li>总体来说，该函数实现的功能很简单</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffChildren</span>(<span class="params">oldChild, newChild, index, patches</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; changes, list &#125; = listDiff(oldChild, newChild, index, patches)</span><br><span class="line">  <span class="keyword">if</span> (changes.length) &#123;</span><br><span class="line">    <span class="keyword">if</span> (patches[index]) &#123;</span><br><span class="line">      patches[index] = patches[index].concat(changes)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      patches[index] = changes</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 记录上一个遍历过的节点</span></span><br><span class="line">  <span class="keyword">let</span> last = <span class="literal">null</span></span><br><span class="line">  oldChild &amp;&amp;</span><br><span class="line">    oldChild.forEach(<span class="function">(<span class="params">item, i</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> child = item &amp;&amp; item.children</span><br><span class="line">      <span class="keyword">if</span> (child) &#123;</span><br><span class="line">        index =</span><br><span class="line">          last &amp;&amp; last.children ? index + last.children.length + <span class="number">1</span> : index + <span class="number">1</span></span><br><span class="line">        <span class="keyword">let</span> keyIndex = list.indexOf(item.key)</span><br><span class="line">        <span class="keyword">let</span> node = newChild[keyIndex]</span><br><span class="line">        <span class="comment">// 只遍历新旧中都存在的节点，其他新增或者删除的没必要遍历</span></span><br><span class="line">        <span class="keyword">if</span> (node) &#123;</span><br><span class="line">          dfs(item, node, index, patches)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> index += <span class="number">1</span></span><br><span class="line">      last = item</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>渲染差异</strong></p>
<blockquote>
<p>通过之前的算法，我们已经可以得出两个树的差异了。既然知道了差异，就需要局部去更新 <code>DOM</code> 了，下面就让我们来看看 <code>Virtual Dom</code> 算法的最后一步骤</p>
</blockquote>
<p><strong>这个函数主要两个功能</strong></p>
<ul>
<li>深度遍历树，将需要做变更操作的取出来</li>
<li>局部更新 <code>DOM</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">patch</span>(<span class="params">node, patchs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> changes = patchs[index]</span><br><span class="line">  <span class="keyword">let</span> childNodes = node &amp;&amp; node.childNodes</span><br><span class="line">  <span class="comment">// 这里的深度遍历和 diff 中是一样的</span></span><br><span class="line">  <span class="keyword">if</span> (!childNodes) index += <span class="number">1</span></span><br><span class="line">  <span class="keyword">if</span> (changes &amp;&amp; changes.length &amp;&amp; patchs[index]) &#123;</span><br><span class="line">    changeDom(node, changes)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> last = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">if</span> (childNodes &amp;&amp; childNodes.length) &#123;</span><br><span class="line">    childNodes.forEach(<span class="function">(<span class="params">item, i</span>) =&gt;</span> &#123;</span><br><span class="line">      index =</span><br><span class="line">        last &amp;&amp; last.children ? index + last.children.length + <span class="number">1</span> : index + <span class="number">1</span></span><br><span class="line">      patch(item, patchs)</span><br><span class="line">      last = item</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeDom</span>(<span class="params">node, changes, noChild</span>) </span>&#123;</span><br><span class="line">  changes &amp;&amp;</span><br><span class="line">    changes.forEach(<span class="function"><span class="params">change</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> &#123; type &#125; = change</span><br><span class="line">      <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> StateEnums.ChangeProps:</span><br><span class="line">          <span class="keyword">let</span> &#123; props &#125; = change</span><br><span class="line">          props.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (item.value) &#123;</span><br><span class="line">              node.setAttribute(item.prop, item.value)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              node.removeAttribute(item.prop)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> StateEnums.Remove:</span><br><span class="line">          node.childNodes[change.index].remove()</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> StateEnums.Insert:</span><br><span class="line">          <span class="keyword">let</span> dom</span><br><span class="line">          <span class="keyword">if</span> (isString(change.node)) &#123;</span><br><span class="line">            dom = <span class="built_in">document</span>.createTextNode(change.node)</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (change.node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">            dom = change.node.create()</span><br><span class="line">          &#125;</span><br><span class="line">          node.insertBefore(dom, node.childNodes[change.index])</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> StateEnums.Replace:</span><br><span class="line">          node.parentNode.replaceChild(change.node.create(), node)</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> StateEnums.Move:</span><br><span class="line">          <span class="keyword">let</span> fromNode = node.childNodes[change.from]</span><br><span class="line">          <span class="keyword">let</span> toNode = node.childNodes[change.to]</span><br><span class="line">          <span class="keyword">let</span> cloneFromNode = fromNode.cloneNode(<span class="literal">true</span>)</span><br><span class="line">          <span class="keyword">let</span> cloenToNode = toNode.cloneNode(<span class="literal">true</span>)</span><br><span class="line">          node.replaceChild(cloneFromNode, toNode)</span><br><span class="line">          node.replaceChild(cloenToNode, fromNode)</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Virtual Dom 算法的实现也就是以下三步</strong></p>
<ul>
<li>通过 <code>JS</code> 来模拟创建 <code>DOM</code> 对象</li>
<li>判断两个对象的差异</li>
<li>渲染差异</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> test4 = <span class="keyword">new</span> Element(<span class="string">'div'</span>, &#123; <span class="attr">class</span>: <span class="string">'my-div'</span> &#125;, [<span class="string">'test4'</span>])</span><br><span class="line"><span class="keyword">let</span> test5 = <span class="keyword">new</span> Element(<span class="string">'ul'</span>, &#123; <span class="attr">class</span>: <span class="string">'my-div'</span> &#125;, [<span class="string">'test5'</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> test1 = <span class="keyword">new</span> Element(<span class="string">'div'</span>, &#123; <span class="attr">class</span>: <span class="string">'my-div'</span> &#125;, [test4])</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> test2 = <span class="keyword">new</span> Element(<span class="string">'div'</span>, &#123; <span class="attr">id</span>: <span class="string">'11'</span> &#125;, [test5, test4])</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> root = test1.render()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pathchs = diff(test1, test2)</span><br><span class="line"><span class="built_in">console</span>.log(pathchs)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'开始更新'</span>)</span><br><span class="line">  patch(root, pathchs)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'结束更新'</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<script>
export default {
  mounted () {
    var script = document.createElement("script");
    script.type = "text/javascript"
    script.charset="UTF-8"
    script.src = "http://tajs.qq.com/stats?sId=59154049"
    document.body.appendChild(script);
 }
}
</script></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Sumind</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://sumind.cn/2017/07/22/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%20-%20%E6%A1%86%E6%9E%B6%E9%80%9A%E8%AF%86/">https://sumind.cn/2017/07/22/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%20-%20%E6%A1%86%E6%9E%B6%E9%80%9A%E8%AF%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://sumind.cn">Sumindの世界</a>！</span></div></div><div class="post-meta__tag-list"></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2017/07/25/JavaScript%E7%9F%A5%E8%AF%86%20-%20Generator/"><i class="fa fa-chevron-left">  </i><span>JavaScript知识 - Generator</span></a></div><div class="next-post pull-right"><a href="/2017/07/20/JavaScript%E7%9F%A5%E8%AF%86%20-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D/"><span>JavaScript知识 - 深拷贝浅拷贝</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://gitee.com/sumind/picCloud/raw/master/img/top_img.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2016 - 2020 By Sumind</div><div class="framework-info"><span> - I will be a front-end engineer with soul - </span></div><div class="footer_custom_text">hitokoto</div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"superSample":2,"width":210,"height":420,"position":"right","hOffset":0,"vOffset":-40},"log":false,"tagMode":false});</script></body></html><script type="text/javascript" color="225,225,225" opacity='0.8' zIndex="-2" count="100" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>